{"/home/travis/build/npmtest/node-npmtest-oneapm/test.js":"/* istanbul instrument in package npmtest_oneapm */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-oneapm/lib.npmtest_oneapm.js":"/* istanbul instrument in package npmtest_oneapm */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_oneapm = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_oneapm = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-oneapm/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-oneapm && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_oneapm */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_oneapm\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_oneapm.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_oneapm.rollup.js'] =\n            local.assetsDict['/assets.npmtest_oneapm.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_oneapm.__dirname + '/lib.npmtest_oneapm.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/index.js":"'use strict';\n\n// this file can be included multiple times\n\nvar logger = require('oneapm-logger');\nvar locales = require('./locales');\nvar semver = require('semver');\nvar agent;\nvar API;\n\n/**\n * pipe error to both process.stderr and logger\n *\n * @param error {Error}\n * @param message {String}\n */\nfunction show_error(error, message) {\n  logger.error(error, message);\n\n  // Skip the 500 page error, wait for the server to fix it.\n  if (error && error.statusCode && error.statusCode !== 500 ) {\n    console.error(message);\n    console.error(error.stack);\n  }\n}\n\n/**\n * @param error\n * @returns {*}\n */\nfunction agent_start_cb(error) {\n  if (error) {\n    show_error(error, locales.AGENT_STARTUP_ERROR);\n  } else {\n    return logger.debug(locales.AGENT_CONNECTED);\n  }\n}\n\ntry {\n\n  // nodejs: 0.8.0\n  // iojs  : 1.0.0 2.0.0\n  if (process.version && semver.lt(process.version,'0.8.0')) {\n    throw new Error(locales.NODE_VERSION_TOO_LOW);\n  }\n\n  logger.debug(\"Process uptime  is %d.\", process.uptime());\n  logger.debug(\"process cwd     is %s.\", process.cwd());\n  logger.debug(\"Process title   is %s.\", process.title);\n  logger.debug(\"Process argv    is %s.\", process.argv.join(' '));\n\n  /**\n   * @throw Error if oneapm.js is not found, use ONEAPM_NO_CONFIG_FILE to mute\n   */\n  var config = require('oneapm-config').initialize();\n\n  if (!config.agent_enabled) {\n    logger.info(locales.AGENT_NOT_ENABLED_ERROR);\n\n  } else {\n\n    var Agent = require('./lib/agent.js');\n    agent = new Agent(config);\n\n    var appNames = agent.config.applications();\n    if (appNames.length < 1) {\n      throw new Error(locales.AGENT_NO_NAME_ERROR);\n    }\n\n    var shimmer = require('./lib/shimmer.js');\n    shimmer.patchModule(agent);\n    shimmer.bootstrapInstrumentation(agent);\n    agent.start(agent_start_cb);\n\n    API = require('./api.js');\n\n  }\n} catch (error) {\n  show_error(error, locales.AGENT_BOOTSTRAP_ERROR);\n}\n\nif (!API) {\n  API = require('./stub_api.js');\n}\n\nmodule.exports = new API(agent);\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm-logger/index.js":"var logger = require('./internal/logger')\n\nmodule.exports = logger\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm-logger/internal/logger.js":"'use strict';\n\nvar path = require('path'),\n    Logger = require('bunyan'),\n    config = require('oneapm-config').initialize(),\n    options;\n\n//\"trace\" (10): Logging from external libraries used by your app or very detailed application logging.\n//\"debug\" (20): Anything else, i.e. too verbose to be included in \"info\" level.\n//\"info\" (30): Detail on regular operation.\n//\"warn\" (40): A note on something that should probably be looked at by an operator eventually.\n//\"error\" (50): Fatal for a particular request, but the service/app continues servicing other requests. An operator should look at this soon(ish).\n//\"fatal\" (60): The service/app is going to stop or become unusable now. An operator should definitely look into this soon.\n\nvar LEVELS = [\n    'trace',\n    'debug',\n    'info',\n    'warn',\n    'error',\n    'fatal'\n];\n\nfunction coerce(value) {\n    if (!isNaN(parseInt(value, 10)) && isFinite(value)) {\n        // value is numeric\n        if (value < 10) value = 10;\n        if (value > 60) value = 60;\n    } else if (LEVELS.indexOf(value) === -1) {\n        value = 'info';\n    }\n\n    return value;\n}\n\n// can't use shimmer here because shimmer depends on logger\nvar _level = Logger.prototype.level;\nLogger.prototype.level = function validatingLevel(value) {\n    return _level.call(this, coerce(value));\n};\n\noptions = {\n    name: 'oneapm_bootstrap',\n    stream: process.stdout,\n    level: 'info'\n};\n\n// create bootstrapping logger\nmodule.exports = new Logger(options);\n\noptions = {\n    name: 'oneapm',\n    streams: [{\n        level: coerce(config.logging.level)\n    }]\n};\n\nswitch (config.logging.filepath) {\n    case 'stdout':\n        options.streams[0].stream = process.stdout;\n        break;\n\n    case 'stderr':\n        options.streams[0].stream = process.stderr;\n        break;\n\n    default:\n        options.streams[0].path = config.logging.filepath;\n}\n\n// create the \"real\" logger\nmodule.exports = new Logger(options);\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm-config/index.js":"module.exports = require('./internal/config.js')\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm-config/internal/config.js":"'use strict';\n\nvar util = require('util'),\n    path = require('path'),\n    fs = require('fs'),\n    EventEmitter = require('events').EventEmitter,\n    logger = require('./logger'), \n    NAMES = require('./metrics/names.js'),\n    feature_flag = require('./feature_flags.js'),\n    flatten = require('oneapm-util').flatten,\n    exists = fs.existsSync || path.existsSync;\n\n/**\n * CONSTANTS -- we gotta lotta 'em\n */\nvar DEFAULT_CONFIG_PATH = path.join(__dirname, 'config.default.js');\nvar DEFAULT_CONFIG = require(DEFAULT_CONFIG_PATH).config;\nvar DEFAULT_FILENAME = 'oneapm.js';\nvar AZURE_APP_NAME = 'APP_POOL_ID';\nvar CONFIG_FILE_LOCATIONS = [\n    process.env.ONEAPM_HOME,\n    process.cwd(),\n    process.env.HOME,\n    path.join(__dirname, '..', '..', '..') // above node_modules\n];\n\n// the REPL has no main module\nif (process.mainModule && process.mainModule.filename) {\n    CONFIG_FILE_LOCATIONS.splice(2, 0, path.dirname(process.mainModule.filename));\n}\n\n/*\n * ENV_MAPPING, LIST_VARS, and BOOLEAN_VARS could probably be unified and\n * objectified, but this is simple and works.\n */\nvar ENV_MAPPING = {\n    oneapm_home: \"ONEAPM_HOME\",\n    app_name: \"ONEAPM_APP_NAME\",\n    license_key: \"ONEAPM_LICENSE_KEY\",\n    ssl: \"ONEAPM_USE_SSL\",\n    host: \"ONEAPM_HOST\",\n    port: \"ONEAPM_PORT\",\n    proxy: \"ONEAPM_PROXY_URL\",\n    proxy_host: \"ONEAPM_PROXY_HOST\",\n    proxy_port: \"ONEAPM_PROXY_PORT\",\n    proxy_user: \"ONEAPM_PROXY_USER\",\n    proxy_pass: \"ONEAPM_PROXY_PASS\",\n    ignore_server_configuration: \"ONEAPM_IGNORE_SERVER_CONFIGURATION\",\n    agent_enabled: \"ONEAPM_ENABLED\",\n    apdex_t: \"ONEAPM_APDEX\",\n    capture_params: \"ONEAPM_CAPTURE_PARAMS\",\n    ignored_params: \"ONEAPM_IGNORED_PARAMS\",\n    logging: {\n        level: \"ONEAPM_LOG_LEVEL\",\n        filepath: \"ONEAPM_LOG\"\n    },\n    error_collector: {\n        enabled: \"ONEAPM_ERROR_COLLECTOR_ENABLED\",\n        ignore_status_codes: \"ONEAPM_ERROR_COLLECTOR_IGNORE_ERROR_CODES\"\n    },\n    transaction_tracer: {\n        enabled: \"ONEAPM_TRACER_ENABLED\",\n        transaction_threshold: \"ONEAPM_TRACER_THRESHOLD\",\n        top_n: \"ONEAPM_TRACER_TOP_N\"\n    },\n    debug: {\n        internal_metrics: \"ONEAPM_DEBUG_METRICS\",\n        tracer_tracing: \"ONEAPM_DEBUG_TRACER\"\n    },\n    rules: {\n        name: \"ONEAPM_NAMING_RULES\",\n        ignore: \"ONEAPM_IGNORING_RULES\"\n    },\n    enforce_backstop: \"ONEAPM_ENFORCE_BACKSTOP\",\n    browser_monitoring: {\n        enable: \"ONEAPM_BROWSER_MONITOR_ENABLE\",\n        debug: \"ONEAPM_BROWSER_MONITOR_DEBUG\"\n    },\n    high_security: \"ONEAPM_HIGH_SECURITY\"\n};\n\n// values in list variables are comma-delimited lists\nvar LIST_VARS = [\n    \"ONEAPM_APP_NAME\",\n    \"ONEAPM_IGNORED_PARAMS\",\n    \"ONEAPM_ERROR_COLLECTOR_IGNORE_ERROR_CODES\",\n    \"ONEAPM_IGNORING_RULES\"\n];\n\n// values in object lists are comma-delimited object literals\nvar OBJECT_LIST_VARS = [\n    \"ONEAPM_NAMING_RULES\"\n];\n\n/*\n * Values in boolean variables. Is pretty tolerant about values, but\n * don't get fancy and just use 'true' and 'false', everybody.\n */\nvar BOOLEAN_VARS = [\n    \"ONEAPM_IGNORE_SERVER_CONFIGURATION\",\n    \"ONEAPM_ENABLED\",\n    \"ONEAPM_CAPTURE_PARAMS\",\n    \"ONEAPM_ERROR_COLLECTOR_ENABLED\",\n    \"ONEAPM_TRACER_ENABLED\",\n    \"ONEAPM_DEBUG_METRICS\",\n    \"ONEAPM_DEBUG_TRACER\",\n    \"ONEAPM_ENFORCE_BACKSTOP\",\n    \"ONEAPM_USE_SSL\",\n    \"ONEAPM_BROWSER_MONITOR_ENABLE\",\n    \"ONEAPM_BROWSER_MONITOR_DEBUG\",\n    \"ONEAPM_HIGH_SECURITY\"\n];\n\n// Config keys that can't be set by the server if high_security === true\nvar HIGH_SECURITY_SETTINGS = {\n    ssl: true,\n    capture_params: false\n};\nvar HIGH_SECURITY_KEYS = Object.keys(HIGH_SECURITY_SETTINGS);\n\nfunction isTruthular(setting) {\n    if (setting === undefined || setting === null) return false;\n\n    var normalized = setting.toString().toLowerCase();\n    switch (normalized) {\n        case 'false':\n        case 'f':\n        case 'no':\n        case 'n':\n        case 'disabled':\n        case '0':\n            return false;\n\n        default:\n            return true;\n    }\n}\n\nfunction fromObjectList(setting) {\n    try {\n        return JSON.parse('[' + setting + ']');\n    } catch (error) {\n        logger.error(\"OneAPM configurator could not deserialize object list:\");\n        logger.error(error.stack);\n    }\n}\n\nfunction _findConfigFile() {\n    var candidate, filepath;\n\n    for (var i = 0; i < CONFIG_FILE_LOCATIONS.length; i++) {\n        candidate = CONFIG_FILE_LOCATIONS[i];\n        if (!candidate) continue;\n\n        filepath = path.join(path.resolve(candidate), DEFAULT_FILENAME);\n        if (!exists(filepath)) continue;\n\n        return fs.realpathSync(filepath);\n    }\n}\n\nfunction _failHard() {\n    var mainpath = path.resolve(path.join(process.cwd(), DEFAULT_FILENAME)),\n        altpath = path.resolve(path.dirname(process.mainModule.filename),\n            DEFAULT_FILENAME);\n\n    var locations;\n    if (mainpath !== altpath) {\n        locations = mainpath + \" or\\n\" + altpath;\n    } else {\n        locations = mainpath;\n    }\n\n    throw new Error(\n        \"Unable to find OneAPM module configuration. A default\\n\" +\n        \"configuration file can be copied from \" + DEFAULT_CONFIG_PATH + \"\\n\" +\n        \"and put at \" + locations + \".\"\n    );\n}\n\nfunction Config(config) {\n    EventEmitter.call(this);\n\n    // 1. start by cloning the defaults\n    var basis = JSON.parse(JSON.stringify(DEFAULT_CONFIG));\n    Object.keys(basis).forEach(function cb_forEach(key) {\n        this[key] = basis[key];\n    }, this);\n\n    // 2. initialize undocumented, internal-only default values\n\n    // feature flags are mostly private settings for gating unreleased features\n    // flags are set in the feature_flags.js file\n    this.feature_flag = feature_flag.prerelease;\n\n    // set by environment\n    this.oneapm_home = null;\n    // set by configuration file loader\n    this.config_file_path = null;\n    // set by collector on handshake\n    this.run_id = null;\n    this.application_id = null;\n    this.web_transactions_apdex = {};\n    // how frequently harvester runs\n    this.data_report_period = 60;\n    // feature level of this account\n    this.product_level = 0;\n    // product-level related\n    this.collect_traces = true;\n    this.collect_errors = true;\n\n    this.browser_monitoring.loader = 'rum';\n    this.browser_monitoring.loader_version = '';\n    if (config && config.browser_monitoring && config.browser_monitoring.beacon_host) {\n        this.browser_monitoring.beacon_host = config.browser_monitoring.beacon_host;\n        this.browser_monitoring.beacon_port = config.browser_monitoring.beacon_port;\n        this.browser_monitoring.beacon_apdex_t = config.browser_monitoring.beacon_apdex_t;\n    }\n    // TODO: currently does not support this, but high-security mode requires\n    // that we explicitly state how we handle this feature\n    this.transaction_tracer.record_sql = 'off';\n\n    // 3. override defaults with values from the loaded / passed configuration\n    this._fromPassed(config);\n\n    // 3.5. special values (only Azure environment APP_POOL_ID for now)\n    this._fromSpecial();\n\n    // 4. override config with environment variables\n    this._fromEnvironment();\n\n    // 5. clean up anything that requires postprocessing\n    this._canonicalize();\n\n    // 6. put the version in the config\n    this.version = require('../package.json').version;\n\n    // 7. apply high security overrides\n    if (this.high_security === true) {\n        this._applyHighSecurity();\n    }\n}\nutil.inherits(Config, EventEmitter);\n\n/**\n * Accept any configuration passed back from the server. Will log all\n * recognized, unsupported, and unknown parameters. Some may not be set,\n * depending on the setting of ignore_server_configuration.\n *\n * @param {object} json The config blob sent by OneAPM.\n */\nConfig.prototype.onConnect = function onConnect(json, recursion) {\n    json = json || {};\n    if (this.high_security === true && recursion !== true && json.high_security !== true) {\n        this.agent_enabled = false;\n        this.emit('agent_enabled', false);\n        return;\n    }\n    if (Object.keys(json).length === 0) return;\n\n    Object.keys(json).forEach(function cb_forEach(key) {\n        this._fromServer(json, key);\n    }, this);\n\n    this.emit('change', this);\n};\n\n/**\n * The guts of the logic about how to deal with server-side configuration.\n *\n * @param {object} params A configuration dictionary.\n * @param {string} key    The particular configuration parameter to set.\n */\nConfig.prototype._fromServer = function _fromServer(params, key) {\n    switch (key) {\n        // handled by the connection\n        case 'messages':\n            break;\n\n            // *sigh* Xzibit, etc.\n        case 'agent_config':\n            this.onConnect(params[key], true);\n            break;\n\n            // if it's undefined or null, so be it\n        case 'agent_run_id':\n            this.run_id = params.agent_run_id;\n            break;\n\n        case 'cross_process_id':\n            this.cross_process_id = params.cross_process_id;\n            break;\n\n            // handled by config.onConnect\n        case 'high_security':\n            break;\n\n            // always accept these settings\n        case 'collect_traces':\n        case 'collect_errors':\n        case 'product_level':\n        case 'application_id':\n            this._alwaysUpdateIfChanged(params, key);\n            break;\n\n            // also accept these settings\n        case 'url_rules':\n        case 'metric_name_rules':\n        case 'transaction_name_rules':\n            this._emitIfSet(params, key);\n            break;\n\n            // setting these can be disabled by ignore_server_configuration\n        case 'ssl':\n        case 'apdex_t':\n        case 'web_transactions_apdex':\n        case 'data_report_period':\n        case 'capture_params':\n        case 'ignored_params':\n            this._updateIfChanged(params, key);\n            break;\n        case 'transaction_tracer.enabled':\n            this._updateNestedIfChanged(\n                params,\n                this.transaction_tracer,\n                'transaction_tracer.enabled',\n                'enabled'\n            );\n            break;\n        case 'transaction_tracer.transaction_threshold':\n            this._updateNestedIfChanged(\n                params,\n                this.transaction_tracer,\n                'transaction_tracer.transaction_threshold',\n                'transaction_threshold'\n            );\n            break;\n        case 'error_collector.enabled':\n            this._updateNestedIfChanged(\n                params,\n                this.error_collector,\n                'error_collector.enabled',\n                'enabled'\n            );\n            break;\n        case 'error_collector.ignore_status_codes':\n            this._updateNestedIfChanged(\n                params,\n                this.error_collector,\n                'error_collector.ignore_status_codes',\n                'ignore_status_codes'\n            );\n            this._canonicalize();\n            break;\n\n        case 'collect_analytics_events':\n            // never enable from server-side\n            // but we allow the server to disable\n            if (params.collect_analytics_events === false)\n                this.transaction_events.enabled = false;\n            break;\n\n        case 'transaction_events.max_samples_stored':\n            this._updateNestedIfChanged(\n                params,\n                this.transaction_events,\n                key,\n                'max_samples_stored'\n            );\n            break;\n\n        case 'transaction_events.max_samples_per_minute':\n            this._updateNestedIfChanged(\n                params,\n                this.transaction_events,\n                key,\n                'max_samples_per_minute'\n            );\n            break;\n\n        case 'transaction_events.enabled':\n            this._updateNestedIfChanged(\n                params,\n                this.transaction_events,\n                key,\n                'enabled'\n            );\n            break;\n\n            // these are used by browser_monitoring\n            // and the api.getRUMHeader() method\n        case 'js_agent_file':\n        case 'js_agent_loader_file':\n        case 'beacon':\n        case 'error_beacon':\n        case 'browser_key':\n        case 'js_agent_loader':\n            this._updateNestedIfChangedRaw(\n                params,\n                this.browser_monitoring,\n                key,\n                key\n            );\n            break;\n\n        case 'browser_monitoring.loader':\n            this._updateNestedIfChangedRaw(\n                params,\n                this.browser_monitoring,\n                key,\n                'loader'\n            );\n            break;\n\n            // these settings aren't supported by the agent (yet)\n        case 'sampling_rate':\n        case 'episodes_file':\n        case 'episodes_url':\n        case 'cross_application_tracing':\n        case 'encoding_key':\n        case 'trusted_account_ids':\n        case 'transaction_tracer.record_sql':\n        case 'slow_sql.enabled':\n        case 'rum.load_episodes_file':\n            this.logUnsupported(params, key);\n            break;\n\n        default:\n            this.logUnknown(params, key);\n    }\n};\n\n/**\n * Change a value sent by the collector if and only if it's different from the\n * value we already have. Emit an event with the key name and the new value,\n * and log that the value has changed.\n *\n * @param {object} json Config blob sent by collector.\n * @param {string} key  Value we're looking to set.\n */\nConfig.prototype._alwaysUpdateIfChanged = function _alwaysUpdateIfChanged(json, key) {\n    var value = json[key];\n    if (value !== null && value !== undefined && this[key] !== value) {\n        if (Array.isArray(value) && Array.isArray(this[key])) {\n            value.forEach(function cb_forEach(element) {\n                if (this[key].indexOf(element) === -1) this[key].push(element);\n            }, this);\n        } else {\n            this[key] = value;\n        }\n        this.emit(key, value);\n        logger.debug(\"Configuration of %s was changed to %s by OneAPM.\", key, value);\n    }\n};\n\n/**\n * Change a value sent by the collector if and only if it's different from the\n * value we already have. Emit an event with the key name and the new value,\n * and log that the value has changed. Parameter will be ignored if\n * ignore_server_configuration is set.\n *\n * @param {object} json Config blob sent by collector.\n * @param {string} key  Value we're looking to set.\n */\nConfig.prototype._updateIfChanged = function _updateIfChanged(json, key) {\n    this._updateNestedIfChanged(json, this, key, key);\n};\n\n/**\n * Some parameter values are nested, need a simple way to change them as well.\n * Will merge local and remote if and only if both are arrays. Parameter will\n * be ignored if ignore_server_configuration is set.\n *\n * @param {object} remote    JSON sent from OneAPM.\n * @param {object} local     A portion of this configuration object.\n * @param {string} remoteKey The name sent by OneAPM.\n * @param {string} localKey  The local name.\n */\nConfig.prototype._updateNestedIfChanged = function _updateNestedIfChanged(remote, local, remoteKey, localKey) {\n    if (this.ignore_server_configuration) return this.logDisabled(remote, remoteKey);\n    // if high-sec mode is enabled, we do not accept server changes to high-sec\n    if (this.high_security && HIGH_SECURITY_KEYS.indexOf(localKey) !== -1) {\n        return this.logDisabled(remote, remoteKey);\n    } else return this._updateNestedIfChangedRaw(remote, local, remoteKey, localKey);\n};\n\nConfig.prototype._updateNestedIfChangedRaw = function _updateNestedIfChangedRaw(\n    remote, local, remoteKey, localKey) {\n    var value = remote[remoteKey];\n    if (value !== null && value !== undefined && local[localKey] !== value) {\n        if (Array.isArray(value) && Array.isArray(local[localKey])) {\n            value.forEach(function cb_forEach(element) {\n                if (local[localKey].indexOf(element) === -1) local[localKey].push(element);\n            });\n        } else {\n            local[localKey] = value;\n        }\n        this.emit(remoteKey, value);\n        logger.debug(\"Configuration of %s was changed to %s by OneAPM.\", remoteKey, value);\n    }\n};\n\n/**\n * Some parameter values are just to be passed on.\n *\n * @param {object} json Config blob sent by collector.\n * @param {string} key  Value we're looking to set.\n */\nConfig.prototype._emitIfSet = function _emitIfSet(json, key) {\n    var value = json[key];\n    if (value !== null && value !== undefined) this.emit(key, value);\n};\n\n/**\n * The agent would normally do something with this parameter, but server-side\n * configuration is disabled via ignore_server_configuration.\n *\n * @param {object} json Config blob sent by collector.\n * @param {string} key  Value the agent won't set.\n */\nConfig.prototype.logDisabled = function logDisabled(json, key) {\n    var value = json[key];\n    if (value !== null && value !== undefined) {\n        logger.debug(\n            \"Server-side configuration of %s is currently disabled by local configuration. \" +\n            \"(Server sent value of %j.)\",\n            key,\n            value\n        );\n    }\n};\n\n/**\n * Help support out by putting in the logs the fact that we don't currently\n * support the provided configuration key, and including the sent value.\n *\n * @param {object} json Config blob sent by collector.\n * @param {string} key  Value the agent doesn't set.\n */\nConfig.prototype.logUnsupported = function logUnsupported(json, key) {\n    var flavor;\n    if (this.ignore_server_configuration) {\n        flavor = \"ignored\";\n    } else {\n        flavor = \"not supported by the Node.js agent\";\n    }\n\n    var value = json[key];\n    if (value !== null && value !== undefined) {\n        logger.debug(\n            \"Server-side configuration of %s is currently %s. (Server sent value of %j.)\",\n            key,\n            flavor,\n            value\n        );\n        this.emit(key, value);\n    }\n};\n\n/**\n * The agent knows nothing about this parameter.\n *\n * @param {object} json Config blob sent by collector.\n * @param {string} key  Value the agent knows nothing about.\n */\nConfig.prototype.logUnknown = function logUnknown(json, key) {\n    var value = json[key];\n    logger.debug(\n        \"OneAPM sent unknown configuration parameter %s with value %j.\",\n        key,\n        value\n    );\n};\n\n/**\n * Ensure that the apps names are always returned as a list.\n */\nConfig.prototype.applications = function applications() {\n    var apps = this.app_name;\n\n    if (Array.isArray(apps) && apps.length > 0) {\n        return apps;\n    }\n    if (apps && typeof apps === 'string') {\n        return [apps];\n    } else {\n        return [];\n    }\n};\n\n/**\n * Ensure that the tier names are always returned as a list.\n */\nConfig.prototype.tiernames = function tiernames() {\n    var tier_name = this.tier_name;\n\n    if (Array.isArray(tier_name) && tier_name.length > 0) {\n        return tier_name;\n    }\n    if (tier_name && typeof tier_name === 'string') {\n        return [tier_name];\n    } else {\n        return [];\n    }\n};\n\n/**\n * Safely overwrite defaults with values passed to constructor.\n *\n * @param object external The configuration being loaded.\n * @param object internal Whichever chunk of the config being overrridden.\n */\nConfig.prototype._fromPassed = function _fromPassed(external, internal) {\n    if (!external) return;\n    if (!internal) internal = this;\n\n    Object.keys(external).forEach(function cb_forEach(key) {\n        // if it's not in the defaults, it doesn't exist\n        if (internal[key] === undefined) return;\n\n        var node = external[key];\n        if (Array.isArray(node)) {\n            internal[key] = node;\n        } else if (typeof node === 'object') {\n            this._fromPassed(node, internal[key]);\n        } else {\n            internal[key] = node;\n        }\n    }, this);\n};\n\n/**\n * Some values should be picked up only if they're not otherwise set, like\n * the Windows / Azure application name. Don't set it if there's already\n * a non-empty value set via the configuration file, and allow these\n * values to be overwritten by environment variables. Just saves a step for\n * PaaS users who don't want to have multiple settings for a single piece\n * of configuration.\n */\nConfig.prototype._fromSpecial = function _fromSpecial() {\n    var name = this.app_name;\n    if (name === null || name === undefined || name === '' ||\n        (Array.isArray(name) && name.length === 0)) {\n        var azureName = process.env[AZURE_APP_NAME];\n        if (azureName) this.app_name = azureName.split(',');\n    }\n};\n\n/**\n * Recursively visit the nodes of the constant containing the mapping between\n * environment variable names, overriding any configuration values that are\n * found in the environment. Operates purely via side effects.\n *\n * @param object metadata The current level of the mapping object. Should never\n *                        need to set this yourself.\n * @param object data     The current level of the configuration object. Should\n *                        never need to set this yourself.\n */\nConfig.prototype._fromEnvironment = function _fromEnvironment(metadata, data) {\n    if (!metadata) metadata = ENV_MAPPING;\n    if (!data) data = this;\n\n    Object.keys(metadata).forEach(function cb_forEach(value) {\n        // if it's not in the config, it doesn't exist\n        if (data[value] === undefined) return;\n\n        var node = metadata[value];\n        if (typeof node === 'string') {\n            var setting = process.env[node];\n            if (setting) {\n                if (LIST_VARS.indexOf(node) > -1) {\n                    data[value] = setting.split(',').map(function cb_map(k) {\n                        return k.trim();\n                    });\n                } else if (OBJECT_LIST_VARS.indexOf(node) > -1) {\n                    data[value] = fromObjectList(setting);\n                } else if (BOOLEAN_VARS.indexOf(node) > -1) {\n                    data[value] = isTruthular(setting);\n                } else {\n                    data[value] = setting;\n                }\n            }\n        } else {\n            // don't crash if the mapping has config keys the current config doesn't.\n            if (!data[value]) data[value] = {};\n            this._fromEnvironment(node, data[value]);\n        }\n    }, this);\n};\n\n/**\n * Depending on how the status codes are set, they could be strings, which\n * makes strict equality testing / indexOf fail. To keep things cheap, parse\n * them once, after configuration has finished loading. Other one-off shims\n * based on special properties of configuration values should go here as well.\n */\nConfig.prototype._canonicalize = function _canonicalize() {\n    var codes = this.error_collector && this.error_collector.ignore_status_codes;\n    if (codes) {\n        this.error_collector.ignore_status_codes = codes.map(function cb_map(code) {\n            return parseInt(code, 10);\n        });\n    }\n};\n\n/**\n * This goes through the settings that high security mode needs and coerces\n * them to be correct.\n */\nConfig.prototype._applyHighSecurity = function() {\n    var self = this;\n    HIGH_SECURITY_KEYS.forEach(function(key) {\n        var hsValue = HIGH_SECURITY_SETTINGS[key];\n        if (self[key] !== hsValue) {\n            logger.warn('High Security Mode: %s was set to %s, coercing to %s',\n                key, self[key], hsValue);\n            self[key] = hsValue;\n            self.emit(key, hsValue);\n        }\n    });\n};\n\n/**\n * The agent will use the supportability metrics object if it's\n * available.\n *\n * @param string suffix Supportability metric name.\n * @param number duration Milliseconds that the measured operation took.\n */\nConfig.prototype.measureInternal = function measureInternal(suffix, duration) {\n    if (this.debug.supportability) {\n        var internal = this.debug.supportability;\n        internal.measureMilliseconds(NAMES.SUPPORTABILITY + suffix, null, duration);\n    }\n};\n\nConfig.prototype.validateFlags = function validateFlags() {\n    Object.keys(this.feature_flag).forEach(function cb_forEach(key) {\n        if (feature_flag.released.indexOf(key) > -1)\n            logger.warn('Feature flag ' + key + ' has been released');\n        if (feature_flag.unreleased.indexOf(key) > -1)\n            logger.warn('Feature flag ' + key + ' has been deprecated');\n    });\n};\n\n/**\n * Get a JSONifiable object containing all settings we want to report to the\n * collector and store in the environment_values table.\n *\n * @return Object containing simple key-value pairs of settings\n */\nConfig.prototype.publicSettings = function publicSettings() {\n    var settings = {};\n\n    for (var key in this) {\n        if (this.hasOwnProperty(key)) settings[key] = this[key];\n    }\n\n    // Agent-side setting is 'enable', but collector-side setting is\n    // 'auto_instrument'. Send both values up.\n    settings.browser_monitoring.auto_instrument = settings.browser_monitoring.enable;\n    // Remove simple circular references\n    settings = JSON.parse(JSON.stringify(settings));\n\n    settings = flatten({}, '', settings);\n\n    return settings;\n};\n\n/**\n * Create a configuration, either from a configuration file or the node\n * process's environment.\n *\n * For configuration via file, check these directories, in order, for a\n * file named 'oneapm.js':\n *\n *   1. The process's current working directory at startup.\n *   2. The same directory as the process's main module (i.e. the filename\n *      passed to node on the command line).\n *   3. The directory pointed to by the environment variable ONEAPM_HOME.\n *   4. The current process's HOME directory.\n *   5. If this module is installed as a dependency, the directory above the\n *      node_modules folder in which oneapm is installed.\n *\n * For configration via environment (useful on Joyent, Azure, Heroku, or\n * other PaaS offerings), set ONEAPM_NO_CONFIG_FILE to something truthy\n * and read README.md for details on what configuration variables are\n * necessary, as well as a complete enumeration of the other available\n * variables.\n *\n * @param {object} config Optional configuration to be used in place of a\n *                        config file.\n */\nfunction initialize(config) {\n    if (config) return new Config(config);\n\n    if (isTruthular(process.env.ONEAPM_NO_CONFIG_FILE)) {\n        config = new Config({});\n        if (config.oneapm_home) delete config.oneapm_home;\n        return config;\n    }\n\n    var filepath = _findConfigFile();\n    if (!filepath) return _failHard();\n\n    try {\n        config = new Config(require(filepath).config);\n        config.config_file_path = filepath;\n        logger.debug(\"Using configuration file %s.\", filepath);\n\n        config.validateFlags();\n\n        return config;\n    } catch (error) {\n        throw new Error(\n            \"Unable to read configuration file \" + filepath + \". A default\\n\" +\n            \"configuration file can be copied from \" + DEFAULT_CONFIG_PATH + \"\\n\" +\n            \"and renamed to 'oneapm.js' in the directory from which you'll be starting\\n\" +\n            \"your application.\"\n        );\n    }\n}\n\n/**\n * Preserve the legacy initializer, but also allow consumers to manage their\n * own configuration if they choose.\n */\nConfig.initialize = initialize;\n\nmodule.exports = Config;","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm-config/internal/logger.js":"// ignore all config log now\n// we will implement a new one later\n\nexports.debug = function() {\n\t// ignore\n}\n\nexports.warn = function() {\n\t// ignore\n}\n\nexports.error = function() {\n\t// ignore\n}\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm-config/internal/metrics/names.js":"'use strict';\n\nvar ERRORS = {\n  PREFIX : 'Errors/',\n  ALL    : 'Errors/all',\n  WEB    : 'Errors/allWeb',\n  OTHER    : 'Errors/allOther'\n};\n\nvar EVENTS = {\n  WAIT : 'Events/wait'\n};\n\nvar MEMORY = {\n  PHYSICAL : 'Memory/Used'\n};\n\nvar CPU = {\n  USERUtilization    :  'CPU/User/Utilization'\n}\n\nvar VIEW = {\n  PREFIX : 'View/',\n  RENDER : '/Rendering'\n};\n\nvar DATASTORE = {\n  PREFIX    : 'Datastore/',\n  STATEMENT : 'Datastore/statement',\n  OPERATION : 'Datastore/operation',\n  INSTANCE  : 'Datastore/instance',\n  ALL       : 'Datastore/all',\n  WEB       : 'Datastore/allWeb',\n  OTHER     : 'Datastore/allOther'\n};\n\nvar DB = {\n  PREFIX    : 'Database/',\n  STATEMENT : 'Database/statement',\n  OPERATION : 'Database/operation',\n  INSTANCE  : 'Database/instance',\n  ALL       : 'Database/all',\n  WEB       : 'Database/allWeb',\n  OTHER     : 'Database/allOther'\n};\n\nvar EXTERNAL = {\n  PREFIX : 'External/',\n  ALL    : 'External/all',\n  WEB    : 'External/allWeb',\n  THRIFT : 'External/allThrift',\n  OTHER  : 'External/allOther'\n};\n\nvar MEMCACHE = {\n  PREFIX    : 'Memcached',\n  OPERATION : DATASTORE.OPERATION + '/Memcached/',\n  INSTANCE  : DATASTORE.INSTANCE  + '/Memcached/'\n};\n\nvar MONGODB = {\n  PREFIX    : 'MongoDB',\n  STATEMENT : DATASTORE.STATEMENT + '/MongoDB/',\n  OPERATION : DATASTORE.OPERATION + '/MongoDB/',\n  INSTANCE  : DATASTORE.INSTANCE  + '/MongoDB/'\n};\n\nvar MYSQL = {\n  PREFIX    : 'MySQL',\n  STATEMENT : DB.STATEMENT + '/MySQL/',\n  OPERATION : DB.OPERATION + '/MySQL/',\n  INSTANCE  : DB.INSTANCE  + '/MySQL/'\n};\n\nvar MYSQL2 = {\n  PREFIX    : 'MySQL2',\n  STATEMENT : DB.STATEMENT + '/MySQL2/',\n  OPERATION : DB.OPERATION + '/MySQL2/',\n  INSTANCE  : DB.INSTANCE  + '/MySQL2/'\n};\n\nvar POSTGRES = {\n  PREFIX    : 'Postgres',\n  STATEMENT : DB.STATEMENT + '/Postgres/',\n  OPERATION : DB.OPERATION + '/Postgres/',\n  INSTANCE  : DB.INSTANCE  + '/Postgres/'\n};\n\nvar REDIS = {\n  PREFIX    : 'Redis',\n  OPERATION : DATASTORE.OPERATION + '/Redis/',\n  INSTANCE  : DATASTORE.INSTANCE  + '/Redis/'\n};\n\nvar THRIFT = {\n  PREFIX    : 'Thrift'\n};\n\nvar CASSANDRA = {\n  PREFIX    : 'Cassandra',\n  OPERATION : DATASTORE.OPERATION + '/Cassandra/',\n  INSTANCE  : DATASTORE.INSTANCE  + '/Cassandra/'\n};\n\nvar EXPRESS = {\n  PREFIX : 'Expressjs/'\n};\n\nvar RESTIFY = {\n  PREFIX : 'Restify/'\n};\n\nvar HAPI = {\n  PREFIX : 'Hapi/'\n};\n\nvar THINKJS = {\n    PREFIX : 'Thinkjs'\n};\n\nmodule.exports = {\n  URI              : 'Uri',\n  NORMALIZED       : 'NormalizedUri',\n  APDEX            : 'Apdex',\n  WEB              : 'WebTransaction',\n  HTTP             : 'HttpDispatcher',\n  CONTROLLER       : 'Controller',\n  CUSTOM           : 'Custom',\n  SUPPORTABILITY   : 'Supportability/',\n  QUEUETIME        : 'WebFrontend/QueueTime',\n  ERRORS           : ERRORS,\n  EVENTS           : EVENTS,\n  CPU              : CPU,\n  MEMORY           : MEMORY,\n  VIEW             : VIEW,\n  DB               : DB,\n  DATASTORE        : DATASTORE,\n  EXTERNAL         : EXTERNAL,\n  MEMCACHE         : MEMCACHE,\n  MONGODB          : MONGODB,\n  MYSQL            : MYSQL,\n  MYSQL2           : MYSQL2,\n  POSTGRES         : POSTGRES,\n  CASSANDRA        : CASSANDRA,\n  REDIS            : REDIS,\n  THRIFT           : THRIFT,\n  EXPRESS          : EXPRESS,\n  RESTIFY          : RESTIFY,\n  HAPI             : HAPI,\n  THINKJS       :THINKJS, \n  ACTION_DELIMITER : '/'\n};\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm-config/internal/feature_flags.js":"'use strict';\n\n// unreleased flags gating an active feature\nexports.prerelease = {\n  proxy: true,\n  custom_instrumentation: true\n};\n\n// flags that are no longer used for released features\nexports.released = [\n  'released',\n  'express4',\n  'insights',\n];\n\n// flags that are no longer used for unreleased features\nexports.unreleased = [\n  'unreleased'\n];\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm-util/index.js":"exports['codec'] = require('./lib/codec.js')\nexports['deep-equal'] = require('./lib/deep-equal.js')\nexports['flatten'] = require('./lib/flatten.js')\nexports['full-url'] = require('./lib/full-url.js')\nexports['generate-guid'] = require('./lib/generate-guid.js')\nexports['inject-script'] = require('./lib/inject-script.js')\nexports['last-io'] = require('./lib/last-io.js')\nexports['myip'] = require('./lib/myip.js')\nexports['stack'] = require('./lib/stack.js')\nexports['stream-sink'] = require('./lib/stream-sink.js')\nexports['sum-children'] = require('./lib/sum-children.js')\nexports['urltils'] = require('./lib/urltils.js')\nexports['sql'] = {\n\t'obfuscate': require('./lib/sql/obfuscate.js')\n}\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm-util/lib/codec.js":"'use strict';\n\nvar zlib = require('zlib');\n\nmodule.exports = {\n  /**\n   * zlib works with streams, so this must be used asynchronously.\n   *\n   * Take in an object literal, and deflate and then Base64 encode it.\n   *\n   * @param {string} params The parameters object.\n   * @param {Function} callback The callback to take the results.\n   *                            The first parameter is any errors\n   *                            from decoding, and the second\n   *                            parameter is the encoded parameters\n   *                            object.\n   */\n  encode : function encode(data, callback) {\n    zlib.deflate(JSON.stringify(data), function cb_deflate(err, raw) {\n      if (err) return callback(err);\n\n      return callback(null, raw.toString('base64'));\n    });\n  },\n\n  /**\n   * zlib works with streams, so this must be used asynchronously.\n   *\n   * Base64 decode a string, decompress it, and then turn the\n   * results back into a JavaScript object.\n   *\n   * @param {string} encoded The encoded data.\n   * @param {Function} callback The callback to take the results,\n   *                            1st parameter is any errors from\n   *                            decoding, 2nd parameter is the\n   *                            decoded data object.\n   */\n  decode : function decode(encoded, callback) {\n    zlib.inflate(new Buffer(encoded, 'base64'), function cb_inflate(err, raw) {\n      if (err) return callback(err);\n\n      try {\n        return callback(null, JSON.parse(raw));\n      }\n      catch (error) {\n        return callback(error);\n      }\n    });\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm-util/lib/deep-equal.js":"'use strict';\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) === '[object Arguments]';\n}\n\nfunction slice(args) {\n  // Array.prototype.slice on arguments arraylike is expensive\n  var l = args.length, a = [], i;\n  for (i = 0; i < l; i++) {\n    a[i] = args[i];\n  }\n  return a;\n}\n\n/**\n * This is a node-specific version of deepEquals, modeled on bits and pieces\n * of loads of other implementations of this algorithm, most notably the\n * one in the Node.js source and Underscore's. It doesn't throw and handles\n * cycles.\n *\n * Everybody who writes one of these functions puts the documentation\n * inline, which makes it incredibly hard to follow. Here's what this version\n * of the algorithm does, in order:\n *\n * 1. === only tests objects and and functions by reference. Null is an object.\n *    Any pairs of identical entities failing this test are therefore objects\n *    (including null), which need to be recursed into and compared attribute by\n *    attribute.\n * 2. Since the only matching entities to get to this test must be objects, if\n *    a or b is not an object, they're clearly not the same. All unfiltered a\n *    and b getting are objects (including null).\n * 3. null is an object, but null === null. All unfiltered a and b are non-null\n *    objects.\n * 4. Buffers need to be special-cased because they live partially on the wrong\n *    side of the C++ / JavaScript barrier. Still, calling this on structures\n *    that can contain Buffers is a bad idea, because they can contain\n *    multiple megabytes of data and comparing them byte-by-byte is hella\n *    expensive. buffertools is a better solution here, but this version of\n *    this code is dependency free.\n * 5. It's much faster to compare dates by numeric value than by lexical value.\n * 6. Same goes for Regexps.\n * 7. The parts of an arguments list most people care about are the arguments\n *    themselves, not the callee, which you shouldn't be looking at anyway.\n * 8. Objects are more complex:\n *    a. ensure that a and b are on the same constructor chain\n *    b. ensure that a and b have the same number of own properties (which is\n *       what Object.keys returns).\n *    c. ensure that cyclical references don't blow up the stack.\n *    d. ensure that all the key names match (faster)\n *    e. esnure that all of the associated values match, recursively (slower)\n *\n * (SOMEWHAT UNTESTED) ASSUMPTIONS:\n *\n * o Functions are only considered identical if they unify to the same\n *   reference. To anything else is to invite the wrath of the halting problem.\n * o V8 is smart enough to optimize treating an Array like any other kind of\n *   object.\n * o Users of this function are cool with mutually recursive data structures\n *   that are otherwise identical being treated as the same.\n */\nfunction deeper(a, b, ca, cb) {\n  if (a === b) {\n    return true;\n  }\n  else if (typeof a !== 'object' || typeof b !== 'object') {\n    return false;\n  }\n  else if (a === null || b === null) {\n    return false;\n  }\n  else if (Buffer.isBuffer(a) && Buffer.isBuffer(b)) {\n    if (a.length !== b.length) return false;\n\n    // potentially incredibly expensive\n    for (var i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;\n\n    return true;\n  }\n  else if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime();\n  }\n  else if (a instanceof RegExp && b instanceof RegExp) {\n    return a.source     === b.source &&\n           a.global     === b.global &&\n           a.multiline  === b.multiline &&\n           a.lastIndex  === b.lastIndex &&\n           a.ignoreCase === b.ignoreCase;\n  }\n  else if (isArguments(a) || isArguments(b)) {\n    if (!(isArguments(a) && isArguments(b))) return false;\n\n    return deeper(slice(a), slice(b), ca, cb);\n  }\n  else {\n    if (a.constructor !== b.constructor) return false;\n\n    var ka = Object.keys(a), kb = Object.keys(b);\n    if (ka.length !== kb.length) return false;\n\n    var cal = ca.length;\n    while (cal--) if (ca[cal] === a) return cb[cal] === b;\n    ca.push(a); cb.push(b);\n\n    ka.sort(); kb.sort();\n    for (var j = ka.length - 1; j >= 0; j--) if (ka[j] !== kb[j]) return false;\n\n    var key;\n    for (var k = ka.length - 1; k >= 0; k--) {\n      key = ka[k];\n      if (!deeper(a[key], b[key], ca, cb)) return false;\n    }\n\n    ca.pop(); cb.pop();\n\n    return true;\n  }\n}\n\nmodule.exports = function exports(a, b) { return deeper(a, b, [], []); };\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm-util/lib/flatten.js":"/**\n * Flatten nested maps of JSONifiable data.\n *\n * Ex: {a: 5, b: {c: true, d: 7}} -> {a: 5, 'b.c': true, 'b.d': 7}\n *\n * @param result Object to place key-value pairs into, normally called with {}\n * @param prefix Prefix for keys, normally called with ''\n * @param obj    Object to be flattened\n *\n * @return Object with flattened key-value pairs\n */\nmodule.exports = function flatten(result, prefix, obj, seen) {\n  seen = seen || [];\n  seen.push(obj);\n\n  for (var key in obj) {\n\n    if (seen.indexOf(obj[key]) > -1) {\n      continue;\n    }\n\n    if (obj[key] instanceof Object) flatten(result, prefix + key + '.', obj[key], seen);\n    else result[prefix + key] = obj[key];\n  }\n\n  return result;\n};\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm-util/lib/full-url.js":"function fullUrl(request) {\n\tif (/^\\//.test(request.url)) {\n\t\tvar protocol = request.ssl ? 'https' : 'http';\n\t\tvar hostAndPort = request.headers['host']\n\t\tif (!hostAndPort) {\n\t\t\tvar localAddress = request.socket.localAddress\n\t\t\tvar localPort = request.socket.localPort\n\t\t\t// IPv6\n\t\t\tif (localAddress.indexOf(':') !== -1) {\n\t\t\t\t// \"Format for Literal IPv6 Addresses in URL's\"\n\t\t\t\t//   https://tools.ietf.org/html/rfc2732\n\t\t\t\t// \"Representing IPv6 Zone Identifiers in Address Literals and Uniform Resource Identifiers\"\n\t\t\t\t//   https://tools.ietf.org/html/rfc6874\n\t\t\t\thostAndPort = '[' + localAddress + ']' + ':' + localPort\n\t\t\t}\n\t\t\t// IPv4\n\t\t\telse {\n\t\t\t\thostAndPort = localAddress + ':' + localPort\n\t\t\t}\n\t\t}\n\t\treturn protocol + '://' + hostAndPort + request.url\n\t}\n\telse {\n\t\treturn request.url;\n\t}\n}\n\nmodule.exports = fullUrl;","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm-util/lib/generate-guid.js":"function generateGuid() {\n\t// 16 chars: [a-z0-9]\n\treturn Math.random().toString(36).substr(2, 16);\n}\n\nmodule.exports = exports = generateGuid;","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm-util/lib/inject-script.js":"/**\n * Created by yan on 15-8-5.\n */\nvar path = require('path');\n// var logger = require('oneapm-logger')\n//   .child({component: 'api-inject-script'});\n\nvar loading = false;\nvar inline_content_cache = {};\n\n/**\n *\n * @param js_agent_loader\n */\nfunction set_cache(js_agent_loader) {\n  loading = true;\n  var js_agent_loader_url = \"http:\" + js_agent_loader;\n  var req = require('http').request(js_agent_loader_url, function (res) {\n    var buf = [];\n    var buf_len = 0;\n    res.on('data', function (r) {\n      buf.push(r);\n      buf_len += r.length;\n    });\n    res.on('end', function () {\n      loading = false;\n      var content = Buffer.concat(buf, buf_len);\n      inline_content_cache[js_agent_loader] = '</script><script type=\"text/javascript\">' + content.toString('UTF-8');\n      // logger.debug('get inline script content ', {\n      //   js_agent_loader: js_agent_loader,\n      //   content: inline_content_cache[js_agent_loader]\n      // });\n      // logger.info('updated inline_content_cache', Object.keys(inline_content_cache));\n    });\n  });\n\n  // logger.info('requesting %s ', js_agent_loader_url);\n  req.end();\n}\n\n/**\n *  return inline or external script for BI features\n *\n * @since v1.2.5\n *\n * @param js_agent_loader {string} BI script file location, normally it will look like //tpm.oneapm.com/static/js/bw-loader-411.4.3.js\n * @param config {Object} agent config object\n * @returns {string}\n */\nmodule.exports = function (js_agent_loader, config) {\n  var external_link = '</script><script type=\"text/javascript\" src=\"' + js_agent_loader + '\">';\n\n  var isProxy = (config.proxy.length + config.proxy_host.length) > 0;\n\n  if (config.is_js_text && !isProxy) {\n\n    if (inline_content_cache[js_agent_loader]) {\n      return inline_content_cache[js_agent_loader];\n    } else if (!loading) {\n      set_cache(js_agent_loader);\n    }\n  }\n\n  return external_link;\n};","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm-util/lib/last-io.js":"var assert = require('assert')\n\nfunction markOrUpdate(socket) {\t\n\tif (!socket.hasOwnProperty('__OneAPM_LastIO')) {\n\t\tsocket.__OneAPM_LastIO = {\n\t\t\tbytesRead: socket.bytesRead,\n\t\t\tbytesWritten: socket.bytesWritten\n\t\t}\n\t}\n\telse {\n\t\tsocket.__OneAPM_LastIO.bytesRead = socket.bytesRead\n\t\tsocket.__OneAPM_LastIO.bytesWritten = socket.bytesWritten\n\t}\n}\n\nfunction bytesRead(socket) {\t\n\tvar last = socket.hasOwnProperty('__OneAPM_LastIO') ? socket.__OneAPM_LastIO.bytesRead : 0\n\treturn socket.bytesRead - last\n}\n\nfunction bytesWritten(socket) {\t\n\tvar last = socket.hasOwnProperty('__OneAPM_LastIO') ? socket.__OneAPM_LastIO.bytesWritten : 0\n\treturn socket.bytesWritten - last\n}\n\nexports.markOrUpdate = markOrUpdate\nexports.bytesRead = bytesRead\nexports.bytesWritten = bytesWritten\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm-util/lib/myip.js":"'use strict';\n\nvar os = require('os');\n\n/**\n * Retrieve local IPs (IPv4 only).\n *\n * @return List of IP string, or empty list.\n */\nfunction myip() {\n    var ip_list = [];\n    var nifs = os.networkInterfaces();\n    for (var name in nifs) {\n        var items = nifs[name];\n        items.forEach(function(item) {\n            if (!item.internal && item.family === 'IPv4') {\n                ip_list.push(item.address);\n            }\n        })\n    }\n    return ip_list.sort();\n}\n\nmodule.exports = exports = myip;","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm-util/lib/stack.js":"var path = require( 'path' );\nvar ONEAPM_MODULE_ROOT = path.resolve(__dirname, '../..')\n\nfunction formatStack(stack) {\n  if( !stack ) return '';\n  // remove error message and instrumentation frames from stack trace\n  return stack.split('\\n').slice(1).filter(notOneAPM).join('\\n');\n}\n\nfunction notOneAPM(frame) {\n  return frame.indexOf(ONEAPM_MODULE_ROOT) === -1\n}\n\nexports.formatStack = formatStack;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm-util/lib/stream-sink.js":"'use strict';\n\nvar EventEmitter = require('events').EventEmitter\n  , util         = require('util')\n  ;\n\n/**\n * Pipe a readable stream into this sink that fulfills the Writable Stream\n * contract and the callback will be fired when the stream has been completely\n * read.\n */\nfunction StreamSink(callback) {\n  EventEmitter.call(this);\n\n  this.callback = callback;\n  this.sink = '';\n  this.writable = true;\n\n  var sink = this;\n  this.on('error', function handle_error(error) {\n    sink.writable = false;\n    callback(error);\n  });\n}\nutil.inherits(StreamSink, EventEmitter);\n\nStreamSink.prototype.write = function write(string) {\n  if (!this.writable) {\n    this.emit('error', new Error(\"Sink no longer writable!\"));\n    return false;\n  }\n\n  // Explicitly copy buffer contents so we are sure to release references to\n  // the TLS slab buffer region.\n  // I guess it is a potential bottle neck, because we are doing lots of string concat here\n  this.sink += string.toString();\n\n  return true;\n};\n\nStreamSink.prototype.end = function end() {\n  this.writable = false;\n\n  this.callback(null, this.sink);\n};\n\nStreamSink.prototype.destroy = function destroy() {\n  this.emit('close');\n  this.writable = false;\n\n  delete this.sink;\n};\n\nmodule.exports = StreamSink;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm-util/lib/sum-children.js":"'use strict';\n\n/**\n * Given an ordered list of disjoint intervals and a new interval to fold into\n * it, determine if the new interval is a sub-interval (in which case it's\n * redundant), an overlapping interval (in which case, replace the most recent\n * interval on the list with an interval representing the union of the new and\n * last intervals), or otherwise (it's disjoint to what we already\n * have, in which case add it to the list). Meant to be used with\n * Array.reduce().\n *\n * Assumes the list being reduced is sorted by interval start time.\n *\n * @param {Array} accum  The accumulated list of reduced intervals.\n * @param {Array} newest A new pair of range start and end to compare to the\n*                        existing intervals.\n *\n * @return {Array} A list of intervals updated to include the new interval.\n */\nfunction reduceIntervals(accum, newest) {\n  if (accum && accum.length > 0) {\n    // the last interval on the list will always be the latest\n    var last = accum.slice(-1)[0];\n\n    // case 1: the new interval is a strict subset of the last interval\n    if (newest[0] >= last[0] && newest[1] <= last[1]) {\n      return accum;\n    }\n    // case 2: the start of the new interval is inside the last interval\n    else if (newest[0] >= last[0] && newest[0] <= last[1]) {\n      var heads = accum.slice(0, -1);\n      // gotta double-wrap the array I'm appending onto the end\n      return heads.concat([[last[0], newest[1]]]);\n    }\n    // case 3: the interval is disjoint\n    else {\n      return accum.concat([newest]);\n    }\n  }\n\n  // base case: wrap up the newest element to create the accumulator\n  return [newest];\n}\n\n/**\n * Reduce a list of intervals to the magnitude of the range, eliminating any\n * overlaps.\n *\n * @param {Array} pairs The list of startRange, endRange pairs to reduce.\n * @return {integer} The magnitude of the range, after all the overlaps have\n *                   been smoothed and the holes eliminated.\n */\nfunction sumChildren(pairs) {\n  // 1. sort the list of [begin, end] pairs by start time\n  var sortedPairs = pairs.sort(function cb_sort(a, b) { return a[0] - b[0]; });\n\n  // 2. reduce the list to a set of disjoint intervals\n  // I love ECMAscript 5!\n  var disjointIntervals = sortedPairs.reduce(reduceIntervals, []);\n\n  // 3. sum the durations of the intervals\n  return disjointIntervals.reduce(function cb_reduce(accum, current) {\n    return accum + (current[1] - current[0]);\n  }, 0);\n}\n\nmodule.exports = sumChildren;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm-util/lib/urltils.js":"'use strict';\n\nvar url = require('url');\n\n/**\n * Utility functions for enforcing OneAPM naming conditions on URLs,\n * and extracting and setting parameters on traces / web trace segments.\n */\nmodule.exports = {\n  /**\n   * This was handed down from the prototype as the canonical list of status\n   * codes that short-circuit naming and normalization. The agent can be\n   * configured to mark HTTP status codes as not being errors.\n   *\n   * @param {Config} config The configuration containing the error list.\n   * @param {string} code   The HTTP status code to check.\n   *\n   * @returns {bool} Whether the status code should be ignored.\n   */\n  isError : function isError(config, code) {\n    var codes = [];\n    if (config &&\n        config.error_collector &&\n        config.error_collector.ignore_status_codes) {\n      codes = config.error_collector.ignore_status_codes;\n    }\n    return code >= 400 && codes.indexOf(code) === -1;\n  },\n\n  /**\n   * Get back the pieces of the URL that OneAPM cares about. Apply these\n   * restrictions, in order:\n   *\n   * 1. Ensure that after parsing the URL, there's at least '/'\n   * 2. Strip off session trackers after ';' (a OneAPM convention)\n   * 3. Remove trailing slash.\n   *\n   * @param {string} requestURL The URL fragment to be scrubbed.\n   * @return {string} The cleaned URL.\n   */\n  scrub : function scrub(requestURL) {\n    var path = url.parse(requestURL).pathname;\n\n    if (path) {\n      path = path.split(';')[0];\n\n      if (path !== '/' && path.charAt(path.length - 1) === '/') {\n        path = path.substring(0, path.length - 1);\n      }\n    }\n    else {\n      path = '/';\n    }\n\n    return path;\n  },\n\n  /**\n   * Extract query parameters, dealing with bare parameters and parameters with\n   * no value as appropriate:\n   *\n   * 'var1&var2=value' is not necessarily the same as 'var1=&var2=value'\n   *\n   * In my world, one is an assertion of presence, and the other is an empty\n   * variable. Some web frameworks behave this way as well, so don't lose\n   * information.\n   *\n   * @param {string} requestURL The URL to be parsed.\n   * @returns {object} The parameters parsed from the request\n   */\n  parseParameters : function parseParameters(requestURL) {\n    var parsed     = url.parse(requestURL, true)\n      , parameters = {}\n      ;\n\n    if (parsed.search !== '') {\n      Object.keys(parsed.query).forEach(function cb_forEach(key) {\n        if (parsed.query[key] === '' && parsed.path.indexOf(key + '=') < 0) {\n          parameters[key] = true;\n        }\n        else {\n          parameters[key] = parsed.query[key];\n        }\n      });\n    }\n\n    return parameters;\n  },\n\n  /**\n   * Copy a set of request parameters from one object to another, following\n   * a few important rules:\n   *\n   * 1. Do not copy a parameter if it's in config.ignored_params.\n   * 2. Do not overwrite any existing parameters in dest, including parameters\n   *    set to null or undefined.\n   *\n   * @param {Config} config      Configuration, where `ignored_params` is\n   *                             guaranteed to be an Array.\n   * @param {object} source      Parameters to be copied (not changed).\n   * @param {object} destination Dictionary to which parameters are copied\n   *                             (mutated in place).\n   */\n  copyParameters : function copyParameters(config, source, destination) {\n    if (!(config && config.capture_params && source && destination)) return;\n\n    var keys = Object.keys(source);\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      if (config.ignored_params.indexOf(key) === -1 && !(key in destination)) {\n        destination[key] = source[key];\n      }\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm-util/lib/sql/obfuscate.js":"'use strict'\n\nmodule.exports = obfuscate\n\nvar singleQuote = /'(?:[^']|'')*?(?:\\\\'.*|'(?!'))/\nvar doubleQuote = /\"(?:[^\"]|\"\")*?(?:\\\\\".*|\"(?!\"))/\nvar dollarQuote = /(\\$(?!\\d)[^$]*?\\$).*?(?:\\1|$)/\nvar oracleQuote = /q'\\[.*?(?:\\]'|$)|q'\\{.*?(?:\\}'|$)|q'\\<.*?(?:\\>'|$)|q'\\(.*?(?:\\)'|$)/\nvar comment = /(?:#|--).*?(?=\\r|\\n|$)/\nvar multilineComment = /\\/\\*(?:[^/]|\\/[^*])*?(?:\\*\\/|\\/\\*.*)/\nvar uuid = /\\{?(?:[0-9a-f]\\-*){32}\\}?/\nvar hex = /0x[0-9a-f]+/\nvar boolean = /true|false|null/\nvar number = /\\b-?(?:[0-9]+\\.)?[0-9]+([eE][+-]?[0-9]+)?/\n\nvar namedePlaceholder = /(?:\\?)|(?::(\\d+|(?:[a-zA-Z][a-zA-Z0-9_]*)))/\n\nvar dialects = {}\n\ndialects.mysql = [\n  replacer(join(\n    [doubleQuote, singleQuote, comment, multilineComment, hex, boolean, number],\n    'gi'\n  )),\n  unmatchedPairs(/'|\"|\\/\\*|\\*\\//)\n]\n\ndialects.mysql2 = [\n  replacer(join(\n    [doubleQuote, singleQuote, comment, multilineComment, hex, boolean, number, namedePlaceholder],\n    'gi'\n  )),\n  unmatchedPairs(/'|\"|\\/\\*|\\*\\//)\n]\n\n\ndialects.postgres = [\n  replacer(join(\n    [dollarQuote, singleQuote, comment, multilineComment, uuid, boolean, number],\n    'gi'\n  )),\n  unmatchedPairs(/'|\\/\\*|\\*\\/|\\$/)\n]\n\ndialects.cassandra = [\n  replacer(join(\n    [singleQuote, comment, multilineComment, uuid, hex, boolean, number],\n    'gi'\n  )),\n  unmatchedPairs(/'|\\/\\*|\\*\\//)\n]\n\ndialects.oracle = [\n  replacer(join(\n    [oracleQuote, singleQuote, comment, multilineComment, number],\n    'gi'\n  )),\n  unmatchedPairs(/'|\\/\\*|\\*\\//)\n]\n\nfunction obfuscate(raw, dialect) {\n  if (!dialects[dialect]) throw new Error('Unknown sql implementation')\n  var replacers = dialects[dialect]\n  var obfuscated = raw\n  for (var i = 0, l = replacers.length; i < l; ++i) {\n    obfuscated = replacers[i](obfuscated)\n  }\n\n  return obfuscated\n}\n\nfunction join(expressions, flags) {\n  return new RegExp(expressions.map(toPart).join('|'), flags)\n}\n\nfunction toPart(expressions) {\n  return expressions.toString().slice(1, -1)\n}\n\nfunction replacer(regex) {\n  return function replace(sql) {\n    return sql.replace(regex, '?')\n  }\n}\n\nfunction unmatchedPairs(regex) {\n  return function check(sql) {\n    return regex.test(sql) ? '?' : sql\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm-config/internal/config.default.js":"/**\n * This file includes all of the configuration variables used by the Node.js\n * module. If there's a configurable element of the module and it's not\n * described in here, there's been a terrible mistake.\n */\nexports.config = {\n  /**\n   * Application name.\n   *\n   * @env ONEAPM_APP_NAME\n   */\n  app_name : '',\n  /**\n   * Array of tier names.\n   *\n   * @env ONEAPM_TIER_NAME\n   */\n  tier_name: [],\n  /**\n   * The user's license key. Must be set by per-app configuration file.\n   *\n   * @env ONEAPM_LICENSE_KEY\n   */\n  license_key : '',\n  /**\n   * Hostname for the OneAPM collector proxy.\n   *\n   * You shouldn't need to change this.\n   *\n   * @env ONEAPM_HOST\n   */\n  host : 'app.collector.oneapm.com',\n  /**\n   * The port on which the collector proxy will be listening.\n   *\n   * You shouldn't need to change this.\n   *\n   * @env ONEAPM_PORT\n   */\n  port : 443,\n  /**\n   * Whether or not to use SSL to connect to OneAPM's servers.\n   *\n   * @env ONEAPM_USE_SSL\n   */\n  ssl : true,\n  /**\n   * Proxy url\n   *\n   * A proxy url can be used in place of setting\n   * proxy_host, proxy_port, proxy_user, and proxy_pass.\n   *\n   * e.g. http://user:pass@host:port/\n   *\n   * Setting proxy will override other proxy settings.\n   *\n   * @env ONEAPM_PROXY_URL\n   */\n  proxy: '',\n  /**\n   * Proxy host to use to connect to the internet.\n   *\n   * @env ONEAPM_PROXY_HOST\n   */\n  proxy_host : '',\n  /**\n   * Proxy port to use to connect to the internet.\n   *\n   * @env ONEAPM_PROXY_PORT\n   */\n  proxy_port : '',\n  /**\n   * Proxy user name when required.\n   *\n   * @env ONEAPM_PROXY_USER\n   */\n  proxy_user : '',\n  /**\n   * Proxy password when required.\n   *\n   * @env ONEAPM_PROXY_PASS\n   */\n  proxy_pass : '',\n  /**\n   * Custom SSL certificates\n   *\n   * If your proxy uses a custom SSL certificate, you can add the CA text to\n   * this array, one entry per certificate.\n   *\n   * The easiest way to do this is with `fs.readFileSync` e.g.\n   *\n   * certificates: [\n   *   require('fs').readFileSync('custom.crt', 'utf8') // don't forget the utf8\n   * ]\n   *\n   */\n  certificates: [],\n  /**\n   * You may want more control over how the module is configured and want to\n   * disallow the use of OneAPM's server-side configuration. To do so, set\n   * this parameter to true. Some configuration information is required to make\n   * the module work properly with the rest of OneAPM, but settings such as\n   * apdex_t and capture_params will not be overridable by OneAPM with this\n   * setting in effect.\n   *\n   * @env ONEAPM_IGNORE_SERVER_CONFIGURATION\n   */\n  ignore_server_configuration : false,\n  /**\n   * getBrowserTimingHeader method will return external script link if set false,\n   * otherwise, it will return BI(Browser Insight) script inlined content\n   *\n   */\n  is_js_text:false,\n  /**\n   * Whether the module is enabled.\n   *\n   * @env ONEAPM_ENABLED\n   */\n  agent_enabled : true,\n  /**\n   * The default Apdex tolerating / threshold value for applications, in\n   * seconds. The default for Node is apdexT to 100 milliseconds, which is\n   * lower than OneAPM standard, but Node.js applications tend to be more\n   * latency-sensitive than most.\n   *\n   * @env ONEAPM_APDEX\n   */\n  apdex_t : 0.100,\n  /**\n   * Whether to capture parameters in the request URL in slow transaction\n   * traces and error traces. Because this can pass sensitive data, it's\n   * disabled by default. If there are specific parameters you want ignored,\n   * use ignored_params.\n   *\n   * @env ONEAPM_CAPTURE_PARAMS\n   */\n  capture_params : false,\n  /**\n   * Array of parameters you don't want captured off request URLs in slow\n   * transaction traces and error traces.\n   *\n   * @env ONEAPM_IGNORED_PARAMS\n   */\n  ignored_params : [],\n  logging : {\n    /**\n     * Verbosity of the module's logging. This module uses bunyan\n     * (https://github.com/trentm/node-bunyan) for its logging, and as such the\n     * valid logging levels are 'fatal', 'error', 'warn', 'info', 'debug' and\n     * 'trace'. Logging at levels 'info' and higher is very terse. For support\n     * requests, attaching logs captured at 'trace' level are extremely helpful\n     * in chasing down bugs.\n     *\n     * @env ONEAPM_LOG_LEVEL\n     */\n    level : 'info',\n    /**\n     * Where to put the log file -- by default just uses process.cwd +\n     * 'oneapm_agent.log'. A special case is a filepath of 'stdout',\n     * in which case all logging will go to stdout, or 'stderr', in which\n     * case all logging will go to stderr.\n     *\n     * @env ONEAPM_LOG\n     */\n    filepath : require('path').join(__dirname, '..', 'oneapm_agent.log')\n  },\n  /**\n   * Whether to collect & submit error traces to OneAPM.\n   *\n   * @env ONEAPM_ERROR_COLLECTOR_ENABLED\n   */\n  error_collector : {\n    /**\n     * Disabling the error tracer just means that errors aren't collected\n     * and sent to OneAPM -- it DOES NOT remove any instrumentation.\n     */\n    enabled : true,\n    /**\n     * List of HTTP error status codes the error tracer should disregard.\n     * Ignoring a status code means that the transaction is not renamed to\n     * match the code, and the request is not treated as an error by the error\n     * collector.\n     *\n     * Defaults to 404 NOT FOUND.\n     *\n     * @env ONEAPM_ERROR_COLLECTOR_IGNORE_ERROR_CODES\n     */\n    ignore_status_codes : [404]\n  },\n  transaction_tracer : {\n    /**\n     * Whether to collect & submit slow transaction traces to OneAPM. The\n     * instrumentation is loaded regardless of this setting, as it's necessary\n     * to gather metrics. Disable the agent to prevent the instrumentation from\n     * loading.\n     *\n     * @env ONEAPM_TRACER_ENABLED\n     */\n    enabled : true,\n    /**\n     * The duration at below which the slow transaction tracer should collect a\n     * transaction trace. If set to 'apdex_f', the threshold will be set to\n     * 4 * apdex_t, which with a default apdex_t value of 500 milliseconds will\n     * be 2 seconds.\n     *\n     * If a time is provided, it is set in seconds.\n     *\n     * @env ONEAPM_TRACER_THRESHOLD\n     */\n    transaction_threshold : 'apdex_f',\n    /**\n     * Increase this parameter to increase the diversity of the slow\n     * transaction traces recorded by your application over time. Confused?\n     * Read on.\n     *\n     * Transactions are named based on the request (see the README for the\n     * details of how requests are mapped to transactions), and top_n refers to\n     * the \"top n slowest transactions\" grouped by these names. The module will\n     * only replace a recorded trace with a new trace if the new trace is\n     * slower than the previous slowest trace of that name. The default value\n     * for this setting is 20, as the transaction trace view page also defaults\n     * to showing the 20 slowest transactions.\n     *\n     * If you want to record the absolute slowest transaction over the last\n     * minute, set top_n to 0 or 1. This used to be the default, and has a\n     * problem in that it will allow one very slow route to dominate your slow\n     * transaction traces.\n     *\n     * The module will always record at least 5 different slow transactions in\n     * the reporting periods after it starts up, and will reset its internal\n     * slow trace aggregator if no slow transactions have been recorded for the\n     * last 5 harvest cycles, restarting the aggregation process.\n     *\n     * @env ONEAPM_TRACER_TOP_N\n     */\n    top_n : 20,\n    record_sql: 'off',\n    explain_threshold : 500\n  },\n  /**\n   * Whether to enable internal supportability metrics and diagnostics. You're\n   * welcome to turn these on, but they will probably be most useful to the\n   * OneAPM node engineering team.\n   */\n  debug : {\n    /**\n     * Whether to collect and submit internal supportability metrics alongside\n     * application performance metrics.\n     *\n     * @env ONEAPM_DEBUG_METRICS\n     */\n    internal_metrics : false,\n    /**\n     * Traces the execution of the transaction tracer. Requires logging.level\n     * to be set to 'trace' to provide any useful output.\n     *\n     * WARNING: The tracer tracing data is likely only to be intelligible to a\n     * small number of people inside OneAPM, so you should probably only\n     * enable tracer tracing if asked to by OneAPM, because it will affect\n     * performance significantly.\n     *\n     * @env ONEAPM_DEBUG_TRACER\n     */\n    tracer_tracing : false\n  },\n  /**\n   * Rules for naming or ignoring transactions.\n   */\n  rules : {\n    /**\n     * A list of rules of the format {pattern : 'pattern', name : 'name'} for\n     * matching incoming request URLs and naming the associated OneAPM\n     * transactions. Both pattern and name are required. Additional attributes\n     * are ignored. Patterns may have capture groups (following JavaScript\n     * conventions), and names will use $1-style replacement strings. See\n     * the documentation for addNamingRule for important caveats.\n     *\n     * @env ONEAPM_NAMING_RULES\n     */\n    name : [],\n    /**\n     * A list of patterns for matching incoming request URLs to be ignored by\n     * the agent. Patterns may be strings or regular expressions.\n     *\n     * @env ONEAPM_IGNORING_RULES\n     */\n    ignore : []\n  },\n  /**\n   * By default, any transactions that are not affected by other bits of\n   * naming logic (the API, rules, or metric normalization rules) will\n   * have their names set to 'NormalizedUri/*'. Setting this value to\n   * false will set them instead to Uri/path/to/resource. Don't change\n   * this setting unless you understand the implications of OneAPM's\n   * metric grouping issues and are confident your application isn't going\n   * to run afoul of them. Your application could end up getting blackholed!\n   * Nobody wants that.\n   *\n   * @env ONEAPM_ENFORCE_BACKSTOP\n   */\n  enforce_backstop : true,\n  /**\n   * Browser Monitoring\n   *\n   * Browser monitoring lets you correlate transactions between the server and browser\n   * giving you accurate data on how long a page request takes, from request,\n   * through the server response, up until the actual page render completes.\n   */\n  browser_monitoring : {\n\n    /**\n     * Enable browser monitoring header generation.\n     *\n     * This does not auto-instrument, rather it enables the agent to generate headers.\n     * The oneapm module can generate the appropriate <script> header, but you must\n     * inject the header yourself, or use a module that does so.\n     *\n     * Usage:\n     *\n     *     var oneapm = require('oneapm');\n     *\n     *     router.get('/', function (req, res) {\n     *       var header = oneapm.getBrowserTimingHeader();\n     *       res.write(header)\n     *       // write the rest of the page\n     *     });\n     *\n     * This generates the <script>...</script> header necessary for Browser Monitoring\n     * This script must be manually injected into your templates, as high as possible\n     * in the header, but _after_ any X-UA-COMPATIBLE HTTP-EQUIV meta tags.\n     * Otherwise you may hurt IE!\n     *\n     * This method must be called _during_ a transaction, and must be called every\n     * time you want to generate the headers.\n     *\n     * Do *not* reuse the headers between users, or even between requests.\n     *\n     * @env ONEAPM_BROWSER_MONITOR_ENABLE\n     */\n    enable : true,\n\n    /**\n     * Request un-minified sources from the server.\n     *\n     * @env ONEAPM_BROWSER_MONITOR_DEBUG\n     */\n    debug : false\n  },\n  transaction_events : {\n    /**\n     * If this is disabled, the agent does not collect, nor try to send, data\n     * for Insights.\n     */\n    enabled: false,\n\n    /**\n     * The agent will collect all events up to this number per minute. If\n     * there are more than that, a statistical sampling will be collected.\n     */\n    max_samples_per_minute: 10000,\n\n    /**\n     * This is used if the agent is unable to send events to the collector.\n     * The values from the previous harvest cycle will be merged into the next\n     * one with this option as the limit.\n     *\n     * This should be *greater* than max_samples_per_minute or you'll see odd\n     * behavior. You probably want at least double the value, but more is okay\n     * as long as you can handle the memory overhead.\n     */\n    max_samples_stored: 20000,\n  },\n\n  /**\n   * High Security\n   *\n   * High security mode (v2) is a setting which prevents any sensitive data from\n   * being sent to OneAPM. The local setting must match the server setting.\n   * If there is a mismatch the agent will log a message and act as if it is\n   * disabled.\n   *\n   * Attributes of high security mode (when enabled):\n   *  * requires SSL\n   *  * does not allow capturing of http params\n   *  * does not allow custom params\n   *\n   */\n  high_security : false,\n  slow_sql : {\n    enabled : false,\n    max_samples : 10\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/api.js":"'use strict';\n\nvar path   = require('path')\n  , util   = require('util')\n  , logger = require('oneapm-logger').child({component : 'api'})\n  , NAMES  = require(path.join(__dirname, 'lib', 'metrics', 'names'))\n  , genericRecorder = require(path.join(__dirname, 'lib', 'metrics', 'recorders',\n                                        'generic'))\n  ;\n\nvar injectScript=require(path.join(__dirname,'lib','util','inject-script'));\n/*\n *\n * CONSTANTS\n *\n */\nvar RUM_STUB = \"<script type='text/javascript'>window.BWEUM||(BWEUM={});\" +\n                \"BWEUM.info = %s; %s</script>\";\n\n// these messages are used in the _gracefail() method below in getBrowserTimingHeader\nvar RUM_ISSUES = [\n  'BWEUM: no browser monitoring headers generated; disabled',\n  'BWEUM: transaction missing while generating browser monitoring headers',\n  'BWEUM: config.browser_monitoring missing, something is probably wrong',\n  'BWEUM: browser_monitoring headers need a transaction name',\n  'BWEUM: browser_monitoring requires valid application_id',\n  'BWEUM: browser_monitoring requires valid browser_key',\n  'BWEUM: browser_monitoring requires js_agent_loader script',\n  'BWEUM: browser_monitoring disabled by browser_monitoring.loader config'\n];\n\n// can't overwrite internal parameters or all heck will break loose\nvar CUSTOM_BLACKLIST = [\n  'nr_flatten_leading'\n];\n\nfunction _rumObfuscate(string, license_key) {\n  var bytes = new Buffer(string);\n  for (var i = 0; i < bytes.length; i++) {\n    bytes[i] = bytes[i] ^ license_key[i % 13].charCodeAt(0);\n  }\n  return bytes.toString('base64');\n}\n\n/**\n * The exported OneAPM API. This contains all of the functions meant to be\n * used by OneAPM customers. For now, that means transaction naming.\n */\nfunction API(agent) {\n  this.agent = agent;\n}\n\n/**\n * Give the current transaction a custom name. Overrides any OneAPM naming\n * rules set in configuration or from OneAPM's servers.\n *\n * IMPORTANT: this function must be called when a transaction is active. OneAPM\n * transactions are tied to web requests, so this method may be called\n * from within HTTP or HTTPS listener functions, Express routes, or other\n * contexts where a web request or response object are in scope.\n *\n * @param {string} name The name you want to give the web request in the OneAPM\n *                      UI. Will be prefixed with 'Custom/' when sent.\n */\nAPI.prototype.setTransactionName = function setTransactionName(name) {\n  var transaction = this.agent.tracer.getTransaction();\n  if (!transaction) {\n    return logger.warn(\"No transaction found when setting name to '%s'.\", name);\n  }\n\n  if (!name) {\n    if (transaction.url) {\n      logger.error(\"Must include name in setTransactionName call for URL %s.\",\n                   transaction.url);\n    }\n    else {\n      logger.error(\"Must include name in setTransactionName call.\");\n    }\n\n    return;\n  }\n\n  transaction.partialName = NAMES.CUSTOM + '/' + name;\n};\n\n/**\n * Give the current transaction a name based on your own idea of what\n * constitutes a controller in your Node application. Also allows you to\n * optionally specify the action being invoked on the controller. If the action\n * is omitted, then the API will default to using the HTTP method used in the\n * request (e.g. GET, POST, DELETE). Overrides any OneAPM naming rules set\n * in configuration or from OneAPM's servers.\n *\n * IMPORTANT: this function must be called when a transaction is active.\n * OneAPM transactions are tied to web requests, so this method may be called\n * from within HTTP or HTTPS listener functions, Express routes, or other\n * contexts where a web request or response object are in scope.\n *\n * @param {string} name   The name you want to give the controller in the OneAPM\n *                         UI. Will be prefixed with 'Controller/' when\n *                        sent.\n * @param {string} action The action being invoked on the controller. Defaults\n *                        to the HTTP method used for the request.\n */\nAPI.prototype.setControllerName = function setControllerName(name, action) {\n  var transaction = this.agent.tracer.getTransaction();\n  if (!transaction) {\n    return logger.warn(\"No transaction found when setting controller to %s.\", name);\n  }\n\n  if (!name) {\n    if (transaction && transaction.url) {\n      logger.error(\"Must include name in setControllerName call for URL %s.\",\n                   transaction.url);\n    }\n    else {\n      logger.error(\"Must include name in setControllerName call.\");\n    }\n\n    return;\n  }\n\n  action = action || transaction.verb || 'GET';\n  transaction.partialName = NAMES.CONTROLLER + '/' + name + '/' + action;\n};\n\n/**\n * Add a custom parameter to the current transaction. Some parameters are\n * reserved (see CUSTOM_BLACKLIST for the current, very short list), and\n * as with most API methods, this must be called in the context of an\n * active transaction. Most recently set value wins.\n *\n * @param {string} name  The name you want displayed in the RPM UI.\n * @param {string} value The value you want displayed. Must be serializable.\n */\nAPI.prototype.addCustomParameter = function addCustomParameter(name, value) {\n  // If high security mode is on, custom params are disabled\n  if (this.agent.config.high_security === true) {\n    // we only want to log this warning once\n    if (this._highSecCustomParamLogged !== true) {\n      this._highSecCustomParamLogged = true;\n      logger.warn(\"Custom parameters are disabled by high security mode.\");\n    }\n    return false;\n  }\n\n  var ignored = this.agent.config.ignored_params || [];\n\n  var transaction = this.agent.tracer.getTransaction();\n  if (!transaction) {\n    return logger.warn(\"No transaction found for custom parameters.\");\n  }\n\n  var trace = transaction.getTrace();\n  if (!trace.custom) {\n    return logger.warn(\n      \"Couldn't add parameter %s to nonexistent custom parameters.\",\n      name\n    );\n  }\n\n  if (CUSTOM_BLACKLIST.indexOf(name) !== -1) {\n    return logger.warn(\"Not overwriting value of NR-only parameter %s.\", name);\n  }\n\n  if (ignored.indexOf(name) !== -1) {\n    return logger.warn(\"Not setting ignored parameter name %s.\", name);\n  }\n\n  if (name in trace.custom) {\n    logger.debug(\n      \"Changing custom parameter %s from %s to %s.\",\n      name,\n      trace.custom[name],\n      value\n    );\n  }\n\n  trace.custom[name] = value;\n};\n\n/**\n * Tell the tracer whether to ignore the current transaction. The most common\n * use for this will be to mark a transaction as ignored (maybe it's handling\n * a websocket polling channel, or maybe it's an external call you don't care\n * is slow), but it's also useful when you want a transaction that would\n * otherwise be ignored due to URL or transaction name normalization rules\n * to *not* be ignored.\n *\n * @param {boolean} ignored Ignore, or don't ignore, the current transaction.\n */\nAPI.prototype.setIgnoreTransaction = function setIgnoreTransaction(ignored) {\n  var transaction = this.agent.tracer.getTransaction();\n  if (!transaction) {\n    return logger.warn(\"No transaction found to ignore.\");\n  }\n\n  transaction.forceIgnore = ignored;\n};\n\n/**\n * Send errors to OneAPM that you've already handled yourself. Should\n * be an Error or one of its subtypes, but the API will handle strings\n * and objects that have an attached .message or .stack property.\n *\n * @param {Error}  error            The error to be traced.\n * @param {object} customParameters Any custom parameters to be displayed in\n *                                  the OneAPM UI.\n */\nAPI.prototype.noticeError = function noticeError(error, customParameters) {\n  if (typeof error === 'string') error = new Error(error);\n  var transaction = this.agent.tracer.getTransaction();\n  this.agent.errors.add(transaction, error, customParameters);\n};\n\n/**\n * If the URL for a transaction matches the provided pattern, name the\n * transaction with the provided name. If there are capture groups in the\n * pattern (which is a standard JavaScript regular expression, and can be\n * passed as either a RegExp or a string), then the substring matches ($1, $2,\n * etc.) are replaced in the name string. BE CAREFUL WHEN USING SUBSTITUTION.\n * If the replacement substrings are highly variable (i.e. are identifiers,\n * GUIDs, or timestamps), the rule will generate too many metrics and\n * potentially get your application blacklisted by OneAPM.\n *\n * An example of a good rule with replacements:\n *\n *   oneapm.addNamingRule('^/storefront/(v[1-5])/(item|category|tag)',\n *                          'CommerceAPI/$1/$2')\n *\n * An example of a bad rule with replacements:\n *\n *   oneapm.addNamingRule('^/item/([0-9a-f]+)', 'Item/$1')\n *\n * Keep in mind that the original URL and any query parameters will be sent\n * along with the request, so slow transactions will still be identifiable.\n *\n * Naming rules can not be removed once added. They can also be added via the\n * agent's configuration. See configuration documentation for details.\n *\n * @param {RegExp} pattern The pattern to rename (with capture groups).\n * @param {string} name    The name to use for the transaction.\n */\nAPI.prototype.addNamingRule = function addNamingRule(pattern, name) {\n  if (!name) return logger.error(\"Simple naming rules require a replacement name.\");\n\n  this.agent.userNormalizer.addSimple(pattern, '/' + name);\n};\n\n/**\n * If the URL for a transaction matches the provided pattern, ignore the\n * transaction attached to that URL. Useful for filtering socket.io connections\n * and other long-polling requests out of your agents to keep them from\n * distorting an app's apdex or mean response time. Pattern may be a (standard\n * JavaScript) RegExp or a string.\n *\n * Example:\n *\n *   oneapm.addIgnoringRule('^/socket\\\\.io/')\n *\n * @param {RegExp} pattern The pattern to ignore.\n */\nAPI.prototype.addIgnoringRule = function addIgnoringRule(pattern) {\n  if (!pattern) return logger.error(\"Must include a URL pattern to ignore.\");\n\n  this.agent.userNormalizer.addSimple(pattern, null);\n};\n\n/**\n * Get the <script>...</script> header necessary for Browser Monitoring\n * This script must be manually injected into your templates, as high as possible\n * in the header, but _after_ any X-UA-COMPATIBLE HTTP-EQUIV meta tags.\n * Otherwise you may hurt IE!\n *\n * This method must be called _during_ a transaction, and must be called every\n * time you want to generate the headers.\n *\n * Do *not* reuse the headers between users, or even between requests.\n *\n * @returns {string} the <script> header to be injected\n */\nAPI.prototype.getBrowserTimingHeader = function getBrowserTimingHeader() {\n  var config = this.agent.config;\n\n  /* Gracefully fail.\n   *\n   * Output an HTML comment and log a warning the comment is meant to be\n   * innocuous to the end user.\n   */\n  function _gracefail(num){\n    logger.warn(RUM_ISSUES[num]);\n    return '<!-- '+RUM_ISSUES[num]+' -->';\n  }\n\n  var browser_monitoring = config.browser_monitoring;\n\n  // config.browser_monitoring should always exist, but we don't want the agent to bail\n  // here if something goes wrong\n  if (!browser_monitoring) return _gracefail(2);\n\n  /* Can control header generation with configuration this setting is only\n   * available in the oneapm.js config file, it is not ever set by the\n   * server.\n   */\n  if (!browser_monitoring.enable) return _gracefail(0);\n\n  var trans = this.agent.getTransaction();\n\n  // bail gracefully outside a transaction\n  if (!trans) return _gracefail(1);\n\n  var name = NAMES.WEB + '/' + trans.partialName;\n\n  /* If we're in an unnamed transaction, add a friendly warning this is to\n   * avoid people going crazy, trying to figure out why browser monitoring is\n   * not working when they're missing a transaction name.\n   */\n  if (!name) return _gracefail(3);\n\n  var time  = trans.timer.getDurationInMillis();\n  var key   = config.license_key;\n  var appid = config.application_id;\n\n  /* This is only going to work if the agent has successfully handshaked with\n   * the collector. If the networks is bad, or there is no license key set in\n   * oneapm.js, there will be no application_id set.  We bail instead of\n   * outputting null/undefined configuration values.\n   */\n  if (!appid) return _gracefail(4);\n\n  /* If there is no browser_key, the server has likely decided to disable\n   * browser monitoring.\n   */\n  var licenseKey = browser_monitoring.browser_key;\n  if (!licenseKey) return _gracefail(5);\n\n  /* If there is no agent_loader script, there is no point\n   * in setting the rum data\n   */\n  var js_agent_loader = browser_monitoring.js_agent_loader;\n  if (!js_agent_loader) return _gracefail(6);\n\n  /* If rum is enabled, but then later disabled on the server,\n   * this is the only parameter that gets updated.\n   *\n   * This condition should only be met if rum is disabled during\n   * the lifetime of an application, and it should be picked up\n   * on the next ForceRestart by the collector.\n   */\n  var loader = browser_monitoring.loader;\n  if (loader === 'none') return _gracefail(7);\n\n  // This hash gets written directly into the browser.\n  var rum_hash = {\n    agent           : browser_monitoring.js_agent_file,\n    beacon          : browser_monitoring.beacon,\n    errorBeacon     : browser_monitoring.error_beacon,\n    licenseKey      : licenseKey,\n    applicationID   : appid,\n    applicationTime : Math.round(time),\n    transactionName : _rumObfuscate(name, key),\n    queueTime       : trans.queueTime,\n\n    // we don't use these parameters yet\n    agentToken      : null,\n    ttGuid          : \"\"\n  };\n\n  // if debugging, do pretty format of JSON\n  var tabs = config.browser_monitoring.debug ? 2 : 0\n    , json = JSON.stringify(rum_hash, null, tabs)\n    ;\n\n  // the complete header to be written to the browser\n  var out = util.format(\n    RUM_STUB,\n    json,\n    injectScript(js_agent_loader,config)\n  );\n\n  logger.trace('generating RUM header', out);\n\n  return out;\n};\n\n/**\n * This creates a new segment with the passed in name. It then wraps the\n * callback and binds it to the current transaction and segment so any further\n * custom instrumentation as well as auto instrumentation will also be able to\n * find the current transaction and segment.\n */\nAPI.prototype.createSegment = function createSegment(name, callback) {\n  // FLAG: custom_instrumentation\n  if (!this.agent.config.feature_flag.custom_instrumentation) {\n    return callback;\n  }\n\n  var tracer = this.agent.tracer;\n  var segment = tracer.addSegment(name, genericRecorder);\n  return tracer.callbackProxy(function () {\n    callback.apply(this, arguments);\n    segment.end();\n  });\n};\n\nmodule.exports = API;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/locales.js":"module.exports = {\n  \"AGENT_NOT_ENABLED_ERROR\": \"Module not enabled in configuration; not starting.\",\n  \"AGENT_NO_NAME_ERROR\": \"OneAPM requires that you name this application! Set app_name in your oneapm.js file or set environment variable ONEAPM_APP_NAME. Not starting!\",\n  \"AGENT_CONNECTED\": \"OneAPM for Node.js is connected to OneAPM.\",\n  \"AGENT_STARTUP_ERROR\": \"OneAPM for Node.js halted startup due to an error:\",\n  \"AGENT_BOOTSTRAP_ERROR\": \"OneAPM for Node.js halted startup due to an error:\",\n  \"NODE_VERSION_TOO_LOW\": \"OneAPM for Node.js requires a version of Node equal to or greater than 0.8.0. Not starting!\"\n}","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/oneapm.js":"/**\n * OneAPM agent configuration.\n *\n * See lib/config.defaults.js in the agent distribution for a more complete\n * description of configuration variables and their potential values.\n */\nexports.config = {\n  /**\n   * Your Application name.\n   */\n  app_name : 'exampleApp',\n  /**\n   * Your tier names.\n   */\n  tier_name: [],\n  /**\n   * Your OneAPM license key.\n   */\n  license_key : 'license key here',\n  logging : {\n    /**\n     * Level at which to log. 'trace' is most useful to OneAPM when diagnosing\n     * issues with the agent, 'info' and higher will impose the least overhead on\n     * production applications.\n     */\n    level : 'info'\n  },\n  transaction_events: {\n        enabled: true\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/stub_api.js":"'use strict';\n\nvar path    = require('path')\n  , logger  = require('oneapm-logger')\n  , RealAPI = require(path.join(__dirname, 'api.js'))\n  ;\n\nfunction stubFunction (name) {\n  // jshint -W061\n  return eval(\"(function () {return function \" + name + \"() {\" +\n              \"logger.debug('Not calling \" + name + \" because OneAPM is disabled.');\" +\n              \"}}())\");\n}\n\nfunction Stub() {}\n\nvar keys   = Object.keys(RealAPI.prototype)\n  , length = keys.length\n  ;\n\n/* This way the stub API doesn't have to be updated in lockstep with the regular\n * API.\n */\nfor (var i = 0; i < length; i++) {\n  var name = keys[i];\n  Stub.prototype[name] = stubFunction(name);\n}\n\n// this code gets injected into HTML templates\n// and we don't want it to return undefined/null\nStub.prototype.getBrowserTimingHeader = function getBrowserTimingHeader(){\n  logger.debug('Not calling getBrowserTimingHeader because OneAPM is disabled.');\n  return '';\n};\n\n// Normally createSegment returns the a wrapped callback, instead we should just\n// return the callback in its unwrapped state.\nStub.prototype.createSegment = function(name, callback) {\n  logger.debug('Not calling createSegment because OneAPM is disabled.');\n  return callback;\n};\n\nmodule.exports = Stub;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/agent.js":"'use strict';\n\nvar path             = require('path')\n  , util             = require('util')\n  , EventEmitter     = require('events').EventEmitter\n  // , Reservoir        = require(path.join(__dirname, 'reservoir.js'))\n  , Events        = require(path.join(__dirname, 'events.js'))\n  , logger           = require('oneapm-logger')\n  , sampler          = require(path.join(__dirname, 'sampler.js'))\n  , NAMES            = require(path.join(__dirname, 'metrics', 'names.js'))\n  , CollectorAPI     = require('oneapm-server')\n  , ErrorTracer      = require(path.join(__dirname, 'error.js'))\n  , QueryTracer      = require(path.join(__dirname, 'db', 'tracer.js'))\n  , Metrics          = require(path.join(__dirname, 'metrics.js'))\n  , MetricNormalizer = require(path.join(__dirname, 'metrics', 'normalizer.js'))\n  , MetricMapper     = require(path.join(__dirname, 'metrics', 'mapper.js'))\n  , TraceAggregator  = require(path.join(__dirname, 'transaction', 'trace', 'aggregator.js'))\n  ;\n\n/*\n *\n * CONSTANTS\n *\n */\n\nvar STATES = [\n  'stopped',      // start state\n  'starting',     // handshaking with NR\n  'connected',    // connected to collector\n  'disconnected', // disconnected from collector\n  'started',      // up and running\n  'stopping',     // shutting down\n  'errored'       // stopped due to error\n];\n\n// just to make clear what's going on\nvar TO_MILLIS   = 1e3\n  , FROM_MILLIS = 1e-3\n  ;\n\nvar COMMAND_FETCH_PERIOD=120;\n\n//if(process.env.ONEAPM_DEMO){\n//  console.log('DEMO Environment, COMMAND_FETCH_PERIOD is set to 5');\n//  COMMAND_FETCH_PERIOD=5;\n//}\n\n/**\n * There's a lot of stuff in this constructor, due to Agent acting as the\n * orchestrator for OneAPM within instrumented applications.\n *\n * This constructor can throw if, for some reason, the configuration isn't\n * available. Don't try to recover here, because without configuration the\n * agent can't be brought up to a useful state.\n */\nfunction Agent(config) {\n  EventEmitter.call(this);\n\n  if (!config) throw new Error(\"Agent must be created with a configuration!\");\n\n  this._state = 'stopped';\n\n  this.config = config;\n  this.config.on('apdex_t', this._apdexTChange.bind(this));\n  this.config.on('data_report_period', this._harvesterIntervalChange.bind(this));\n\n  // high security mode\n  this.config.on('agent_enabled', this._enabledChange.bind(this));\n\n  this.environment = require(path.join(__dirname, 'environment'));\n  this.version     = this.config.version;\n\n  this.collector = new CollectorAPI(this);\n  this.config.on('change', this._configChange.bind(this));\n\n  // error tracing\n  this.errors = new ErrorTracer(this.config);\n\n  // query tracing\n  this.queries = new QueryTracer(this.config);\n\n  // metrics\n  this.mapper = new MetricMapper();\n  this.metricNameNormalizer = new MetricNormalizer(this.config, 'metric name');\n  this.config.on(\n    'metric_name_rules',\n    this.metricNameNormalizer.load.bind(this.metricNameNormalizer)\n  );\n  this.metrics = new Metrics(this.config.apdex_t, this.mapper, this.metricNameNormalizer);\n\n  // transaction naming\n  this.transactionNameNormalizer = new MetricNormalizer(this.config, 'transaction name');\n  this.config.on(\n    'transaction_name_rules',\n    this.transactionNameNormalizer.load.bind(this.transactionNameNormalizer)\n  );\n  this.urlNormalizer = new MetricNormalizer(this.config, 'URL');\n  this.config.on('url_rules', this.urlNormalizer.load.bind(this.urlNormalizer));\n\n  // user naming and ignoring rules\n  this.userNormalizer = new MetricNormalizer(this.config, 'user');\n  this.userNormalizer.loadFromConfig();\n\n  // transaction traces\n  this.tracer = this._setupTracer();\n  this.traces = new TraceAggregator(this.config);\n\n  // insights events\n  this.events = new Events(this.mapper);\n  this.events.limit = this.config.transaction_events.max_samples_per_minute;\n\n  // supportability\n  if (this.config.debug.internal_metrics) {\n    this.config.debug.supportability = new Metrics(\n      this.config.apdex_t,\n      this.mapper,\n      this.metricNameNormalizer\n    );\n  }\n\n  // hidden class\n  this.harvesterHandle = null;\n  \n  // intervalTimer for commands listener\n  this.commandsHandle = null;\n\n  // agent events\n  this.on('transactionFinished', this._transactionFinished.bind(this));\n  this.on('command',this.commandHandler.bind(this));\n}\nutil.inherits(Agent, EventEmitter);\n\n\n/**\n * \n * @param {Array} cmdItem [ 730, { name: 'restart', arguments: {} } ]\n */\nAgent.prototype.commandHandler = function commandHandler(cmdItem) {\n    var agent = this;\n\n    var cmdId = cmdItem[0];\n    var cmdData = cmdItem[1];\n    \n    logger.info('remote command received %d : %s', cmdId, cmdData)\n\n    if (cmdData.name === 'restart') {\n      logger.info('restarting');\n      \n      agent.stop(function (err) {\n        if (err) {\n          logger.error(err);\n        }\n        agent.start(function (err) {\n          if (err) {\n            logger.error(err);\n          }          \n        });\n      });\n    } else {\n      logger.warn('command type %s not supported', cmdData.name);\n    }\n}\n\n/**\n * The agent is meant to only exist once per application, but the singleton is\n * managed by index.js. An agent will be created even if the agent's disabled by\n * the configuration.\n *\n * @config {boolean} agent_enabled Whether to start up the agent.\n *\n * @param {Function} callback Continuation and error handler.\n */\nAgent.prototype.start = function start(callback) {\n  if (!callback) throw new TypeError(\"callback required!\");\n\n  var agent = this;\n\n  this.state('starting');\n\n  if (this.config.agent_enabled !== true) {\n    logger.warn(\"The OneAPM Node.js agent is disabled by its configuration. \" +\n                \"Not starting!\");\n\n    this.state('stopped');\n    return process.nextTick(callback);\n  }\n\n  if (!(this.config.license_key)) {\n    logger.error(\"A valid account license key cannot be found. \" +\n                 \"Has a license key been specified in the agent configuration \" +\n                 \"file or via the ONEAPM_LICENSE_KEY environment variable?\");\n\n    this.state('errored');\n    return process.nextTick(function cb_nextTick() {\n      callback(new Error(\"Not starting without license key!\"));\n    });\n  }\n\n  sampler.start(agent);\n\n  logger.info(\"Starting OneAPM for Node.js connection process.\");\n\n  this.collector.connect(function cb_connect(error, config) {\n    if (error) {\n      agent.state('errored');\n      return callback(error, config);\n    }\n\n    if (agent.collector.isConnected()) {\n      \n      // check new commands every two minutes \n      agent.commandsHandle = agent.commandsHandle || setInterval(function () {\n        agent.collector.commands(function (error, returned, json) {\n          \n          if (error) {\n            // error could be: not connected to colletor\n            logger.error(error);\n            return;\n          }\n\n          if (returned && returned.length > 0) {\n            // emit all events together\n            returned.forEach(function (item) {\n              agent.emit('command', item);\n            });\n          }       \n        });\n      }, COMMAND_FETCH_PERIOD * TO_MILLIS);\n        \n      // harvest immediately for quicker data display\n      agent.harvest(function cb_harvest(error) {\n        if(process.env.ONEAPM_DEMO){\n          console.log('DEMO Environment, data_report_period is set to 5');\n          agent._startHarvester(5);\n        }else{\n          agent._startHarvester(agent.config.data_report_period);\n        }\n\n        agent.state('started');\n        callback(error, config);\n      });\n    }\n    else {\n      process.nextTick(function cb_nextTick() { callback(null, config); });\n    }\n  });\n};\n\n/**\n * Any memory claimed by the agent will be retained after stopping.\n *\n * FIXME: make it possible to dispose of the agent, as well as do a\n * \"hard\" restart. This requires working with shimmer to strip the\n * current instrumentation and patch to the module loader.\n */\nAgent.prototype.stop = function stop(callback) {\n  if (!callback) throw new TypeError(\"callback required!\");\n\n  var agent = this;\n\n  this.state('stopping');\n  this._stopHarvester();\n\n  clearInterval(agent.commandsHandle);\n  agent.commandsHandle = null;\n  \n  sampler.stop();\n\n  if (this.collector.isConnected()) {\n    this.collector.shutdown(function cb_shutdown(error) {\n      if (error) {\n        agent.state('errored');\n        logger.warn(error, \"Got error shutting down connection to OneAPM:\");\n      }\n      else {\n        agent.state('stopped');\n        logger.info(\"Stopped OneAPM for Node.js.\");\n      }\n\n      callback(error);\n    });\n  }\n  else {\n    process.nextTick(callback);\n  }\n};\n\n/**\n * On agent startup, an interval timer is started that calls this method once\n * a minute, which in turn invokes the pieces of the harvest cycle. It calls\n * the various collector API methods in order, bailing out if one of them fails,\n * to ensure that the agents don't pummel the collector if it's already\n * struggling.\n */\nAgent.prototype.harvest = function harvest(callback) {\n  if (!callback) throw new TypeError(\"callback required!\");\n\n  var agent = this;\n\n  // not necessary to make sure of it again and again\n  if (this.collector.isConnected()) {\n    agent._sendMetrics(function cb__sendMetrics(error) {\n      if (error) return callback(error);\n\n      agent._sendErrors(function cb__sendErrors(error) {\n        if (error) return callback(error);\n\n        agent._sendTrace(function cb__sendTrace(error) {\n          if (error) return callback(error);\n\n          agent._sendEvents( function cb_sendEvents(error) {\n            if (error) return callback(error);\n\n            agent._sendQueries(callback);\n          });\n\n        });\n      });\n    });\n  }\n  else {\n    process.nextTick(function cb_nextTick() {\n      callback(new Error(\"Not connected to OneAPM!\"));\n    });\n  }\n};\n\n/**\n * Public interface for passing configuration data from the collector\n * on to the configuration, in an effort to keep them at least somewhat\n * decoupled.\n *\n * @param {object} configuration New config JSON from the collector.\n */\nAgent.prototype.reconfigure = function reconfigure(configuration) {\n  if (!configuration) throw new TypeError(\"must pass configuration\");\n\n  this.config.onConnect(configuration);\n};\n\n/**\n * Make it easier to determine what state the agent thinks it's in (needed\n * for a few tests, but fragile).\n *\n * FIXME: remove the need for this\n *\n * @param {string} newState The new state of the agent.\n */\nAgent.prototype.state = function state(newState) {\n  if (STATES.indexOf(newState) === -1) {\n    throw new TypeError(\"Invalid state \" + newState);\n  }\n  logger.debug(\"Agent state changed from %s to %s.\", this._state, newState);\n  this._state = newState;\n  this.emit(this._state);\n};\n\n/**\n * Server-side configuration value.\n *\n * @param {number} apdexT Apdex tolerating value, in seconds.\n */\nAgent.prototype._apdexTChange = function _apdexTChange(apdexT) {\n  logger.debug(\"Apdex tolerating value changed to %s.\", apdexT);\n  this.metrics.apdexT = apdexT;\n  if (this.config.debug.supportability) {\n    this.config.debug.supportability.apdexT = apdexT;\n  }\n};\n\n/**\n * Server-side configuration value. When run, forces a harvest cycle\n * so as to not cause the agent to go too long without reporting.\n *\n * @param {number} interval Time in seconds between harvest runs.\n */\nAgent.prototype._harvesterIntervalChange = function _harvesterIntervalChange(interval, callback) {\n  var agent = this;\n\n  // only change the setup if the harvester is currently running\n  if (this.harvesterHandle) {\n    // force a harvest now, to be safe\n    this.harvest(function cb_harvest(error) {\n      agent._restartHarvester(interval);\n      if (callback) callback(error);\n    });\n  }\n  else {\n    if (callback) process.nextTick(callback);\n  }\n};\n\n/**\n * Restart the harvest cycle timer.\n *\n * @param {number} harvestSeconds How many seconds between harvests.\n */\nAgent.prototype._restartHarvester = function _restartHarvester(harvestSeconds) {\n  this._stopHarvester();\n  this._startHarvester(harvestSeconds);\n};\n\n/**\n * Safely stop the harvest cycle timer.\n */\nAgent.prototype._stopHarvester = function _stopHarvester() {\n  if (this.harvesterHandle) clearInterval(this.harvesterHandle);\n  this.harvesterHandle = undefined;\n};\n\n/**\n * Safely start the harvest cycle timer, and ensure that the harvest\n * cycle won't keep an application from exiting if nothing else is\n * happening to keep it up.\n *\n * @param {number} harvestSeconds How many seconds between harvests.\n */\nAgent.prototype._startHarvester = function _startHarvester(harvestSeconds) {\n  var agent = this;\n  function onError(error) {\n    if (error) {\n      logger.info(error, \"Error on submission to OneAPM (data held for redelivery):\");\n    }\n  }\n  function harvester() { agent.harvest(onError); }\n\n  this.harvesterHandle = setInterval(harvester, harvestSeconds * TO_MILLIS);\n  // timer.unref is 0.9+\n  if (this.harvesterHandle.unref) this.harvesterHandle.unref();\n};\n\n/**\n * `agent_enabled` changed. This will generally only happen because of a high\n * security mode mismatch between the agent and the collector. This only\n * expects to have to stop the agent. No provisions have been made, nor\n * testing have been done to make sure it is safe to start the agent back up.\n */\nAgent.prototype._enabledChange = function() {\n  if (this.config.agent_enabled === false) {\n    logger.warn('agent_enabled has been changed to false, stopping the agent.');\n    this.stop(function nop() {});\n  }\n};\n\n/**\n * Report new settings to collector after a configuration has changed. This\n * always occurs after handling a response from a connect call.\n */\nAgent.prototype._configChange = function _configChange() {\n  this.collector.reportSettings();\n};\n\n/**\n * To develop the current transaction tracer, I created a tracing tracer that\n * tracks when transactions, segments and function calls are proxied. This is\n * used by the tests, but can also be dumped and logged, and is useful for\n * figuring out where in the execution chain tracing is breaking down.\n *\n * @param object config Agent configuration.\n *\n * @returns Tracer Either a debugging or production transaction tracer.\n */\nAgent.prototype._setupTracer = function _setupTracer() {\n  var Tracer;\n  var debug = this.config.debug;\n  if (debug && debug.tracer_tracing) {\n    Tracer = require(path.join(__dirname, 'transaction', 'tracer', 'debug'));\n  }\n  else {\n    Tracer = require(path.join(__dirname, 'transaction', 'tracer'));\n  }\n\n  return new Tracer(this);\n};\n\n/**\n * The pieces of supportability metrics are scattered all over the place -- only\n * send supportability metrics if they're explicitly enabled in the\n * configuration.\n *\n * @param {Function} callback Gets any delivery errors.\n */\nAgent.prototype._sendMetrics = function _sendMetrics(callback) {\n  var agent = this;\n\n  if (this.collector.isConnected()) {\n    if (this.errors.errorCount > 0) {\n      this.metrics.getOrCreateMetric(NAMES.ERRORS.ALL).incrementCallCount(this.errors.errorCount);\n      this.metrics.getOrCreateMetric(NAMES.ERRORS.WEB).incrementCallCount(this.errors.errorWebCount);\n      this.metrics.getOrCreateMetric(NAMES.ERRORS.OTHER).incrementCallCount(this.errors.errorOtherCount);\n    }\n\n\n    // merge internal metrics and send them\n    if (this.config.debug.supportability) {\n      this.metrics.merge(this.config.debug.supportability);\n    }\n\n    // wait to check until all the standard stuff has been added\n    if (this.metrics.toJSON().length < 1) {\n      logger.debug(\"No metrics to send.\");\n      return process.nextTick(callback);\n    }\n\n    var metrics      = this.metrics\n      , beginSeconds = metrics.started * FROM_MILLIS\n      , endSeconds   = Date.now() * FROM_MILLIS\n      , payload      = [this.config.run_id, beginSeconds, endSeconds, metrics]\n      ;\n\n    // reset now to avoid losing metrics that come in after delivery starts\n    this.metrics = new Metrics(\n      this.config.apdex_t,\n      this.mapper,\n      this.metricNameNormalizer\n    );\n\n    this.collector.metricData(payload, function cb_metricData(error, rules) {\n      if (error) agent.metrics.merge(metrics);\n      \n       // send data and get metric mapper to be used\n      if (rules) agent.mapper.load(rules);\n\n      callback(error);\n    });\n  }\n  else {\n    process.nextTick(function cb_nextTick() {\n      callback(new Error(\"not connected to OneAPM (metrics will be held)\"));\n    });\n  }\n};\n\n/**\n * The error tracer doesn't know about the agent, and the connection\n * doesn't know about the error tracer. Only the agent knows about both.\n *\n * @param {Function} callback Gets any delivery errors.\n */\nAgent.prototype._sendErrors = function _sendErrors(callback) {\n  var agent = this;\n\n  if (this.config.collect_errors && this.config.error_collector.enabled) {\n    if (!this.collector.isConnected()) {\n      return process.nextTick(function cb_nextTick() {\n        callback(new Error(\"not connected to OneAPM (errors will be held)\"));\n      });\n    }\n    else if (this.errors.errors < 1) {\n      logger.debug(\"No errors to send.\");\n      return process.nextTick(callback);\n    }\n\n    var errors  = this.errors.errors\n      , payload = [this.config.run_id, errors]\n      ;\n\n    // reset now to avoid losing errors that come in after delivery starts\n    this.errors = new ErrorTracer(agent.config);\n\n    this.collector.errorData(payload, function cb_errorData(error) {\n       // will merging old errors create memory leak ?\n      if (error) agent.errors.merge(errors);\n\n      callback(error);\n    });\n  }\n  else {\n    /**\n     * Reset the errors object even if collection is disabled due to error\n     * counting. Also covers the case where the error collector gets disabled\n     * in the middle of a harvest cycle so the agent doesn't continue to hold\n     * on to the errors it had collected during the harvest cycle so far.\n     */\n    this.errors = new ErrorTracer(agent.config);\n    process.nextTick(callback);\n  }\n};\n\n/**\n * The trace aggregator has its own harvester, which is already\n * asynchronous, due to its need to compress the nested transaction\n * trace data.\n *\n * @param {Function} callback Gets any encoding or delivery errors.\n */\nAgent.prototype._sendTrace = function _sendTrace(callback) {\n  var agent = this;\n  if (this.config.collect_traces && this.config.transaction_tracer.enabled) {\n    if (!this.collector.isConnected()) {\n      return process.nextTick(function cb_nextTick() {\n        callback(new Error(\"not connected to OneAPM (slow trace data will be held)\"));\n      });\n    }\n\n    this.traces.harvest(function cb_harvest(error, encoded, trace) {\n      if (error || !encoded) return callback(error);\n\n      var payload = [agent.config.run_id, [encoded]];\n      agent.collector.transactionSampleData(payload, function cb_transactionSampleData(error) {\n        if (!error) agent.traces.reset(trace);\n\n        callback(error);\n      });\n    });\n  }\n  else {\n    process.nextTick(callback);\n  }\n};\n\n\nAgent.prototype._sendQueries = function _sendQueries(callback) {\n  var agent = this\n  var queries = this.queries\n\n  this.queries = new QueryTracer(agent.config)\n\n  if (! (this.config.slow_sql && this.config.slow_sql.enabled) ) {\n    logger.debug('Slow Query is not enabled.')\n    return process.nextTick(callback)\n  }\n\n  if (Object.keys(queries.samples).length < 1) {\n    logger.debug('No queries to send.')\n    return process.nextTick(callback)\n  }\n\n  queries.prepareJSON(function gotJSON(err, data) {\n    if (err) {\n      this.queries.merge(queries)\n      logger.debug('Error while serializing query data: %s', err.message)\n      return callback(err)\n    }\n\n    agent.collector.queryData([data], function handleResponse(error) {\n      if (error) agent.queries.merge(queries)\n      callback(error)\n    })\n  })\n}\n\nAgent.prototype._sendEvents = function _sendEvents (callback) {\n  if (this.config.transaction_events.enabled) {\n    var agent  = this;\n    var events = agent.events;\n    var sample = events.toArray();\n    var run_id = agent.config.run_id;\n\n    // bail if there are no events\n    if (sample.length < 1) {\n      return process.nextTick(callback);\n    }\n\n    var payload = sample;\n\n    // clear events\n    agent.events = new Events(agent.mapper);\n    agent.events.limit = agent.config.transaction_events.max_samples_per_minute;\n\n    // send data to collector\n    agent.collector.analyticsEvents(payload, function cb_analyticsEvents(err) {\n\n      if (err && err.statusCode === 413 ) {\n        logger.warn('request too large; event data dropped');\n      }\n      else if (err) {\n        logger.warn('analytics events failed to send; re-sampling');\n\n        // boost the limit if a connection fails\n        // and re-aggregate on failure\n        var newlimit = agent.config.transaction_events.max_samples_stored;\n        agent.events.limit = newlimit;\n\n        for(var k=0; k<sample.length; k++) agent.events.add(sample[k]);\n      }\n      else {\n        // if we had to limit events and sample them, emit a warning\n        var diff = events.overflow();\n        if (diff > 0) logger.warn(\n          'analytics event overflow, dropped %d events; ' +\n           'try increasing your limit above %d',\n          diff, events.limit\n        );\n      }\n\n      callback(err);\n    });\n  }\n  else {\n    process.nextTick(callback);\n  }\n};\n\nAgent.prototype._addEventFromTransaction = function _addEventFromTransaction(transaction) {\n  if (!this.config.transaction_events.enabled) return;\n\n  var mapper = this.mapper;\n\n  var eventName = [-1, transaction.name, \"\"];\n  var duration = transaction.timer.duration / 1000;\n  var execTime = duration; // TODO\n\n  var event = {\n    name: eventName, \n    startTime: transaction.timer.start,\n    guid: transaction.guid,\n    refererGuid: transaction.referer_guid,\n    tripGuid: transaction.trip_guid,\n    callCount: 1,\n    duration: duration,\n    errors: transaction.error ? 1 : 0,\n    ApdexPerfZone: null,\n    requestUrl: transaction.fullUrl,\n    bytesRead: transaction.bytesRead, \n    bytesWritten: transaction.bytesWritten, \n    hasTrace: transaction.trace !== null,\n    execTime: execTime, \n    isAsync: 1,\n  };\n\n  // calculate apdex perfect zone\n  event.ApdexPerfZone = calcApdexPerfZone(this.config.apdex_t, event.duration)\n\n  this.events.add(event);\n\n  function calcApdexPerfZone(apdexT, duration) {\n    if (duration <= apdexT) {\n      return 'S';\n    }\n    else if (duration <= (4 * apdexT)) {\n      return 'T';\n    }\n    else {\n      return 'F';\n    }\n  }\n};\n\n/**\n * Put all the logic for handing finalized transactions off to the tracers and\n * metric collections in one place.\n *\n * @param {Transaction} transaction Newly-finalized transaction.\n */\nAgent.prototype._transactionFinished = function _transactionFinished(transaction) {\n  // only available when this.config.debug.tracer_tracing is true\n  if (transaction.describer) {\n    logger.trace({trace_dump : transaction.describer.verbose},\n                 \"Dumped transaction state.\");\n  }\n\n  if (!transaction.ignore) {\n    if (transaction.forceIgnore === false) {\n      logger.debug(\"Explicitly not ignoring %s.\", transaction.name);\n    }\n    this.metrics.merge(transaction.metrics);\n    this.errors.onTransactionFinished(transaction, this.metrics);\n    this.traces.add(transaction);\n\n    this._addEventFromTransaction(transaction);\n  }\n  else {\n    if (transaction.forceIgnore === true) {\n      logger.debug(\"Explicitly ignoring %s.\", transaction.name);\n    }\n    else {\n      logger.debug(\"Ignoring %s.\", transaction.name);\n    }\n  }\n};\n\n/**\n * Get the current transaction (if there is one) from the tracer.\n *\n * @returns {Transaction} The current transaction.\n */\nAgent.prototype.getTransaction = function getTransaction() {\n  return this.tracer.getTransaction();\n};\n\nmodule.exports = Agent;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/events.js":"var assert = require('assert')\n\n\nfunction Events(mapper) {\n    assert(mapper !== null && mapper !== undefined)\n\n    this.mapper = mapper;\n    this.list = [];\n    this.limit = 0; // not implemented\n}\n\nEvents.prototype.overflow = function overflow() {\n    // never overflow\n    return 0;\n};\n\nEvents.prototype.add = function(newEvent) {\n    this.list.push(newEvent)\n}\n\nEvents.prototype.toArray = function() {\n    var mapper = this.mapper\n    // list of: [{name, events}, ...]\n    var groupByName = groupEventsByName(this.list)\n    var array = groupByName.map(function(group) {\n        return [\n            mapName(group.name),\n            group.events.map(function(event) {\n                return [\n                    event.startTime,\n                    event.guid,\n                    event.refererGuid,\n                    event.tripGuid,\n                    event.callCount,\n                    event.duration,\n                    event.errors,\n                    event.ApdexPerfZone,\n                    event.requestUrl,\n                    event.bytesWritten,\n                    event.bytesRead,\n                    event.hasTrace ? 1 : 0,\n                    event.execTime,\n                    event.isAsync ? 1 : 0,\n                ]\n            })\n        ]\n    })\n    return array;\n\n    function mapName(groupName) {\n        assert(Array.isArray(groupName) && groupName.length === 3)\n        var transactionName = groupName[1]\n        var metricId = mapper.map(transactionName)\n        if (typeof metricId === 'number') {\n            return [metricId]\n        }\n        else {\n            return groupName\n        }\n    }\n}\n\nfunction mergeTo(srcEvent, dstEvent) {\n    dstEvent.startTime = Math.min(srcEvent.startTime, dstEvent.startTime);\n    // keep dstEvent.guid?\n    // keep dstEvent.refererGuid?\n    dstEvent.callCount += srcEvent.callCount;\n    // add dstEvent.duration ?\n    dstEvent.errors += srcEvent.errors;\n    dstEvent.ApdexPerfZone = lowerApdexPerfZone(srcEvent.ApdexPerfZone, dstEvent.ApdexPerfZone);\n    dstEvent.bytesWritten += srcEvent.bytesWritten;\n    dstEvent.bytesRead += dstEvent.bytesRead;\n    // keep dstEvent.hasTrace?\n    // add dstEvent.execTime?\n\n    function lowerApdexPerfZone(a, b) {\n        // 'F' < 'T' < 'S'\n        var value = {\n            'f': 0,\n            'F': 0,\n            't': 1, \n            'T': 1,\n            's': 2,\n            'S': 2\n        }\n        if (value[a] < value[b]) {\n            return a\n        }\n        else {\n            return b\n        }\n    }\n}\n\nfunction groupEventsByName(events) {\n    var nameMap = {}\n    var groups = []\n    events.forEach(function(event) {\n        var strName = JSON.stringify(event.name)\n        if (!nameMap[strName]) {\n            var group = {\n                name: event.name,\n                events: []\n            }\n            nameMap[strName] = group\n            groups.push(group)\n        }\n        pushOrMerge(nameMap[strName].events, event)\n    })\n\n    return groups\n}\n\nfunction pushOrMerge(list, event) {\n    var merged = false\n    for (var i = 0, len = list.length; i < len; ++i) {\n        var existing_event = list[i]\n        if (existing_event.tripGuid === event.tripGuid) {\n            mergeTo(event, existing_event)\n            merged = true\n            break\n        }\n    }\n    if (!merged) {\n        list.push(event)\n    }\n}\n\nmodule.exports = Events;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/environment.js":"'use strict';\n\nvar path = require('path');\nvar fs   = require('fs');\nvar os   = require('os');\nvar logger = require('oneapm-logger')\nvar isDocker = require('is-docker');\n\nvar exists = fs.existsSync || path.existsSync;\n\n/**\n * true if and only if path exists and is a directory\n * should now throw\n */\nfunction existsDir(dirPath) {\n  if (!exists(dirPath)) return false;\n\n  var stat = fs.statSync(dirPath);\n  if (stat) return stat.isDirectory();\n\n  return false;\n}\n\nvar remapping = {\n  node_install_npm    : \"npm installed?\",\n  node_install_waf    : \"WAF build system installed?\",\n  node_use_openssl    : \"OpenSSL support?\",\n  node_shared_openssl : \"Dynamically linked to OpenSSL?\",\n  node_shared_v8      : \"Dynamically linked to V8?\",\n  node_shared_zlib    : \"Dynamically linked to Zlib?\",\n  node_use_dtrace     : \"DTrace support?\",\n  node_use_etw        : \"Event Tracing for Windows (ETW) support?\"\n};\n\nvar settings = [];\n\nfunction getSetting(name) {\n  var items = settings.filter(function cb_filter(candidate) {\n    return candidate[0] === name;\n  }).map(function cb_map(setting) {\n    return setting[1];\n  });\n\n  return items;\n}\n\n/**\n * Add a setting to the module's shared settings object.\n *\n * @param string name\n * @param string value\n */\nfunction addSetting(name, value) {\n  if (getSetting(name).indexOf(value) === -1) settings.push([name, value]);\n}\n\n/**\n * Remove settings with the given name.\n *\n * @param {string} name\n */\nfunction clearSetting(name) {\n  settings = settings.filter(function cb_filter(candidate) {\n    return candidate[0] !== name;\n  });\n}\n\n/**\n * Build up a list of top-level packages available to an application relative\n * to the provided root.\n *\n * @param string root Where to start.\n * @return array List of packages.\n */\nfunction listPackages(root) {\n  var packages = [];\n  if (existsDir(root)) {\n    packages = fs.readdirSync(root)\n      .filter(function cb_filter(entry) {\n        var candidate = path.resolve(root, entry);\n        if (fs.existsSync(candidate)) {\n          var isDir = fs.statSync(candidate).isDirectory();\n          var packageJsonExists = exists(path.resolve(candidate, 'package.json'));\n          var isSymbolicLink = fs.lstatSync( candidate ).isSymbolicLink();\n          return  isDir && packageJsonExists && (!isSymbolicLink);\n        }\n      })\n      .map(function cb_map(dir) {\n        var pck = path.resolve(root, dir, 'package.json');\n        // The parsing of package.json might fail by unknown reasons, just catch the error to make the program continue.\n        // Thanks the good guy Aray at doupai.cc, who figures out the issue for us and provids the solution.\n        var version = '<unknown>';\n        try {\n          version = JSON.parse(fs.readFileSync(pck)).version;\n        }\n        catch( e ) {\n          logger.warn('Failed to parse package.json %s', pck);\n        }\n        return [dir, version];\n      });\n  }\n\n  return packages;\n}\n\n/**\n * Build up a list of dependencies from a given node_module root.\n *\n * @param string root Where to start.\n * @return array List of dependencies.\n */\nfunction listDependencies(root) {\n  var children = [];\n  if (existsDir(root)) {\n    fs.readdirSync(root)\n      .filter(function cb_filter(entry) {\n        var candidate = path.resolve(root, entry);\n        if (fs.existsSync(candidate)) {\n          var isDir = fs.statSync(candidate).isDirectory();\n          var packageJsonExists = exists(path.resolve(candidate, 'package.json'));\n          var isSymbolicLink = fs.lstatSync( candidate ).isSymbolicLink();\n          return  isDir && packageJsonExists && (!isSymbolicLink);\n        }\n      })\n      .forEach(function cb_forEach(entry) {\n        var candidate = path.resolve(root, entry, 'node_modules');\n        if (exists(candidate)) {\n          children = children.concat(listPackages(candidate));\n          children = children.concat(listDependencies(candidate));\n        }\n      });\n  }\n\n  return children;\n}\n\n/**\n * Build up a list of packages, starting from the current directory.\n *\n * @param string start Root directory to start generation from.\n * @returns object Two lists, of packages and dependencies, with the\n *                 appropriate names.\n */\nfunction getLocalPackages(start) {\n  var packages     = []\n    , dependencies = []\n    , candidate    = start\n    ;\n\n  while (candidate) {\n    var root = path.resolve(candidate, 'node_modules');\n    packages = packages.concat(listPackages(root));\n    dependencies = dependencies.concat(listDependencies(root));\n\n    var last = candidate;\n    candidate = path.dirname(candidate);\n    if (last === candidate) break;\n  }\n\n  return {packages : packages, dependencies : dependencies};\n}\n\n/**\n * Generic method for getting packages and dependencies relative to a\n * provided root directory.\n *\n * @param string root Where to start looking -- doesn't add node_modules.\n * @returns object Two lists, of packages and dependencies, with the\n *                 appropriate names.\n */\nfunction getPackages(root) {\n  var packages     = []\n    , dependencies = []\n    ;\n\n  if (exists(root)) {\n    packages = listPackages(root);\n    dependencies = listDependencies(root);\n  }\n\n  return {packages : packages, dependencies : dependencies};\n}\n\n/**\n * Generate a list of globally-installed packages, if available / accessible\n * via the environment.\n *\n * @returns object Two lists, of packages and dependencies, with the\n *                 appropriate names.\n */\nfunction getGlobalPackages() {\n  var packages     = []\n    , dependencies = []\n    ;\n\n  if (process.config && process.config.variables) {\n    var prefix = process.config.variables.node_prefix;\n    if (prefix) {\n      var root = path.resolve(prefix, 'lib', 'node_modules');\n      return getPackages(root);\n    }\n  }\n\n  return {packages : packages, dependencies : dependencies};\n}\n\n/**\n * Take a list of packages and reduce it to a list of pairs serialized\n * to JSON (to simplify things on the collector end) where each\n * package appears at most once, with all the versions joined into a\n * comma-delimited list.\n *\n * @returns Array Sorted list of [name, version] pairs.\n */\nfunction flattenVersions(packages) {\n  var info = Object.create(null);\n  packages.forEach(function cb_forEach(pair) {\n    var p = pair[0]\n      , v = pair[1]\n      ;\n\n    if (info[p]) {\n      if (info[p].indexOf(v) < 0) info[p].push(v);\n    }\n    else {\n      info[p] = [v];\n    }\n  });\n\n  return Object.keys(info)\n               .map(function cb_map(key) {\n                 return [key, info[key].join(', ')];\n               })\n               .sort()\n               .map(function cb_map(pair) {\n                 return JSON.stringify(pair);\n               });\n}\n\n/**\n * There are a bunch of settings generated at build time that are useful to\n * know for troubleshooting purposes. These settings are only available in 0.7\n * and up.\n *\n * This function works entirely via side effects using the\n * addSetting function.\n */\nfunction remapConfigSettings() {\n  if (process.config && process.config.variables) {\n    var variables = process.config.variables;\n    Object.keys(variables).forEach(function cb_forEach(key) {\n      if (remapping[key]) {\n        var value = variables[key];\n\n        if (value === true  || value === 1) value = 'yes';\n        if (value === false || value === 0) value = 'no';\n\n        addSetting(remapping[key], value);\n      }\n    });\n  }\n}\n\n/**\n * Scrape the list of packages, following the algorithm as described in the\n * node module page:\n *\n * http://nodejs.org/docs/latest/api/modules.html\n *\n * This function works entirely via side effects using the addSetting\n * function.\n */\nfunction findPackages() {\n  var local   = getLocalPackages(process.cwd())\n    , all     = getGlobalPackages()\n    , other   = {packages : [], dependencies : []}\n    ;\n\n  if (process.env.NODE_PATH) {\n    var paths;\n    if (process.platform === 'win32') { // why. WHY.\n      paths = process.env.NODE_PATH.split(';');\n    }\n    else {\n      paths = process.env.NODE_PATH.split(':');\n    }\n\n    paths.forEach(function cb_forEach(nodePath) {\n      if (nodePath[0] !== '/') nodePath = path.resolve(process.cwd(), nodePath);\n      var nextSet = getPackages(nodePath);\n      other.packages = other.packages.concat(nextSet.packages);\n      other.dependencies = other.dependencies.concat(nextSet.dependencies);\n    });\n  }\n\n  var packages = local.packages.concat(\n    all.packages,\n    other.packages\n  );\n\n  var dependencies = local.dependencies.concat(\n    all.dependencies,\n    other.dependencies\n  );\n\n  var home\n    , homeOld\n    ;\n\n  if (process.platform === 'win32') {\n    if (process.env.USERDIR) {\n      home    = getPackages(path.resolve(process.env.USERDIR, '.node_modules'));\n      homeOld = getPackages(path.resolve(process.env.USERDIR, '.node_libraries'));\n    }\n  }\n  else {\n    if (process.env.HOME) {\n      home    = getPackages(path.resolve(process.env.HOME, '.node_modules'));\n      homeOld = getPackages(path.resolve(process.env.HOME, '.node_libraries'));\n    }\n  }\n\n  if (home) {\n    packages.unshift(home.packages);\n    dependencies.unshift(home.dependencies);\n  }\n\n  if (homeOld) {\n    packages.unshift(homeOld.packages);\n    dependencies.unshift(homeOld.dependencies);\n  }\n\n  addSetting('Packages', flattenVersions(packages));\n  addSetting('Dependencies', flattenVersions(dependencies));\n}\n\n// hi Nuno\nfunction badOS() {\n  var badVersion = false;\n\n  if (!process.versions) {\n    badVersion = true;\n  }\n  else {\n    var version = process.versions.node.split('.');\n    if (version[1] <= 8 && version[2] <= 5) badVersion = true;\n  }\n\n  return badVersion &&\n         os.arch() === 'x64' &&\n         os.type() === 'SunOS';\n}\n\n\n/**\n *\n * @param bytes {Number} size in bytes\n * @return {string} size in MB\n */\nfunction readableSize(bytes){\n  return Math.round( bytes / Math.pow(2,20) )+\"MB\"\n}\n\n/**\n * Settings actually get scraped below.\n */\nfunction gatherEnv() {\n  // in 64-bit SmartOS zones, node <= 0.8.5 pukes on os.cpus()\n  if (!badOS()) {\n    var cpus = os.cpus();\n    addSetting('Processors', cpus.length);\n    addSetting('CPU Model', cpus[0].model);\n  }\n\n  addSetting('Total Memory', readableSize(os.totalmem()));\n  addSetting('Free Memory', readableSize(os.freemem()));\n\n  addSetting('OS',              os.type());\n  addSetting('OS version',      os.release());\n  addSetting('Node.js version', process.version);\n  addSetting('Architecture',    process.arch);\n  addSetting('Docker',          isDocker()?\"yes\":\"no\");\n\n  var oneapmPackageFile = path.join(__dirname, '../package.json');\n  if (exists(oneapmPackageFile)) {\n    var from = require(oneapmPackageFile)._from;\n    addSetting('Install From', from ? from : \"N/A\");\n  }\n\n  if ('NODE_ENV' in process.env) {\n    addSetting('NODE_ENV',      process.env.NODE_ENV);\n  }\n};\n\n/**\n * Reset settings and gather them, built to minimally refactor this file.\n */\nfunction refresh() {\n  // gather persisted settings\n  var framework = getSetting('Framework');\n  var dispatcher = getSetting('Dispatcher');\n  // clearing and rebuilding a global variable\n  settings = [];\n  // add persisted settings\n  if (framework.length) {\n    framework.forEach(function (fw) {\n      addSetting('Framework', fw);\n    });\n  }\n\n  if (dispatcher.length) {\n    dispatcher.forEach(function (d) {\n      addSetting('Dispatcher', d);\n    });\n  }\n\n  gatherEnv();\n  remapConfigSettings();\n  findPackages();\n}\n// initialize settings\nrefresh();\n\n/**\n * Refreshes settings and returns the settings object.\n */\nfunction toJSON() {\n  refresh();\n\n  return settings;\n}\n\nmodule.exports = {\n  setFramework    : function setFramework(framework) { addSetting('Framework', framework); },\n  setDispatcher   : function setDispatcher(dispatcher) { addSetting('Dispatcher', dispatcher); },\n  clearFramework  : function clearFramework() { clearSetting('Framework'); },\n  clearDispatcher : function clearDispatcher() { clearSetting('Dispatcher'); },\n  toJSON          : toJSON,\n  get             : getSetting,\n  refresh         : refresh\n};\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/error.js":"'use strict';\n\nvar path    = require('path')\n  , urltils = require(path.join(__dirname, 'util', 'urltils'))\n  , logger  = require('oneapm-logger').child({component : 'error_tracer'})\n  , NAMES   = require(path.join(__dirname, 'metrics', 'names'))\n  ;\n\n/*\n *\n * CONSTANTS\n *\n */\nvar MAX_ERRORS = 20;\n\n/**\n * Given either or both of a transaction and an exception, generate an error\n * trace in the JSON format expected by the collector. Since this will be\n * used by both the HTTP instrumentation, which uses HTTP status codes to\n * determine whether a transaction is in error, and the domain-based error\n * handler, which traps actual instances of Error, try to set sensible\n * defaults for everything.\n *\n * @param {Transaction} transaction      The agent transaction, presumably\n *                                       coming out of the instrumentation.\n * @param {Error}       exception        Something trapped by an error listener.\n * @param {object}      customParameters Any custom parameters associated with\n *                                       the request (optional).\n */\nfunction createError(transaction, exception, customParameters, config) {\n  // the collector throws this out, so don't bother setting it\n  var timestamp = Date.now()/1000\n    , name      = 'WebTransaction/Uri/*'\n    , message   = ''\n    , type      = 'Error'\n    , params    = {\n      custom_params  : {},\n      agentAttributes : {},\n      intrinsics      : {},\n      requestParameters: {}\n    }\n    ;\n\n  if (transaction && transaction.name) name = transaction.name;\n  \n  // NB: anything throwing / emitting strings is buggy, but it happens\n  if (typeof exception === 'string') {\n    message = exception;\n  }\n  else if (exception && exception.message) {\n    message = exception.message;\n    // only care about extracting the type if it's Error-like.\n    if (exception && exception.constructor && exception.constructor.name) {\n      type = exception.constructor.name;\n    }\n  }\n  else if (transaction &&\n           transaction.statusCode &&\n           urltils.isError(config, transaction.statusCode)) {\n    message = 'HttpError ' + transaction.statusCode;\n  }\n\n  if (transaction && transaction.url) {\n    var url        = transaction.url\n      , statusCode = transaction.statusCode || 500\n      ;\n\n    /* We need a name for this transaction, but since error-tracing can happen\n     * in the middle of the request, and it's possible that the user will\n     * recover from the error, name the transaction now, preserving the\n     * necessary state to maintain any user-provided naming information.\n     */\n    if (!transaction.name) {\n      var partialName = transaction.partialName;\n      transaction.setName(url, statusCode);\n      transaction.partialName = partialName;\n    }\n\n    var custom = transaction.getTrace().custom;\n    Object.keys(custom).forEach(function (param) {\n      params.custom_params[param] = custom[param];\n    });\n\n    name = transaction.name;\n    params.request_uri = url;\n    if (config.capture_params) {\n      var reqParams = transaction.getTrace().parameters;\n      var urlParams = urltils.parseParameters(url);\n      // clear out ignored params\n      config.ignored_params.forEach(function cb_forEach(k) {\n        // polymorphic hidden classes aren't an issue with data bags\n        delete urlParams[k];\n        delete reqParams[k];\n      });\n\n      Object.keys(urlParams).forEach(function (param) {\n        params.agentAttributes[param] = urlParams[param];\n      });\n\n      Object.keys(reqParams).forEach(function (param) {\n        params.agentAttributes[param] = reqParams[param];\n      });\n    }\n  }\n\n  // this needs to be done *after* pulling custom params from transaction\n  var isHighSec = config.high_security;\n  if (customParameters && !isHighSec) {\n    var ignored = [];\n    if (transaction) ignored = config.ignored_params;\n    Object.keys(customParameters).forEach(function cb_forEach(param) {\n      if (ignored.indexOf(param) === -1) params.custom_params[param] = customParameters[param];\n    });\n  }\n\n  var stack = exception && exception.stack;\n  // FIXME: doing this work should not be the agent's responsibility\n  if (stack) params.stack_trace = ('' + stack).split(/[\\n\\r]/g);\n\n  try{\n    // copy all headers excluding cookie to requestParameters\n    Object.keys(transaction && transaction.headers).forEach(function(header){\n      if ([\"cookie\"].indexOf(header) === -1) {\n        params.requestParameters[header] = transaction.headers[header];\n      }\n    });\n    params.requestParameters['remoteAddress'] = transaction.remoteAddress;\n    params.requestParameters['exceptions'] = JSON.stringify(transaction.exceptions);\n  }catch(e){\n    logger.warn(e);\n  }\n\n  return [timestamp, name, message, type, params];\n}\n\n/**\n * This is a fairly simple-minded tracer that converts errored-out HTTP\n * transactions and JS Errors into the error traces expected by the collector.\n *\n * It also acts as a collector for the traced errors.\n */\nfunction ErrorTracer(config) {\n  this.config     = config;\n  this.errorCount = 0;\n  this.errorWebCount = 0;\n  this.errorOtherCount = 0; //not necessary because it can be calculated\n  this.errors     = [];\n  this.seen       = [];\n}\n\n/**\n * Every finished transaction goes through this handler, so do as\n * little as possible.\n */\nErrorTracer.prototype.onTransactionFinished = function onTransactionFinished(transaction, metrics) {\n  if (!transaction) throw new Error(\"Error collector got a blank transaction.\");\n  if (!metrics) throw new Error(\"Error collector requires metrics to count errors.\");\n\n  if (urltils.isError(this.config, transaction.statusCode) ||\n      (transaction.statusCode < 1 && transaction.exceptions.length > 0)) {\n    if (transaction.exceptions.length > 0) {\n      transaction.exceptions.forEach(function cb_forEach(exception) {\n        this.add(transaction, exception);\n      }, this);\n    }\n    else {\n      this.add(transaction);\n    }\n\n    var count = metrics.getOrCreateMetric(NAMES.ERRORS.PREFIX + transaction.name);\n    count.incrementCallCount(1);\n  }\n};\n\n/**\n * This function uses an array of seen exceptions to ensure errors don't get\n * double-counted. It can also be used as an unofficial means of marking that\n * user errors shouldn't be traced.\n *\n * For an error to be traced, at least one of the transaction or the error\n * must be present.\n *\n * NOTE: this interface is unofficial and may change in future.\n *\n * @param {Transaction} transaction      Transaction associated with the error\n *                                       (optional).\n * @param {Error}       exception        The error to be traced (optional).\n * @param {object}      customParameters Any custom parameters associated with\n *                                       the request (optional).\n */\nErrorTracer.prototype.add = function add(transaction, exception, customParameters) {\n  if (!exception) {\n    if (!transaction) return;\n    if (!transaction.statusCode) return;\n    if (transaction.error) return;\n  }\n  else {\n    if (this.seen.indexOf(exception) !== -1) return;\n    if (typeof exception !== 'string' && !exception.message && !exception.stack) {\n      return;\n    }\n  }\n\n  this.errorCount++;\n  \n  if(transaction && transaction.isWeb()){\n     this.errorWebCount++;\n  }else{\n     this.errorOtherCount++;\n  }\n\n  // allow enabling & disabling the error tracer at runtime\n  if (!this.config.collect_errors ||\n      !this.config.error_collector || !this.config.error_collector.enabled) return;\n\n  if (exception) {\n    logger.trace(exception, \"Got exception to trace:\");\n    // put the error on the transaction to show we've already traced it\n    if (transaction) transaction.error = exception;\n    this.seen.push(exception);\n  }\n\n  if (this.errors.length < MAX_ERRORS) {\n    var error = createError(transaction, exception, customParameters, this.config);\n    logger.debug({error : error}, \"Error to be sent to collector:\");\n    this.errors.push(error);\n    if( transaction ) { // Finish the transaction to make sure when error occurs, the transaction can also be recorded.\n      transaction.end();\n    }\n  }\n  else {\n    logger.debug(\"Already have %d errors to send to collector, not keeping.\",\n                 MAX_ERRORS);\n  }\n};\n\n/**\n * If the connection to the collector fails, retain as many as will fit without\n * overflowing the current error list.\n *\n * @param array errors Previously harvested errors.\n */\nErrorTracer.prototype.merge = function merge(errors) {\n  if (!errors) return;\n\n  var len = Math.min(errors.length, MAX_ERRORS - this.errors.length);\n  logger.warn(\"Merging %s (of %s) errors for next delivery.\", len, errors.length);\n  for (var i = 0; i < len; i++) this.errors.push(errors[i]);\n};\n\nmodule.exports = ErrorTracer;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/util/urltils.js":"'use strict';\n\nvar url = require('url');\n\n/**\n * Utility functions for enforcing OneAPM naming conditions on URLs,\n * and extracting and setting parameters on traces / web trace segments.\n */\nmodule.exports = {\n  /**\n   * This was handed down from the prototype as the canonical list of status\n   * codes that short-circuit naming and normalization. The agent can be\n   * configured to mark HTTP status codes as not being errors.\n   *\n   * @param {Config} config The configuration containing the error list.\n   * @param {string} code   The HTTP status code to check.\n   *\n   * @returns {bool} Whether the status code should be ignored.\n   */\n  isError : function isError(config, code) {\n    var codes = [];\n    if (config &&\n        config.error_collector &&\n        config.error_collector.ignore_status_codes) {\n      codes = config.error_collector.ignore_status_codes;\n    }\n    return code >= 400 && codes.indexOf(code) === -1;\n  },\n\n  /**\n   * Get back the pieces of the URL that OneAPM cares about. Apply these\n   * restrictions, in order:\n   *\n   * 1. Ensure that after parsing the URL, there's at least '/'\n   * 2. Strip off session trackers after ';' (a OneAPM convention)\n   * 3. Remove trailing slash.\n   *\n   * @param {string} requestURL The URL fragment to be scrubbed.\n   * @return {string} The cleaned URL.\n   */\n  scrub : function scrub(requestURL) {\n    var path = url.parse(requestURL).pathname;\n\n    if (path) {\n      path = path.split(';')[0];\n\n      if (path !== '/' && path.charAt(path.length - 1) === '/') {\n        path = path.substring(0, path.length - 1);\n      }\n    }\n    else {\n      path = '/';\n    }\n\n    return path;\n  },\n\n  /**\n   * Extract query parameters, dealing with bare parameters and parameters with\n   * no value as appropriate:\n   *\n   * 'var1&var2=value' is not necessarily the same as 'var1=&var2=value'\n   *\n   * In my world, one is an assertion of presence, and the other is an empty\n   * variable. Some web frameworks behave this way as well, so don't lose\n   * information.\n   *\n   * @param {string} requestURL The URL to be parsed.\n   * @returns {object} The parameters parsed from the request\n   */\n  parseParameters : function parseParameters(requestURL) {\n    var parsed     = url.parse(requestURL, true)\n      , parameters = {}\n      ;\n\n    if (parsed.search !== '') {\n      Object.keys(parsed.query).forEach(function cb_forEach(key) {\n        if (parsed.query[key] === '' && parsed.path.indexOf(key + '=') < 0) {\n          parameters[key] = true;\n        }\n        else {\n          parameters[key] = parsed.query[key];\n        }\n      });\n    }\n\n    return parameters;\n  },\n\n  /**\n   * Copy a set of request parameters from one object to another, following\n   * a few important rules:\n   *\n   * 1. Do not copy a parameter if it's in config.ignored_params.\n   * 2. Do not overwrite any existing parameters in dest, including parameters\n   *    set to null or undefined.\n   *\n   * @param {Config} config      Configuration, where `ignored_params` is\n   *                             guaranteed to be an Array.\n   * @param {object} source      Parameters to be copied (not changed).\n   * @param {object} destination Dictionary to which parameters are copied\n   *                             (mutated in place).\n   */\n  copyParameters : function copyParameters(config, source, destination) {\n    if (!(config && config.capture_params && source && destination)) return;\n\n    var keys = Object.keys(source);\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      if (config.ignored_params.indexOf(key) === -1 && !(key in destination)) {\n        destination[key] = source[key];\n      }\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/feature_flags.js":"'use strict';\n\n// unreleased flags gating an active feature\nexports.prerelease = {\n  proxy: true,\n  custom_instrumentation: true\n};\n\n// flags that are no longer used for released features\nexports.released = [\n  'released',\n  'express4',\n  'insights',\n];\n\n// flags that are no longer used for unreleased features\nexports.unreleased = [\n  'unreleased'\n];\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/metrics.js":"'use strict';\n\nvar path       = require('path')\n  , Stats      = require(path.join(__dirname, 'stats.js'))\n  , ApdexStats = require(path.join(__dirname, 'stats', 'apdex.js'))\n  ;\n\n/*\n *\n * CONSTANTS\n *\n */\nvar FROM_MILLIS = 1e-3;\n\n/**\n * A metric is a set of aggregated data (summary statistics) associated with a\n * metric name. Some metrics belong to scopes, which are typically the name of\n * a transaction or a background task. This class is a collection of mappings\n * from names (or scopes and names) to data, as well as functions for\n * manipulating those data directly. It also can produce a serialized\n * representation suitable for stringifying into JSON and sending to the\n * collector.\n *\n * There are several metrics collections in existence at any given time. Each\n * agent has one metrics collection, which is created at the beginning of each\n * harvest cycle. Each new transaction also gets its own metrics collection,\n * which is merged into the agent's metrics when the transaction is finalized.\n * This allows each set of metrics to be added to the harvest cycle atomically,\n * which guarantees that each transaction will not have its metrics split\n * across multiple harvest cycles. If delivery to the collector fails, the\n * metrics collection associated with the failed delivery can be merged back\n * into the metrics collection for the ongoing harvest cycle.  Finally, if so\n * configured, the agent will have an internal set of supportability metrics\n * that can be used to report information about the operation of the agent.\n *\n * Metrics can be remapped, which is a process by which they are assigned a\n * short, numerical ID by OneAPM. This can shrink the serialized JSON\n * considerably. The mapping from transaction name (and scope) happens only\n * at serialization time, which allows the mappings from name to ID to happen\n * on the fly.\n *\n * @param {Number} apdexT The apdex-tolerating value, for use in creating apdex\n *                        statistics.\n * @param {MetricMapper} mapper The mapper that turns metric names into IDs.\n */\nfunction Metrics(apdexT, mapper, normalizer) {\n  if (apdexT === undefined || apdexT === null || apdexT === '') {\n    throw new Error(\"metrics must be created with apdexT\");\n  }\n  if (!mapper) throw new Error(\"metrics must be created with a mapper\");\n  if (!normalizer) throw new Error(\"metrics must be created with a name normalizer\");\n\n  this.started    = Date.now();\n  this.apdexT     = apdexT;\n  this.mapper     = mapper;\n  this.normalizer = normalizer;\n  this.unscoped   = {}; // {name : stats} where unscoped stats is put\n  this.scoped     = {}; // {scope : {name : stats}}\n}\n\n/**\n * This is the preferred way for interacting with metrics. Set the duration\n * (and optionally the amount of that duration that was exclusive to that\n * particular metric and not any child operations to that metric) of an\n * operation. If there are no data for the name (and optional scope) existing,\n * the collection will create a set of data before recording the measurement.\n *\n * @param {string} name The name of the metric.\n * @param {string} scope (Optional) The scope to which the metric belongs.\n * @param {Number} duration The duration of the related operation, in milliseconds.\n * @param {Number} exclusive (Optional) The portion of the operation specific to this\n *                           metric.\n * @return {Stats} The aggregated data related to this metric.\n */\nMetrics.prototype.measureMilliseconds = function measureMilliseconds(name, scope, duration, exclusive) {\n  var stats = this.getOrCreateMetric(name, scope);\n  stats.recordValueInMillis(duration, exclusive);\n  return stats;\n};\n\n/**\n * Set the size of an operation. If there are no data for the name existing,\n * the collection will create a set of data before recording the measurement.\n *\n * @param {string} name The name of the metric.\n * @param {Number} size The size of the related operation, in bytes.\n * @return {Stats} The aggregated data related to this metric.\n */\nMetrics.prototype.measureBytes = function measureBytes(name, size) {\n  var stats = this.getOrCreateMetric(name);\n  stats.recordValueInBytes(size);\n  return stats;\n};\n\n/**\n * Look up the mapping from a name (and optionally a scope) to a set of metric\n * data for that name, creating the data if they don't already exist.\n *\n * @param {string} name The name of the requested metric.\n * @param {string} scope (Optional) The scope to which the metric is bound.\n * @return {Stats} The aggregated data for that name.\n */\nMetrics.prototype.getOrCreateMetric = function getOrCreateMetric(name, scope) {\n  if (!name) throw new Error('Metrics must be named');\n\n  var resolved = this._resolve(scope);\n  if (!resolved[name]) resolved[name] = new Stats();\n  return resolved[name];\n};\n\n/**\n * Look up the mapping from a name (and optionally a scope) to a set of metric\n * apdex data for that name, creating the data if they don't already exist.\n *\n * @param {string} name          The name of the requested metric.\n * @param {string} scope         The scope to which the metric is bound\n *                               (optional).\n * @param {number} overrideApdex A custom apdexT for this metric, in\n *                               milliseconds. This will be the same for\n *                               a given run, because key transaction metrics\n *                               are set at connect time via server-side\n *                               configuration.\n *\n * @return {ApdexStats} The aggregated data for that name.\n */\nMetrics.prototype.getOrCreateApdexMetric = function getOrCreateApdexMetric(name, scope, overrideApdex) {\n  if (!name) throw new Error('Metrics must be named');\n\n  var resolved = this._resolve(scope)\n    , apdexT   = overrideApdex > 0 ? (overrideApdex * FROM_MILLIS) : this.apdexT\n    ;\n\n  if (!resolved[name]) resolved[name] = new ApdexStats(apdexT);\n  return resolved[name];\n};\n\n/**\n * Look up a metric, and don't create it if it doesn't exist. Can create scopes\n * as a byproduct, but this function is only intended for use in testing, so\n * it's not a big deal.\n *\n * @param {string} name Metric name.\n * @param {string} scope (Optional) The scope, if any, to which the metric\n *                       belongs.\n * @return {object} Either a stats aggregate, an apdex stats aggregate, or\n *                  undefined.\n */\nMetrics.prototype.getMetric = function getMetric(name, scope) {\n  if (!name) throw new Error('Metrics must be named');\n\n  return this._resolve(scope)[name];\n};\n\n/**\n * Convert this collection into a representation suitable for serialization\n * by JSON.stringify and delivery to the collector. Hope you like nested\n * arrays!\n *\n * @return {Object} Set of nested arrays containing metric information.\n */\nMetrics.prototype.toJSON = function toJSON() {\n  return this._toUnscopedData().concat(this._toScopedData());\n};\n\n/**\n * Combine two sets of metric data. Intended to be used as described above,\n * either when folding a transaction's metrics into the agent's metrics for\n * later harvest, or one harvest cycle's metrics into the next when a\n * delivery attempt to the collector fails. Among the more performance-\n * critical pieces of code in the agent, so some performance tuning would\n * probably be a good idea.\n *\n * @param {Metrics} other The collection to be folded into this one.\n */\nMetrics.prototype.merge = function merge(other) {\n  this.started = Math.min(this.started, other.started);\n\n  Object.keys(other.unscoped).forEach(function cb_forEach(name) {\n    if (this.unscoped[name]) {\n      this.unscoped[name].merge(other.unscoped[name]);\n    }\n    else {\n      this.unscoped[name] = other.unscoped[name];\n    }\n  }, this);\n\n  Object.keys(other.scoped).forEach(function cb_forEach(scope) {\n    Object.keys(other.scoped[scope]).forEach(function cb_forEach(name) {\n      if (other.scoped[scope][name]) {\n        var resolved = this._resolve(scope);\n        if (resolved[name]) {\n          resolved[name].merge(other.scoped[scope][name]);\n        }\n        else {\n          resolved[name] = other.scoped[scope][name];\n        }\n      }\n    }, this);\n  }, this);\n};\n\n/**\n * Look up the metric namespace belonging to a scope, creating it if it doesn't\n * already exist.\n *\n * @param {string} scope (Optional) The scope to look up.\n * @return {object} The namespace associated with the provided scope, or the\n *                  unscoped metrics if the scope isn't set.\n */\nMetrics.prototype._resolve = function _resolve(scope) {\n  var resolved;\n\n  if (scope) {\n    if (!this.scoped[scope]) this.scoped[scope] = {};\n\n    resolved = this.scoped[scope];\n  }\n  else {\n    resolved = this.unscoped;\n  }\n\n  return resolved;\n};\n\n/**\n * Map a metric to its nested-array representation, applying any name -> ID\n * mappings along the way. Split from _getScopedData for performance.\n *\n * @param {string} name The string to look up.\n */\nMetrics.prototype._getUnscopedData = function _getUnscopedData(name) {\n  if (!this.unscoped[name]) return;\n\n  var normalized = this.normalizer.normalize(name);\n  if (!normalized) return;\n\n  return [this.mapper.map(normalized), this.unscoped[name]];\n};\n\n/**\n * Map a metric to its nested-array representation, applying any name -> ID\n * mappings along the way. Split from _getUnscopedData for performance.\n *\n * @param {string} name The string to look up.\n */\nMetrics.prototype._getScopedData = function _getScopedData(name, scope) {\n  if (!this.scoped[scope][name]) return;\n\n  var normalized = this.normalizer.normalize(name);\n  if (!normalized) return;\n\n  return [this.mapper.map(normalized, scope), this.scoped[scope][name]];\n};\n\n/**\n * @return {object} A serializable version of the unscoped metrics. Intended\n *                  for use by toJSON.\n */\nMetrics.prototype._toUnscopedData = function _toUnscopedData() {\n  var metricData = [];\n\n  Object.keys(this.unscoped).forEach(function cb_forEach(name) {\n    var data = this._getUnscopedData(name);\n    if (data) metricData.push(data);\n  }, this);\n\n  return metricData;\n};\n\n/**\n * @return {object} A serializable version of the scoped metrics. Intended for\n *                  use by toJSON.\n */\nMetrics.prototype._toScopedData = function _toScopedData() {\n  var metricData = [];\n\n  Object.keys(this.scoped).forEach(function cb_forEach(scope) {\n    Object.keys(this.scoped[scope]).forEach(function cb_forEach(name) {\n      var data = this._getScopedData(name, scope);\n      if (data) metricData.push(data);\n    }, this);\n  }, this);\n\n  return metricData;\n};\n\nmodule.exports = Metrics;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/stats.js":"'use strict';\n\n/*\n *\n * CONSTANTS\n *\n */\nvar BYTES_PER_MB = 1024 * 1024;\nvar FROM_MILLIS  = 1e-3;\n\n\n/**\n * Simple container for tracking running statistics for a metric.\n */\nfunction Stats() {\n  this.total = 0;\n  this.totalExclusive = 0;\n  this.min = 0;\n  this.max = 0;\n  this.sumOfSquares = 0;\n  this.callCount = 0;\n}\n\n/**\n * Update the summary statistics with a new value.\n *\n * @param {Number} totalTime Time, in seconds, of the measurement.\n * @param {Number} exclusiveTime Time that was taken by only the\n *                               current measurement (optional).\n */\nStats.prototype.recordValue = function recordValue(totalTime, exclusiveTime) {\n  // even if a caller messes up, don't break everything else\n  if (totalTime !== 0 && !totalTime) totalTime = 0;\n  if (exclusiveTime !== 0 && !exclusiveTime) exclusiveTime = totalTime;\n\n  if (this.callCount > 0) {\n    this.min = Math.min(totalTime, this.min);\n  }\n  else {\n    this.min = totalTime;\n  }\n  this.max = Math.max(totalTime, this.max);\n\n  this.sumOfSquares   += (totalTime * totalTime);\n  this.callCount      += 1;\n  this.total          += totalTime;\n  this.totalExclusive += exclusiveTime;\n};\n\n/**\n * Until the collector accepts statistics in milliseconds, this code is going\n * to have some hinky floating-point values to deal with.\n */\nStats.prototype.recordValueInMillis = function recordValueInMillis(totalTime, exclusiveTime) {\n  this.recordValue(totalTime * FROM_MILLIS,\n                   exclusiveTime >= 0 ? exclusiveTime * FROM_MILLIS : null);\n};\n\n/**\n * Really?\n *\n * FIXME: Really?\n */\nStats.prototype.recordValueInBytes = function recordValueInBytes(bytes, exclusiveBytes) {\n  exclusiveBytes = exclusiveBytes || bytes;\n  this.recordValue(bytes / BYTES_PER_MB, exclusiveBytes / BYTES_PER_MB);\n};\n\nStats.prototype.incrementCallCount = function incrementCallCount(count) {\n  if (typeof count === 'undefined') count = 1;\n  this.callCount += count;\n};\n\n/**\n * Fold another summary's statistics into this one.\n */\nStats.prototype.merge = function merge(other) {\n  if (other.callCount > 0) {\n    if (this.callCount > 0) {\n      this.min = Math.min(this.min, other.min);\n    }\n    else {\n      this.min = other.min;\n    }\n  }\n  this.max = Math.max(this.max, other.max);\n\n  this.total          += other.total;\n  this.totalExclusive += other.totalExclusive;\n  this.sumOfSquares   += other.sumOfSquares;\n  this.callCount      += other.callCount;\n};\n\n/**\n * The serializer relies upon this representation, so don't change the\n * values, cardinality, or ordering of this array without ensuring that\n * it matches the version of the \"protocol\" being sent to the collector.\n *\n * @returns {Array} Number of calls,\n *                  total time in seconds,\n *                  time for this metric alone in seconds,\n *                  shortest individual time in seconds,\n *                  longest individual time in seconds,\n *                  running sum of squares.\n */\nStats.prototype.toJSON = function toJSON() {\n  return [\n    this.callCount,\n    this.total,\n    this.totalExclusive,\n    this.min,\n    this.max,\n    this.sumOfSquares\n  ];\n};\n\nmodule.exports = Stats;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/stats/apdex.js":"'use strict';\n\n/*\n *\n * CONSTANTS\n *\n */\nvar FROM_MILLIS = 1e-3;\n\n\nfunction ApdexStats(apdexT) {\n  if (!apdexT && apdexT !== 0) {\n    throw new Error('Apdex summary must be created with apdexT.');\n  }\n  this.apdexT = apdexT;\n\n  this.satisfying = 0;\n  this.tolerating = 0;\n  this.frustrating = 0;\n}\n\nApdexStats.prototype.recordValue = function recordValue(time) {\n  if (time <= this.apdexT) {\n    this.satisfying++;\n  }\n  else if (time <= 4 * this.apdexT) {\n    this.tolerating++;\n  }\n  else {\n    this.frustrating++;\n  }\n};\n\nApdexStats.prototype.recordValueInMillis = function recordValueInMillis(timeInMillis) {\n  this.recordValue(timeInMillis * FROM_MILLIS);\n};\n\n/**\n * Used by the error handler to indicate that a user was frustrated by a page\n * error.\n */\nApdexStats.prototype.incrementFrustrating = function incrementFrustrating() {\n  this.frustrating++;\n};\n\n/**\n * When merging apdex stastics, the apdex tolerating value isn't brought along\n * for the ride.\n *\n * @param {ApdexStats} other The existing apdex stats being merged in.\n */\nApdexStats.prototype.merge = function merge(other) {\n  this.satisfying  += other.satisfying;\n  this.tolerating  += other.tolerating;\n  this.frustrating += other.frustrating;\n};\n\n/**\n * This feels dirty: ApdexStats override the ordinary statistics serialization\n * format by putting satisfying, tolerating and frustrating values in the\n * first three fields in the array and setting the next two to the apdex (used\n * by calculations inside RPM), followed by 0.\n *\n * @returns {Array} A six-value array where only the first three values are\n *                  significant: satisfying, tolerating, and frustrating\n *                  load times, respectively.\n */\nApdexStats.prototype.toJSON = function toJSON() {\n  return [\n    this.satisfying,\n    this.tolerating,\n    this.frustrating,\n    this.apdexT,\n    this.apdexT,\n    0\n  ];\n};\n\nmodule.exports = ApdexStats;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/reservoir.js":"// from http://en.wikipedia.org/wiki/Reservoir_sampling\n\nfunction Reservoir() {\n  this.limit = 10;\n  this._size = 0;\n  this._data = [];\n\n  this.Random = Math.random;\n  this.Floor  = Math.floor;\n}\n\nReservoir.prototype.overflow = function overflow() {\n  var diff = this._size - this.limit;\n  return diff >= 0 ? diff : 0;\n};\n\nReservoir.prototype.add = function add(item) {\n  var k = this.limit;\n  var i = this._size ++;\n\n  if (i < k) {\n    this._data.push(item);\n  } else {\n    var j = this.Floor(this.Random() * (i + 2));\n    if (j < k) this._data[j] = item;\n  }\n\n};\n\nReservoir.prototype.toArray = function toArray() {\n  return this._data;\n};\n\nmodule.exports = Reservoir;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/sampler.js":"'use strict';\n\nvar path = require('path');\nvar NAMES = require(path.join(__dirname, 'metrics', 'names'));\nvar Timer = require(path.join(__dirname, 'timer'));\n\n\nvar samplers = [];\n\nfunction Sampler(sampler, interval) {\n  this.id = setInterval(sampler, interval);\n  // timer.unref only in 0.9+\n  // unrefed Timeout/Interval will not prevent the program from exiting\n  if (this.id.unref) {\n    this.id.unref();\n  }\n}\n\nSampler.prototype.stop = function stop() {\n  clearInterval(this.id);\n};\n\nfunction recordQueueTime(agent, timer) {\n\n  timer.end();\n  agent.metrics.measureMilliseconds(NAMES.EVENTS.WAIT, null, timer.getDurationInMillis());\n}\n\n/**\n * @since 1.2.2\n */\nfunction sampleCPU(agent) {\n  var pidusage = require('pidusage-fork');\n  return function CPUSampler() {\n    //result is {cpu:percentage ...}\n    pidusage.stat(process.pid, function (err, result) {\n      if (err) {\n\n      } else {\n        var stats = agent.metrics.getOrCreateMetric(NAMES.CPU.USERUtilization);\n        stats.recordValue(result.cpu / 100);\n      }\n    });\n  };\n}\n\nfunction sampleMemory(agent) {\n  return function memorySampler() {\n    var mem = process.memoryUsage();\n    agent.metrics.measureBytes(NAMES.MEMORY.PHYSICAL, mem.rss);\n  };\n}\n\nfunction checkEvents(agent) {\n  return function eventSampler() {\n    var timer = new Timer();\n    timer.begin();\n    setTimeout(recordQueueTime.bind(null, agent, timer), 0);\n  };\n}\n\nvar sampler = {\n  state: 'stopped',\n\n  sampleMemory: sampleMemory,\n  checkEvents: checkEvents,\n  sampleCPU: sampleCPU,\n\n  start: function start(agent) {\n    samplers.push(new Sampler(sampleCPU(agent), 5e3));\n    samplers.push(new Sampler(sampleMemory(agent), 5e3));\n    samplers.push(new Sampler(checkEvents(agent), 15e3));\n    sampler.state = 'running';\n  },\n\n  stop: function stop() {\n    samplers.forEach(function cb_forEach(sampler) {\n      sampler.stop();\n    });\n    samplers = [];\n    sampler.state = 'stopped';\n  }\n};\n\nmodule.exports = sampler;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/metrics/names.js":"'use strict';\n\nvar ERRORS = {\n  PREFIX : 'Errors/',\n  ALL    : 'Errors/all',\n  WEB    : 'Errors/allWeb',\n  OTHER    : 'Errors/allOther'\n};\n\nvar EVENTS = {\n  WAIT : 'Events/wait'\n};\n\nvar MEMORY = {\n  PHYSICAL : 'Memory/Used'\n};\n\nvar CPU = {\n  USERUtilization    :  'CPU/User/Utilization'\n}\n\nvar VIEW = {\n  PREFIX : 'View/',\n  RENDER : '/Rendering'\n};\n\nvar DATASTORE = {\n  PREFIX    : 'Datastore/',\n  STATEMENT : 'Datastore/statement',\n  OPERATION : 'Datastore/operation',\n  INSTANCE  : 'Datastore/instance',\n  ALL       : 'Datastore/all',\n  WEB       : 'Datastore/allWeb',\n  OTHER     : 'Datastore/allOther'\n};\n\nvar DB = {\n  PREFIX    : 'Database/',\n  STATEMENT : 'Database/statement',\n  OPERATION : 'Database/operation',\n  INSTANCE  : 'Database/instance',\n  ALL       : 'Database/all',\n  WEB       : 'Database/allWeb',\n  OTHER     : 'Database/allOther'\n};\n\nvar EXTERNAL = {\n  PREFIX : 'External/',\n  ALL    : 'External/all',\n  WEB    : 'External/allWeb',\n  THRIFT : 'External/allThrift',\n  OTHER  : 'External/allOther'\n};\n\nvar MEMCACHE = {\n  PREFIX    : 'Memcached',\n  OPERATION : DATASTORE.OPERATION + '/Memcached/',\n  INSTANCE  : DATASTORE.INSTANCE  + '/Memcached/'\n};\n\nvar MONGODB = {\n  PREFIX    : 'MongoDB',\n  STATEMENT : DATASTORE.STATEMENT + '/MongoDB/',\n  OPERATION : DATASTORE.OPERATION + '/MongoDB/',\n  INSTANCE  : DATASTORE.INSTANCE  + '/MongoDB/'\n};\n\nvar MYSQL = {\n  PREFIX    : 'MySQL',\n  STATEMENT : DB.STATEMENT + '/MySQL/',\n  OPERATION : DB.OPERATION + '/MySQL/',\n  INSTANCE  : DB.INSTANCE  + '/MySQL/'\n};\n\nvar MYSQL2 = {\n  PREFIX    : 'MySQL2',\n  STATEMENT : DB.STATEMENT + '/MySQL2/',\n  OPERATION : DB.OPERATION + '/MySQL2/',\n  INSTANCE  : DB.INSTANCE  + '/MySQL2/'\n};\n\nvar POSTGRES = {\n  PREFIX    : 'Postgres',\n  STATEMENT : DB.STATEMENT + '/Postgres/',\n  OPERATION : DB.OPERATION + '/Postgres/',\n  INSTANCE  : DB.INSTANCE  + '/Postgres/'\n};\n\nvar REDIS = {\n  PREFIX    : 'Redis',\n  OPERATION : DATASTORE.OPERATION + '/Redis/',\n  INSTANCE  : DATASTORE.INSTANCE  + '/Redis/'\n};\n\nvar THRIFT = {\n  PREFIX    : 'Thrift'\n};\n\nvar CASSANDRA = {\n  PREFIX    : 'Cassandra',\n  OPERATION : DATASTORE.OPERATION + '/Cassandra/',\n  INSTANCE  : DATASTORE.INSTANCE  + '/Cassandra/'\n};\n\nvar EXPRESS = {\n  PREFIX : 'Expressjs/'\n};\n\nvar RESTIFY = {\n  PREFIX : 'Restify/'\n};\n\nvar HAPI = {\n  PREFIX : 'Hapi/'\n};\n\nvar THINKJS = {\n    PREFIX : 'Thinkjs'\n};\n\nmodule.exports = {\n  URI              : 'Uri',\n  NORMALIZED       : 'NormalizedUri',\n  APDEX            : 'Apdex',\n  WEB              : 'WebTransaction',\n  HTTP             : 'HttpDispatcher',\n  CONTROLLER       : 'Controller',\n  CUSTOM           : 'Custom',\n  SUPPORTABILITY   : 'Supportability/',\n  QUEUETIME        : 'WebFrontend/QueueTime',\n  ERRORS           : ERRORS,\n  EVENTS           : EVENTS,\n  CPU              : CPU,\n  MEMORY           : MEMORY,\n  VIEW             : VIEW,\n  DB               : DB,\n  DATASTORE        : DATASTORE,\n  EXTERNAL         : EXTERNAL,\n  MEMCACHE         : MEMCACHE,\n  MONGODB          : MONGODB,\n  MYSQL            : MYSQL,\n  MYSQL2           : MYSQL2,\n  POSTGRES         : POSTGRES,\n  CASSANDRA        : CASSANDRA,\n  REDIS            : REDIS,\n  THRIFT           : THRIFT,\n  EXPRESS          : EXPRESS,\n  RESTIFY          : RESTIFY,\n  HAPI             : HAPI,\n  THINKJS       :THINKJS, \n  ACTION_DELIMITER : '/'\n};\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/timer.js":"'use strict';\n\n/**\n * Explicit enumeration of the states a transaction can be in:\n *\n * PENDING upon instantiation (implicitly, no start time set)\n * RUNNING while timer is running (implicitly, start time is set but no stop\n *   time is set).\n * STOPPED timer has been completeted (implicitly, start time and stop time\n *   are set, but the timer has not yet been harvested).\n * DEAD timer has been harvested and can only have its duration read.\n */\nvar PENDING = 1\n  , RUNNING = 2\n  , STOPPED = 3\n  ;\n\nfunction hrToMillis(hr) {\n  // process.hrTime gives you [second, nanosecond] duration pairs\n  return (hr[0] * 1e3) + (hr[1] / 1e6);\n}\n\n/**\n * A mildly tricksy timer that tracks its own state and allows its duration\n * to be set manually.\n */\nfunction Timer() {\n  this.state = PENDING;\n}\n\n/**\n * Start measuring time elapsed.\n *\n * Uses process.hrtime if available, Date.now() otherwise.\n */\nTimer.prototype.begin = function begin() {\n  if (this.state > PENDING) return;\n\n  this.start = Date.now();\n  // need to put a guard on this for compatibility with Node < 0.8\n  if (process.hrtime) this.hrstart = process.hrtime();\n  this.state = RUNNING;\n};\n\n/**\n * End measurement.\n */\nTimer.prototype.end = function end() {\n  if (this.state > RUNNING) return;\n\n  if (process.hrtime) this.hrDuration = process.hrtime(this.hrstart);\n  this.duration = Date.now() - this.start;\n  this.state = STOPPED;\n};\n\n/**\n * Update the duration of the timer without ending it..\n */\nTimer.prototype.touch = function touch() {\n  if (this.state > RUNNING) return;\n\n  if (process.hrtime) this.hrDuration = process.hrtime(this.hrstart);\n  this.duration = Date.now() - this.start;\n};\n\n/**\n * @return {bool} Is this timer currently running?\n */\nTimer.prototype.isRunning = function isRunning() {\n  return this.state === RUNNING;\n};\n\n/**\n * @return {bool} Is this timer still alive?\n */\nTimer.prototype.isActive = function isActive() {\n  return this.state < STOPPED;\n};\n\n/**\n * When testing, it's convenient to be able to control time. Stops the timer\n * as a byproduct.\n *\n * @param {number} duration How long the timer ran.\n * @param {number} start When the timer started running (optional).\n */\nTimer.prototype.setDurationInMillis = function setDurationInMillis(duration, start) {\n  if (this.state > RUNNING) return;\n  this.state = STOPPED;\n\n  this.durationInMillis = duration;\n  if (start || start === 0) {\n    this.hrstart = [Math.floor(start / 1e3), start * 1e6];\n    this.start = start;\n  }\n};\n\n/**\n * Returns how long the timer has been running (if it's still running) or\n * how long it ran (if it's been ended or touched).\n */\nTimer.prototype.getDurationInMillis = function getDurationInMillis() {\n  if (this.state === PENDING) return 0;\n\n  // only set by setDurationInMilis\n  if (this.durationInMillis >= 0) return this.durationInMillis;\n\n  // prioritize .end() and .touch()\n  if (this.hrDuration) {\n    return hrToMillis(this.hrDuration);\n  }\n  else if (this.duration) {\n    return this.duration;\n  }\n  // fall back to time elapsed since start\n  else if (process.hrtime) {\n    return hrToMillis(process.hrtime(this.hrstart));\n  }\n  else {\n    return Date.now() - this.start;\n  }\n};\n\n/**\n * Get a single object containing the interval this timer was active.\n *\n * @return {Array} 2-tuple of start time in milliseconds, end time in\n *                 milliseconds.\n */\nTimer.prototype.toRange = function toRange() {\n  return [this.start, this.start + this.getDurationInMillis()];\n};\n\n/**\n * Abstract away the nonsense related to having both an\n * hrtime start time and a regular one, and always return\n * milliseconds since start.\n *\n * @param {Timer} other The point relative to which this timer started.\n * @return {number} The offset in (floating-point) milliseconds.\n */\nTimer.prototype.startedRelativeTo = function startedRelativeTo(other) {\n  if (this.hrstart && other.hrstart && process.hrtime) {\n    var s  = this.hrstart[0] - other.hrstart[0]\n      , ns = this.hrstart[1] - other.hrstart[1]\n      ;\n\n    return hrToMillis([s, ns]);\n  }\n  else {\n    return this.start - other.start;\n  }\n};\n\nmodule.exports = Timer;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/shimmer.js":"'use strict';\n\nvar path   = require('path');\nvar logger = require('oneapm-logger').child({component : 'shimmer'});\n\n/*\n *\n * CONSTANTS\n *\n */\nvar CORE_INSTRUMENTATION = {http  : 'http.js', https : 'http.js'};\nvar INSTRUMENTATION      = [\n  'connect',\n  'express',\n  'generic-pool',\n  'hapi',\n  'thinkjs',\n  'memcached',\n  'mongodb',\n  'mysql',\n  'mysql2',\n  'pg',\n  'node-cassandra-cql',\n  'redis',\n  'thrift',\n  'restify' ];\n\n/**\n * Unwrapping is only likely to be used by test code, and is a fairly drastic\n * maneuver, but it should be pretty safe if there's a desire to reboot the\n * agent in flight.\n *\n * All of the wrapped methods are tracked in this variable and used by unwrapAll\n * below.\n */\nvar instrumented = [];\n\n/**\n * All instrumentation files must export the same interface: a single\n * initialization function that takes the agent and the module to be\n * instrumented.\n */\nfunction instrument(agent, shortName, fileName, nodule) {\n  try {\n    require(fileName)(agent, nodule);\n  }\n  catch (error) {\n    logger.debug(error, \"Failed to instrument module %s.\",\n                 path.basename(shortName, \".js\"));\n  }\n}\n\nfunction _postLoad(agent, nodule, name) {\n  var base = path.basename(name);\n\n  // necessary to prevent instrument() from causing an infinite loop\n  if (INSTRUMENTATION.indexOf(base) !== -1) {\n    logger.trace('Instrumenting %s.', base);\n    var filename = path.join(__dirname, 'instrumentation', base + '.js');\n    instrument(agent, base, filename, nodule);\n  }\n\n  return nodule;\n}\n\nvar shimmer = module.exports = {\n  /**\n   * If debug isn't false, the agent will retain references to wrapped methods\n   * for the entire lifetime of the agent. Some instrumentation depends on\n   * wrapping functions on individual objects, and this will cause the agent\n   * to retain references to a large number of dead objects.\n   */\n  debug : false,\n\n  /**\n   * Don't throw, but do log and bail out if wrapping fails.\n   *\n   * Provide an escape hatch by creating a closure around the original method\n   * and object / module wrapped into a helper function that will restore the\n   * original function / method. See Sinon for a systematic use of this\n   * pattern.\n   *\n   * @param {object} nodule Class or module containing the function to wrap.\n   * @param {object} noduleName Human-readable module / Class name. More\n   *                            helpful than you'd think.\n   * @param {string} methods One or more names of methods or functions to extract\n   *                         and wrap.\n   * @param {function} wrapper A generator that, when called, returns a\n   *                           wrapped version of the original function.\n   */\n  wrapMethod : function wrapMethod(nodule, noduleName, methods, wrapper) {\n    if (!methods) {\n      return logger.warn(new Error(),\n                         \"Must include a method name to wrap. Called from:\");\n    }\n\n    if (!noduleName) noduleName = '[unknown]';\n    if (!Array.isArray(methods)) methods = [methods];\n\n    methods.forEach(function cb_forEach(method) {\n      var fqmn = noduleName + '.' + method;\n\n      if (!nodule) return logger.debug(\"Can't wrap %s from nonexistent object.\",\n                                       fqmn);\n      if (!wrapper) return logger.debug(\"Can't wrap %s without a wrapper generator.\",\n                                        fqmn);\n\n      var original = nodule[method];\n\n      if (!original) return logger.trace(\"%s not defined, so not wrapping.\", fqmn);\n      if (original.__NR_unwrap) return logger.debug(\"%s already wrapped by agent.\", fqmn);\n\n      var wrapped = wrapper(original);\n      wrapped.__NR_original = original;\n      wrapped.__NR_unwrap = function __NR_unwrap() {\n        nodule[method] = original;\n        logger.trace(\"Removed instrumentation from %s.\", fqmn);\n      };\n\n      nodule[method] = wrapped;\n      if (shimmer.debug) instrumented.push(wrapped);\n      logger.trace(\"Instrumented %s.\", fqmn);\n    });\n  },\n\n  /**\n   * Sometimes you gotta do some crazy stuff to get the job done. Instead of using\n   * regular monkeypatching, wrapDeprecated allows you to pass in a getter and setter\n   * and then uses defineProperty to replace the original property with an\n   * accessor. Note that responsibility for unwrapping is not handled by this\n   * function.\n   *\n   * @param {object}   nodule     Class or module containing the property to\n   *                              wrap.\n   * @param {object}   noduleName Human-readable module / Class name. More\n   *                              helpful than you'd think.\n   * @param {string}   property   The property to replace with the accessor.\n   * @param {function} options    Optional getter and setter to use for the accessor.\n   *\n   * @returns {object} The original value of the property.\n   */\n  wrapDeprecated : function wrapDeprecated(nodule, noduleName, property, options) {\n    if (!property) {\n      logger.warn(new Error(), \"Must include a function name to wrap. Called from:\");\n      return;\n    }\n\n    if (!noduleName) noduleName = '[unknown]';\n\n    var fqmn = noduleName + '.' + property;\n    if (!nodule) {\n      logger.debug(\"Can't wrap %s from nonexistent object.\", fqmn);\n      return;\n    }\n\n    var original = nodule[property];\n    if (!original) {\n      logger.trace(\"%s not defined, so not wrapping.\", fqmn);\n      return;\n    }\n\n    delete nodule[property];\n\n    var descriptor = {\n      configurable : true,\n      enumerable : true,\n    };\n    if (options.get) descriptor.get = options.get;\n    if (options.set) descriptor.set = options.set;\n    Object.defineProperty(nodule, property, descriptor);\n    logger.trace(\"Instrumented %s.\", fqmn);\n\n    return original;\n  },\n\n  unwrapMethod : function unwrapMethod(nodule, noduleName, method) {\n    if (!noduleName) noduleName = '[unknown]';\n    if (!method) return logger.debug(\"Must include a method name to unwrap. \" +\n                                     \"Called from: %s\", new Error().stack);\n\n    var fqmn = noduleName + '.' + method;\n\n    if (!nodule) return logger.debug(\"Can't unwrap %s from nonexistent object.\",\n                                     fqmn);\n    var wrapped = nodule[method];\n\n    // keep instrumented up to date\n    var pos = instrumented.indexOf(wrapped);\n    if (pos !== -1) instrumented.splice(pos, 1);\n\n    if (!wrapped) return logger.debug(\"%s not defined, so not unwrapping.\", fqmn);\n    if (!wrapped.__NR_unwrap) return logger.debug(\"%s isn't unwrappable.\", fqmn);\n\n    wrapped.__NR_unwrap();\n  },\n\n  unwrapAll : function unwrapAll() {\n    instrumented.forEach(function cb_forEach(wrapper) {\n      wrapper.__NR_unwrap();\n    });\n    instrumented = [];\n  },\n\n  /**\n   * Patch the module.load function so that we see modules loading and\n   * have an opportunity to patch them with instrumentation.\n   */\n  patchModule : function patchModule(agent) {\n    logger.trace(\"Wrapping module loader.\");\n    var Module = require('module');\n\n    shimmer.wrapMethod(Module, 'Module', '_load', function cb_wrapMethod(load) {\n      return function cls_wrapMethod(file) {\n        return _postLoad(agent, load.apply(this, arguments), file);\n      };\n    });\n  },\n\n  unpatchModule : function unpatchModule() {\n    logger.trace(\"Unwrapping to previous module loader.\");\n    var Module = require('module');\n\n    shimmer.unwrapMethod(Module, 'Module', '_load');\n  },\n\n  bootstrapInstrumentation : function bootstrapInstrumentation(agent) {\n    Object.keys(CORE_INSTRUMENTATION).forEach(function cb_forEach(mojule) {\n      var filename = CORE_INSTRUMENTATION[mojule]\n        , filepath = path.join(__dirname, 'instrumentation', 'core', filename)\n        ;\n\n      instrument(agent, filename, filepath, require(mojule));\n    });\n  },\n\n  /**\n   * NOT FOR USE IN PRODUCTION CODE\n   *\n   * If an instrumented module has a dependency on another instrumented module,\n   * and multiple tests are being run in a single test suite with their own\n   * setup and teardown between tests, it's possible transitive dependencies\n   * will be unwrapped in the module cache in-place (which needs to happen to\n   * prevent stale closures from channeling instrumentation data to incorrect\n   * agents, but which means the transitive dependencies won't get rewrapped\n   * the next time the parent module is required).\n   *\n   * Since this only applies in test code, it's not worth the drastic\n   * monkeypatching to Module necessary to walk the list of child modules and\n   * rewrap them.\n   *\n   * Use this to re-apply any applicable instrumentation.\n   */\n  reinstrument : function reinstrument(agent, path) {\n    return _postLoad(agent, require(path), path);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/transaction.js":"'use strict';\n\nvar path         = require('path')\n  , urltils      = require(path.join(__dirname, 'util', 'urltils.js'))\n  , Metrics      = require(path.join(__dirname, 'metrics.js'))\n  , Timer        = require(path.join(__dirname, 'timer.js'))\n  , Trace        = require(path.join(__dirname, 'transaction', 'trace.js'))\n  , NAMES        = require(path.join(__dirname, 'metrics', 'names.js'))\n  , generateGuid = require(path.join(__dirname, 'util', 'generate-guid.js'))\n  ;\n\n/**\n * Simplifies development and debugging, not passed to collector\n */\nvar id = 1337;\n\n\n/**\n * Bundle together the metrics and the trace segment for a single agent\n * transaction.\n *\n * @param {Object} agent The agent.\n */\nfunction Transaction(agent) {\n  if (!agent) throw new Error('every transaction must be bound to the agent');\n\n  this.agent = agent;\n  this.metrics = new Metrics(\n    agent.config.apdex_t,\n    agent.mapper,\n    agent.metricNameNormalizer\n  );\n\n  this.id = id++;\n  this.exceptions = [];\n  this.timer = new Timer();\n  this.timer.begin();\n\n  this._recorders  = [];\n\n  // hidden class optimization\n  this.url         = null;\n  this.fullUrl     = null;\n  this.name        = null;\n  this.partialName = null;\n  this.statusCode  = null;\n  this.error       = null;\n  this.verb        = null;\n  this.trace       = null;\n  this.forceIgnore = null;\n  this.ignore      = false;\n  this.queueTime   = 0;\n\n  // analytic event context\n  this.guid = generateGuid();\n  this.force_trace = false;\n  this.referer_guid = null;\n  this.trip_guid = this.guid;\n  this.bytesRead = 0;\n  this.bytesWritten = 0;\n}\n\n/**\n * Return the associated transaction trace, creating it if necessary.\n */\nTransaction.prototype.getTrace = function getTrace() {\n  if (!this.trace) this.trace = new Trace(this);\n\n  return this.trace;\n};\n\n/**\n * Add a clear API method for determining whether a transaction is web or\n * background.\n *\n * @returns {boolean} Whether this transaction has a URL.\n */\nTransaction.prototype.isWeb = function isWeb() {\n  return this.url ? true : false;\n};\n\n/**\n * @return {bool} Is this transaction still alive?\n */\nTransaction.prototype.isActive = function isActive() {\n  return this.timer.isActive();\n};\n\n/**\n * Close out the current transaction and its associated trace. Remove any\n * instances of this transaction annotated onto the call stack.\n */\nTransaction.prototype.end = function end() {\n  if (!this.timer.isActive()) return;\n\n  this.timer.end();\n  if (this.trace) this.trace.end();\n\n  this.agent.emit('transactionFinished', this);\n};\n\nTransaction.prototype.applyUserNamingRules = function applyUserNamingRules(requestUrl) {\n  // 1. user normalization rules (set in configuration)\n  var normalizer = this.agent.userNormalizer;\n  if (normalizer.isIgnored(requestUrl)) this.ignore = true;\n  // User rules take precedence over the API and router introspection.\n  // Only override names set via API if rules match.\n  if (normalizer.isNormalized(requestUrl)) {\n    this.partialName = NAMES.NORMALIZED + normalizer.normalize(requestUrl);\n  }\n};\n\n/**\n * Sets the name of this transaction, figuring out along the way whether the\n * transaction should be ignored. Should run as late in the transaction's\n * lifetime as possible.\n *\n * Works entirely via side effects.\n *\n * @param {string} requestURL The URL to extract the name from.\n * @param {string} statusCode The HTTP status code from the response.\n */\nTransaction.prototype.setName = function setName(requestURL, statusCode) {\n  var normalizer;\n\n  this.url = urltils.scrub(requestURL);\n  this.statusCode = statusCode;\n\n  // 1. user normalization rules (set in configuration)\n  this.applyUserNamingRules(this.url);\n\n  // 2. URL normalization rules (sent by server)\n  normalizer = this.agent.urlNormalizer;\n  if (normalizer.isIgnored(this.url)) this.ignore = true;\n  /* Nothing has already set a name for this transaction, so normalize and\n   * potentially apply the URL backstop now. Only do so if no user rules\n   * matched.\n   */\n  if (!this.partialName) this.partialName = normalizer.normalize(this.url);\n\n  // 3. transaction name normalization rules (sent by server)\n  normalizer = this.agent.transactionNameNormalizer;\n  var fullName = NAMES.WEB + '/' + this.partialName;\n  if (normalizer.isIgnored(fullName)) this.ignore = true;\n  // Always applied.\n  this.name = normalizer.normalize(fullName);\n\n  // Allow the API to explicitly set the ignored status.\n  if (this.forceIgnore === true || this.forceIgnore === false) {\n    this.ignore = this.forceIgnore;\n  }\n};\n\n/**\n * Measure the duration of an operation named by a metric, optionally\n * belonging to a scope.\n *\n * @param {string} name The name of the metric to gather.\n * @param {string} scope (optional) Scope to which the metric is bound.\n * @param {number} duration The time taken by the operation, in milliseconds.\n * @param {number} exclusive The time exclusively taken by an operation, and\n *                           not its children.\n */\nTransaction.prototype.measure = function measure(name, scope, duration, exclusive) {\n  this.metrics.measureMilliseconds(name, scope, duration, exclusive);\n};\n\n/**\n * Based on the status code and the duration of a web transaction, either\n * mark the transaction as frustrating, or record its time for apdex purposes.\n *\n * @param {string} name     Metric name.\n * @param {number} duration Duration of the transaction, in milliseconds.\n * @param {number} keyApdex A key transaction apdexT, in milliseconds\n *                          (optional).\n */\nTransaction.prototype._setApdex = function _setApdex(name, duration, keyApdexInMillis) {\n  var apdexStats = this.metrics.getOrCreateApdexMetric(name, null, keyApdexInMillis);\n  if (urltils.isError(this.agent.config, this.statusCode)) {\n    apdexStats.incrementFrustrating();\n  }\n  else {\n    apdexStats.recordValueInMillis(duration);\n  }\n};\n\n\n/**\n * The instrumentation associates metrics with the different kinds of trace\n * segments. The metrics recorders are dependent on the transaction name to\n * collect their scoped metrics, and so must wait for the transaction's\n * name to be finalized before the recording process. Segments are only\n * responsible for their own life cycle, so responsibility for understanding\n * when the transaction name has been finalized is handed off to the trace,\n * which for now defers running these recorders until the trace is ended.\n *\n * @param {Function} recorder The callback which records metrics. Takes a\n *                            single parameter, which is the transaction's\n *                            name.\n */\nTransaction.prototype.addRecorder = function addRecorder(recorder) {\n  this._recorders.push(recorder)\n}\n\n/**\n * Run the metrics recorders for this trace. If the transaction's name /\n * scope hasn't been set yet, the recorder will be passed an undefined name,\n * and should be written to handle this.\n */\nTransaction.prototype.record = function record() {\n  var name = this.name\n  for (var i = 0, l = this._recorders.length; i < l; ++i) {\n    this._recorders[i](name)\n  }\n}\n\n\n\n\nmodule.exports = Transaction;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/transaction/trace.js":"'use strict';\n\nvar path    = require('path')\n  , codec   = require(path.join(__dirname, '..', 'util', 'codec'))\n  , Segment = require(path.join(__dirname, 'trace', 'segment'))\n  ;\n\n/*\n *\n * CONSTANTS\n *\n */\nvar FROM_MILLIS = 1e-3;\n\n/**\n * A Trace holds the root of the Segment graph and preoduces the final\n * serialization of the transaction trace.\n *\n * @param {Transaction} transaction The transaction bound to the trace.\n */\nfunction Trace(transaction) {\n  if (!transaction) throw new Error('All traces must be associated with a transaction.');\n\n  this.transaction = transaction;\n  this.recorders = [];\n\n  this.root = new Segment(this, 'ROOT');\n\n  this.custom = {};\n\n  // hidden class optimization\n  this.parameters = {};\n  this.domain     = null;\n}\n\n/**\n * End and close the current trace. Triggers metric recording for trace\n * segments that support recording.\n */\nTrace.prototype.end = function end() {\n  this.root.end();\n  this.record();\n};\n\n/**\n * The instrumentation associates metrics with the different kinds of trace\n * segments. The metrics recorders are dependent on the transaction name to\n * collect their scoped metrics, and so must wait for the transaction's\n * name to be finalized before the recording process. Segments are only\n * responsible for their own life cycle, so responsibility for understanding\n * when the transaction name has been finalized is handed off to the trace,\n * which for now defers running these recorders until the trace is ended.\n *\n * @param {Function} recorder The callback which records metrics. Takes a\n *                            single parameter, which is the transaction's\n *                            name.\n */\nTrace.prototype.addRecorder = function addRecorder(recorder) {\n  this.recorders.push(recorder);\n};\n\n/**\n * Run the metrics recorders for this trace. If the transaction's name /\n * scope hasn't been set yet, the recorder will be passed an undefined name,\n * and should be written to handle this.\n */\nTrace.prototype.record = function record() {\n  var name = this.transaction.name;\n  this.recorders.forEach(function cb_forEach(recorder) { recorder(name); }.bind(this));\n};\n\n/**\n * Add a child to the list of segments.\n *\n * @param {string} childName Name for the new segment.\n * @returns {Segment} Newly-created Segment.\n */\nTrace.prototype.add = function add(childName, callback) {\n  return this.root.add(childName, callback);\n};\n\n/**\n * Explicitly set a trace's runtime instead of using it as a stopwatch.\n * (As a byproduct, stops the timer.)\n *\n * @param {int} duration Duration of this particular trace.\n * @param {int} startTimeInMillis (optional) Start of this trace.\n */\nTrace.prototype.setDurationInMillis = function setDurationInMillis(duration, startTimeInMillis) {\n  this.root.setDurationInMillis(duration, startTimeInMillis);\n};\n\n/**\n * @return {integer} The amount of time the trace took, in milliseconds.\n */\nTrace.prototype.getDurationInMillis = function getDurationInMillis() {\n  return this.root.getDurationInMillis();\n};\n\n/**\n * The duration of the transaction trace tree that only this level accounts\n * for.\n *\n * @return {integer} The amount of time the trace took, minus any child\n *                   traces, in milliseconds.\n */\nTrace.prototype.getExclusiveDurationInMillis = function getExclusiveDurationInMillis() {\n  return this.root.getExclusiveDurationInMillis();\n};\n\n/**\n * The serializer is asynchronous, so serialization is as well.\n *\n * The transaction trace sent to the collector is a nested set of arrays. The\n * outermost array has the following fields, in order:\n *\n * 0: start time of the trace, in milliseconds\n * 1: duration, in milliseconds\n * 2: the path, or root metric name\n * 3: the URL (fragment) for this trace\n * 4: an array of segment arrays, deflated and then base64 encoded\n * 5: FIXME: the guid for this transaction, used to correlate across\n *    transactions (for now, to correlate with RUM sessions)\n * 6: reserved for future use, specified to be null for now\n * 7: FIXME: RUM2 force persist flag\n *\n * In addition, there is a \"root node\" (not the same as the first child, which\n * is a node with the special name ROOT and contents otherwise identical to the\n * top-level segment of the actual trace) with the following fields:\n *\n * 0: start time IN SECONDS\n * 1: a dictionary containing request parameters\n * 2: a dictionary containing custom parameters (currently not user-modifiable)\n * 3: the transaction trace segments (including the aforementioned root node)\n * 4: FIXME: a dictionary containing \"parameter groups\" with special information\n *    related to this trace\n *\n * @param {Function} callback Called after serialization with either\n *                            an error (in the first parameter) or\n *                            the serialized transaction trace.\n */\nTrace.prototype.generateJSON = function generateJSON(callback) {\n  var rootNode = [\n    this.root.timer.start * FROM_MILLIS,\n    {}, // moved to agentAttributes\n    {\n      // hint to RPM for how to display this trace's segments\n      // nr_flatten_leading: false\n    }, // moved to userAttributes\n    this.root.toJSON(),\n    {\n      agentAttributes : this.parameters,\n      userAttributes  : this.custom,\n      intrinsics      : {}\n    },\n    []  // FIXME: parameter groups\n  ];\n\n  var trace = this;\n  codec.encode(rootNode, function cb_encode(err, encoded) {\n    if (err) return callback(err, null, null);\n\n    var json = [\n      trace.root.timer.start,\n      trace.getDurationInMillis(),\n      trace.transaction.name,\n      trace.transaction.url,\n      encoded,\n      '',   // FIXME: RUM\n      null, // NOTE: reserved for future use\n      false // FIXME: RUM2\n    ];\n\n    return callback(null, json, trace);\n  });\n};\n\nmodule.exports = Trace;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/util/codec.js":"'use strict';\n\nvar zlib = require('zlib');\n\nmodule.exports = {\n  /**\n   * zlib works with streams, so this must be used asynchronously.\n   *\n   * Take in an object literal, and deflate and then Base64 encode it.\n   *\n   * @param {string} params The parameters object.\n   * @param {Function} callback The callback to take the results.\n   *                            The first parameter is any errors\n   *                            from decoding, and the second\n   *                            parameter is the encoded parameters\n   *                            object.\n   */\n  encode : function encode(data, callback) {\n    zlib.deflate(JSON.stringify(data), function cb_deflate(err, raw) {\n      if (err) return callback(err);\n\n      return callback(null, raw.toString('base64'));\n    });\n  },\n\n  /**\n   * zlib works with streams, so this must be used asynchronously.\n   *\n   * Base64 decode a string, decompress it, and then turn the\n   * results back into a JavaScript object.\n   *\n   * @param {string} encoded The encoded data.\n   * @param {Function} callback The callback to take the results,\n   *                            1st parameter is any errors from\n   *                            decoding, 2nd parameter is the\n   *                            decoded data object.\n   */\n  decode : function decode(encoded, callback) {\n    zlib.inflate(new Buffer(encoded, 'base64'), function cb_inflate(err, raw) {\n      if (err) return callback(err);\n\n      try {\n        return callback(null, JSON.parse(raw));\n      }\n      catch (error) {\n        return callback(error);\n      }\n    });\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/transaction/trace/segment.js":"'use strict';\n\nvar path        = require('path')\n  , util        = require('util')\n  , urltils     = require(path.join(__dirname, '..', '..', 'util', 'urltils.js'))\n  , sumChildren = require(path.join(__dirname, '..', '..', 'util', 'sum-children'))\n  , Timer       = require(path.join(__dirname, '..', '..', 'timer'))\n  ;\n\n/**\n * TraceSegments are inserted to track instrumented function calls. Each one is\n * bound to a trace, given a name (used only internally to the framework\n * for now), and has one or more children (that are also part of the same\n * trace), as well as an associated timer.\n *\n * @param {Trace} trace The transaction trace to which this segment will be\n *                      bound.\n * @param {string} name Human-readable name for this segment (e.g. 'http',\n *                      'net', 'express', 'mysql', etc).\n * @param {Function} recorder Callback that takes a segment and a scope name\n *                            as parameters (intended to be used to record\n *                            metrics related to the segment).\n */\nfunction TraceSegment(trace, name, recorder) {\n  if (!trace) throw new Error('Trace segments must be bound to a transaction trace.');\n  if (!name) throw new Error('Trace segments must be named.');\n\n  this.trace = trace;\n  this.name = name;\n\n  if (recorder) this.trace.addRecorder(recorder.bind(null, this));\n\n  this.parameters = {nr_exclusive_duration_millis : null};\n  this.children = [];\n\n  this.timer = new Timer();\n  this.timer.begin();\n\n  // hidden class optimization\n  this.partialName = null;\n  this._exclusiveDuration = null;\n  this.host = null;\n  this.port = null;\n}\n\n/**\n * Once a transaction is named, the web segment also needs to be updated to\n * match it (which implies this method must be called subsequent to\n * transaction.setName). To properly name apdex metrics during metric\n * recording, it's also necessary to copy the transaction's partial name. And\n * finally, marking the trace segment as being a web segment copies the\n * segment's parameters onto the transaction.\n *\n * @param {string} rawURL The URL, as it came in, for parameter extraction.\n */\nTraceSegment.prototype.markAsWeb = function markAsWeb(rawURL) {\n  var transaction = this.trace.transaction;\n\n  // transaction name and web segment name must match\n  this.name = transaction.name;\n  // partialName is used to name apdex metrics when recording\n  this.partialName = transaction.partialName;\n\n  var config = this.trace.transaction.agent.config;\n\n  // Copy params object so we can modify it before applying it\n  // multiple params places. It eventually runs through copyParameters\n  // so I'm not worried about `ignored_params` or `capture_params`.\n  var params = util._extend({}, this.parameters);\n\n  // This shouldn't be moved from the segment to the trace, so remove it.\n  delete params.nr_exclusive_duration_millis;\n\n  // Because we are assured we have the URL here, lets grab query params. Same\n  // as above, about to be run through copyParameters, so opt for the faster\n  // object merge/copy.\n  util._extend(params, urltils.parseParameters(rawURL));\n\n  urltils.copyParameters(config, params, this.parameters);\n  urltils.copyParameters(config, params, this.trace.parameters);\n\n};\n\n/**\n * A segment attached to something evented (such as a database\n * cursor) just finished an action, so set the timer to mark\n * the timer as having a stop time.\n */\nTraceSegment.prototype.touch = function touch() {\n  this.timer.touch();\n};\n\n/**\n * Stop timing the related action.\n */\nTraceSegment.prototype.end = function end() {\n  if (!this.timer.isActive()) return;\n\n  this.timer.end();\n};\n\n/**\n * Add a new segment to a scope implicitly bounded by this segment.\n *\n * @param {string} childName New human-readable name for the segment.\n * @returns {TraceSegment} New nested TraceSegment.\n */\nTraceSegment.prototype.add = function add(childName, callback) {\n  var segment = new TraceSegment(this.trace, childName, callback);\n  this.children.push(segment);\n  return segment;\n};\n\n/**\n * Set the duration of the segment explicitly.\n *\n * @param {Number} duration Duration in milliseconds.\n */\nTraceSegment.prototype.setDurationInMillis = function setDurationInMillis(duration, start) {\n  this.timer.setDurationInMillis(duration, start);\n};\n\nTraceSegment.prototype.getDurationInMillis = function getDurationInMillis() {\n  return this.timer.getDurationInMillis();\n};\n\n/**\n * Only for testing!\n *\n * @param {number} duration Miliseconds of exclusive duration.\n */\nTraceSegment.prototype._setExclusiveDurationInMillis = function _setExclusiveDurationInMillis(duration) {\n  this._exclusiveDuration = duration;\n};\n\n/**\n * The duration of the transaction trace tree that only this level accounts\n * for.\n *\n * @return {integer} The amount of time the trace took, minus any child\n *                   segments, in milliseconds.\n */\nTraceSegment.prototype.getExclusiveDurationInMillis = function getExclusiveDurationInMillis() {\n  if (this._exclusiveDuration) return this._exclusiveDuration;\n\n  var total = this.getDurationInMillis()\n    , end   = this.timer.toRange()[1]\n    ;\n\n  if (this.children.length > 0) {\n    // convert the list of start, duration pairs to start, end pairs\n    total -= sumChildren(this._getChildPairs(end));\n  }\n\n  return total;\n};\n\n/**\n * Enumerate the timings of this segment's descendents.\n *\n * @param {Number} end The end of this segment, to keep the calculated\n *                     duration from exceeding the duration of the\n *                     parent. Defaults to Infinity.\n *\n * @returns {Array} Unsorted list of [start, end] pairs, with no pair\n *                  having an end greater than the passed in end time.\n */\nTraceSegment.prototype._getChildPairs = function _getChildPairs(end) {\n  // quick optimization\n  if (this.children.length < 1) return [];\n  if (!end) end = Infinity;\n\n  var seed = this.children.map(function cb_map(segment) {\n    return segment.timer.toRange();\n  });\n\n  return this.children\n    .reduce(function cb_reduce(pairs, segment) {\n      return pairs.concat(segment._getChildPairs(end));\n    }, seed)\n    .filter(function cb_filter(pair) {\n      return pair[0] < end;\n    })\n    .map(function cb_map(pair) {\n      // FIXME: heuristically limit intervals to the end of the parent segment\n      return [pair[0], Math.min(pair[1], end)];\n    });\n};\n\n/**\n * This is perhaps the most poorly-documented element of transaction traces:\n * what do each of the segment representations look like prior to encoding?\n * Spelunking in the code for the other agents has revealed that each child\n * node is an array with the following field in the following order:\n *\n * 0: entry timestamp relative to transaction start time\n * 1: exit timestamp\n * 2: metric name\n * 3: parameters as a name -> value JSON dictionary\n * 4: any child segments\n *\n * Other agents include further fields in this. I haven't gotten to the bottom\n * of all of them (and Ruby, of course, sends marshalled Ruby object), but\n * here's what I know so far:\n *\n * in Java:\n * 5: class name\n * 6: method name\n *\n * in Python:\n * 5: a \"label\"\n *\n * FIXME: I don't know if it makes sense to add custom fields for Node. TBD\n */\nTraceSegment.prototype.toJSON = function toJSON() {\n  var start = this.timer.startedRelativeTo(this.trace.root.timer);\n  if (!this.parameters.nr_exclusive_duration_millis) {\n    this.parameters.nr_exclusive_duration_millis = this.getExclusiveDurationInMillis();\n  }\n\n  return [\n    start,\n    start + this.getDurationInMillis(),\n    this.name,\n    this.parameters,\n    this.children.map(function cb_map(child) { return child.toJSON(); }),\n    this.name,\n    this.trace.transaction.verb\n  ];\n};\n\nmodule.exports = TraceSegment;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/util/sum-children.js":"'use strict';\n\n/**\n * Given an ordered list of disjoint intervals and a new interval to fold into\n * it, determine if the new interval is a sub-interval (in which case it's\n * redundant), an overlapping interval (in which case, replace the most recent\n * interval on the list with an interval representing the union of the new and\n * last intervals), or otherwise (it's disjoint to what we already\n * have, in which case add it to the list). Meant to be used with\n * Array.reduce().\n *\n * Assumes the list being reduced is sorted by interval start time.\n *\n * @param {Array} accum  The accumulated list of reduced intervals.\n * @param {Array} newest A new pair of range start and end to compare to the\n*                        existing intervals.\n *\n * @return {Array} A list of intervals updated to include the new interval.\n */\nfunction reduceIntervals(accum, newest) {\n  if (accum && accum.length > 0) {\n    // the last interval on the list will always be the latest\n    var last = accum.slice(-1)[0];\n\n    // case 1: the new interval is a strict subset of the last interval\n    if (newest[0] >= last[0] && newest[1] <= last[1]) {\n      return accum;\n    }\n    // case 2: the start of the new interval is inside the last interval\n    else if (newest[0] >= last[0] && newest[0] <= last[1]) {\n      var heads = accum.slice(0, -1);\n      // gotta double-wrap the array I'm appending onto the end\n      return heads.concat([[last[0], newest[1]]]);\n    }\n    // case 3: the interval is disjoint\n    else {\n      return accum.concat([newest]);\n    }\n  }\n\n  // base case: wrap up the newest element to create the accumulator\n  return [newest];\n}\n\n/**\n * Reduce a list of intervals to the magnitude of the range, eliminating any\n * overlaps.\n *\n * @param {Array} pairs The list of startRange, endRange pairs to reduce.\n * @return {integer} The magnitude of the range, after all the overlaps have\n *                   been smoothed and the holes eliminated.\n */\nfunction sumChildren(pairs) {\n  // 1. sort the list of [begin, end] pairs by start time\n  var sortedPairs = pairs.sort(function cb_sort(a, b) { return a[0] - b[0]; });\n\n  // 2. reduce the list to a set of disjoint intervals\n  // I love ECMAscript 5!\n  var disjointIntervals = sortedPairs.reduce(reduceIntervals, []);\n\n  // 3. sum the durations of the intervals\n  return disjointIntervals.reduce(function cb_reduce(accum, current) {\n    return accum + (current[1] - current[0]);\n  }, 0);\n}\n\nmodule.exports = sumChildren;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/util/generate-guid.js":"function generateGuid() {\n\t// 16 chars: [a-z0-9]\n\treturn Math.random().toString(36).substr(2, 16);\n}\n\nmodule.exports = exports = generateGuid;","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/db/nosql-statement.js":"'use strict';\n\nvar path = require('path')\n  , DS   = require(path.join(__dirname, '..', 'metrics', 'names')).DATASTORE\n  ;\n\nfunction ParsedStatement(type, operation, model) {\n  this.type      = type;\n  this.operation = operation;\n  this.model     = model;\n}\n\nParsedStatement.prototype.recordMetrics = function recordMetrics(segment, scope) {\n  var duration    = segment.getDurationInMillis()\n    , exclusive   = segment.getExclusiveDurationInMillis()\n    , transaction = segment.trace.transaction\n    , type        = transaction.isWeb() ? DS.WEB : DS.OTHER\n    , operation   = DS.OPERATION + '/' + this.type + '/' + this.operation\n    , model       = DS.STATEMENT + '/' + this.type +\n                      '/' + this.model + '/' + this.operation\n    ;\n\n\n  if (scope) transaction.measure(model, scope, duration, exclusive);\n\n  transaction.measure(model,     null, duration, exclusive);\n  transaction.measure(operation, null, duration, exclusive);\n  transaction.measure(type,      null, duration, exclusive);\n  transaction.measure(DS.ALL,    null, duration, exclusive);\n\n  if (segment.port > 0) {\n    var hostname = segment.host || 'localhost'\n      , location = hostname + ':' + segment.port\n      , instance = DS.INSTANCE + '/' + this.type + '/' + location\n      ;\n\n    transaction.measure(instance, null, duration, exclusive);\n  }\n};\n\nmodule.exports = ParsedStatement;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/db/parsed-statement.js":"'use strict';\n\nvar path = require('path')\n  , DB   = require(path.join(__dirname, '..', 'metrics', 'names')).DB\n  ;\n\n/**\n *\n * @param type\n * @param operation\n * @param model\n * @param raw   : The raw sql string, like 'SELECT * FROM ....'\n */\nfunction ParsedStatement(type, operation, model, raw) {\n  this.type      = type;\n  this.operation = operation;\n  this.model     = model;\n\n  this.trace     = null;\n  this.raw       = '';\n\n  if( typeof raw === 'string' ) {\n    this.trace = new Error();\n    this.raw   = raw;\n  }\n}\n\nParsedStatement.prototype.recordMetrics = function recordMetrics(segment, scope) {\n  var duration    = segment.getDurationInMillis()\n    , exclusive   = segment.getExclusiveDurationInMillis()\n    , transaction = segment.trace.transaction\n    , type        = transaction.isWeb() ? DB.WEB : DB.OTHER\n    , operation   = DB.OPERATION + '/' + this.type + '/' + this.operation\n    , model       = DB.STATEMENT + '/' + this.type +\n                      '/' + this.model + '/' + this.operation\n    ;\n  \n  // Database/update\n  var globalOperation   = DB.PREFIX + this.operation;\n\n  if (scope) transaction.measure(model, scope, duration, exclusive);\n\n  transaction.measure(model,     null, duration, exclusive);\n  transaction.measure(operation, null, duration, exclusive);\n  transaction.measure(type,      null, duration, exclusive);\n  transaction.measure(DB.ALL,    null, duration, exclusive);\n  \n  transaction.measure(globalOperation,    null, duration, exclusive);\n\n  if (segment.port > 0) {\n    var hostname = segment.host || 'localhost'\n      , location = hostname + ':' + segment.port\n      , instance = DB.INSTANCE + '/' + this.type + '/' + location\n      ;\n\n    transaction.measure(instance, null, duration, exclusive);\n  }\n\n  if( this.raw ) { // If the ParsedStatment contains a raw SQL statement, add it to the agent's QueryTracer\n    transaction.agent.queries.addQuery( segment, this.type.toLowerCase(), this.raw, this.trace );\n  }\n};\n\nmodule.exports = ParsedStatement;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/db/parse-sql.js":"'use strict';\n\nvar path             = require('path')\n  , logger           = require('oneapm-logger')\n                         .child({component : 'parse_sql'})\n  , StatementMatcher = require(path.join(__dirname, 'statement-matcher'))\n  , ParsedStatement  = require(path.join(__dirname, 'parsed-statement'))\n  ;\n\nvar OPERATIONS      = [new StatementMatcher('select', /^\\s*select.*?\\sfrom[\\s\\[]+([^\\]\\s,)(;]*).*/gi),\n                       new StatementMatcher('update', /^\\s*update\\s+([^\\s,;]*).*/gi),\n                       new StatementMatcher('insert', /^\\s*insert(?:\\s+ignore)?\\s+into\\s+([^\\s(,;]*).*/gi),\n                       new StatementMatcher('delete', /^\\s*delete\\s+from\\s+([^\\s,(;]*).*/gi)]\n  , BAD_STATEMENT   = new ParsedStatement('unknown', 'unknown', 'unknown')\n  , COMMENT_PATTERN = /\\/\\\\*.*?\\\\*\\//\n  ;\n\nmodule.exports = function parseSql(type, sql) {\n  sql = sql.replace(COMMENT_PATTERN, '').trim();\n\n  var parsedStatement;\n  OPERATIONS.every(function cb_every(op) {\n    var ps = op.getParsedStatement(type, sql);\n    if (ps) {\n      parsedStatement = ps;\n      return false;\n    }\n    else {\n      return true;\n    }\n  });\n\n  if (parsedStatement) {\n    return parsedStatement;\n  }\n  else {\n    logger.debug(\"Unable to extract operation and model from [%s], ignoring query.\", sql);\n    return BAD_STATEMENT;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/db/statement-matcher.js":"'use strict';\n\nvar path            = require('path')\n  , ParsedStatement = require(path.join(__dirname, 'parsed-statement'))\n  ;\n\nfunction StatementMatcher(operation, operationPattern) {\n  this.operation        = operation;\n  this.operationPattern = operationPattern;\n}\n\nStatementMatcher.prototype.getParsedStatement = function getParsedStatement(type, sql) {\n  this.operationPattern.lastIndex = 0;\n\n  var match = new RegExp(\"^\\\\s*\" + this.operation, \"ig\").test(sql);\n  if (match) {\n    var queryMatch = this.operationPattern.exec(sql);\n    var model = queryMatch ? queryMatch[1] : 'unknown';\n\n    return new ParsedStatement(type, this.operation, model, sql);\n  }\n};\n\nmodule.exports = StatementMatcher;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/db/tracer.js":"'use strict'\n\nvar logger = require('oneapm-logger').child({component: 'query_tracer'})\nvar obfuscate = require('../util/sql/obfuscate')\nvar Stats = require('../stats')\nvar util = require('util')\nvar stackUtil = require('../util/stack')\nvar crypto = require('crypto')\nvar encode = require('../util/codec.js').encode\nvar path = require('path')\n\nmodule.exports = QueryTracer\n\nfunction QueryTracer(config) {\n  if (!(this instanceof QueryTracer)) {\n    return new QueryTracer(config)\n  }\n  this.samples = {}\n  this.config = config\n}\n\nQueryTracer.prototype.removeShortest = function removeShortest() {\n  var keys = Object.keys(this.samples)\n  var shortest\n\n\n  for (var i = 0, len = keys.length; i < len; ++i) {\n    var sample = this.samples[keys[i]].trace\n    if (!shortest || shortest.duration > sample.duration) {\n      shortest = sample\n    }\n  }\n\n  delete this.samples[shortest.normalized]\n}\n\nQueryTracer.prototype.merge = function merge(tracer) {\n  var keys = Object.keys(tracer.samples)\n\n  for (var i = 0, len = keys.length; i < len; ++i) {\n    if (this.samples[keys[i]]) {\n      this.samples[keys[i]].merge(tracer.samples[keys[i]])\n    } else {\n      this.samples[keys[i]] = tracer.samples[keys[i]]\n    }\n  }\n}\n\nQueryTracer.prototype.addQuery = function addQuery(segment, type, query, trace) {\n  var duration = segment.getDurationInMillis()\n\n  if (duration < this.config.transaction_tracer.explain_threshold) return\n\n  var slowQuery = new SlowQuery(segment, type, query, trace)\n\n  switch (this.config.transaction_tracer.record_sql) {\n    case 'raw':\n      logger.info('recording raw sql')\n      segment.parameters.sql = slowQuery.query\n      break\n    case 'obfuscated':\n      logger.info('recording obfuscated sql')\n      // TODO Maybe the backend server should handle the property 'sql_obfuscated', so keep it in the comment.\n      segment.parameters.sql = slowQuery.obfuscated\n      //segment.parameters.sql_obfuscated = slowQuery.obfuscated\n      break\n    default:\n      logger.info(\n        'not collecting slow-query because transaction_tracer.record_sql was set to %s',\n        this.config.transaction_tracer.record_sql\n      )\n      return\n  }\n\n  segment.parameters.backtrace = slowQuery.trace\n\n  if (!this.config.slow_sql.enabled) return\n\n  if (this.samples[slowQuery.normalized]) {\n    return this.samples[slowQuery.normalized].aggregate(slowQuery)\n  }\n\n  this.samples[slowQuery.normalized] = new QuerySample(this, slowQuery)\n\n  if (Object.keys(this.samples).length > this.config.slow_sql.max_samples) {\n    this.removeShortest()\n  }\n}\n\nQueryTracer.prototype.prepareJSON = function prepareJSON(done) {\n  var keys = Object.keys(this.samples)\n  var remaining = keys.length\n  var data = []\n\n  if (!remaining) return done(null, data)\n\n  for (var i = 0; i < keys.length; ++i) {\n    this.samples[keys[i]].prepareJSON(collect)\n  }\n\n  function collect(err, json) {\n    if (err) {\n      done(err)\n      // turn callback into a noop so it can't be called more than once\n      done = noop\n      return\n    }\n\n    data.push(json)\n    if (!--remaining) done(null, data)\n  }\n\n  function noop() {}\n}\n\nfunction QuerySample(tracer, slowQuery) {\n  Stats.call(this)\n  this.tracer = tracer\n  this.trace = slowQuery\n  this.aggregate(slowQuery)\n}\n\nutil.inherits(QuerySample, Stats)\n\nQuerySample.prototype.aggregate = function aggregate(slowQuery) {\n  this.recordValueInMillis(slowQuery.duration * 1000 )\n  if (this.trace && this.trace.duration >= slowQuery.duration) return\n  this.trace = slowQuery\n}\n\nQuerySample.prototype.merge = function merge(sample) {\n  Stats.prototype.merge.call(this, sample)\n  if (this.trace.duration < sample.trace.duration) {\n    this.trace = sample.trace\n  }\n}\n\nQuerySample.prototype.prepareJSON = function prepareJSON(done) {\n  // this.trace is actually a SlowQuery object\n  // For a TraceSegment(this.trace.segment), the transaction is stored in the TraceSegment instance's trace property.\n  var transaction = this.trace.segment.trace.transaction\n  var sample = this\n  var trace = sample.trace\n\n\n  encode(sample.getParams(), function encoded(err, data) {\n    if (err) return done(err)\n\n    done(null, [\n      transaction.name,\n      transaction.url || '<unknown>',\n      trace.id,\n      getQuery(sample.tracer.config, trace),\n      trace.metric,\n      sample.callCount,\n      sample.total,\n      sample.min,\n      sample.max,\n      data\n    ])\n  })\n}\n\nQuerySample.prototype.getParams = function getParams() {\n  return {backtrace: this.trace.trace}\n}\n\nfunction SlowQuery(segment, type, query, trace) {\n  this.obfuscated = obfuscate(query, type)\n  this.normalized = this.obfuscated.replace(/\\?\\s*,\\s*|\\s*/g, '')\n  this.id = normalizedHash(this.normalized)\n  this.segment = segment\n  this.query = query\n  this.metric = segment.name\n  this.trace = stackUtil.formatStack(trace.stack)  // trace is an Error object, for capturing the stack.\n  this.duration = segment.getDurationInMillis()\n}\n\nfunction normalizedHash(value) {\n  return parseInt(crypto.createHash('md5').update(value).digest('hex').slice(-4), 16)\n}\n\nfunction getQuery(config, trace) {\n  switch (config.transaction_tracer.record_sql) {\n    case 'raw':\n      return trace.query\n    case 'obfuscated':\n      return trace.obfuscated\n    default:\n      return '?'\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/instrumentation/connect.js":"'use strict';\n\nvar path    = require('path')\n  , shimmer = require(path.join(__dirname, '..', 'shimmer'))\n  , logger  = require('oneapm-logger').child({component : 'connect'})\n  ;\n\n/*\n *\n * CONSTANTS\n *\n */\n\nvar ORIGINAL = '__NR_original';\nvar RESERVED = [ // http://es5.github.io/#x7.6.1.2\n  // always (how would these even get here?)\n  'class', 'enum', 'extends', 'super', 'const', 'export', 'import',\n  // strict\n  'implements', 'let', 'private', 'public', 'yield', 'interface',\n  'package', 'protected', 'static'\n];\n\n/**\n * ES5 strict mode disallows some identifiers that are allowed in non-strict\n * code. Mangle function names that are on that list of keywords so they're\n * non-objectionable in strict mode (which is currently enabled everywhere\n * inside the agent, as well as at many customer sites).\n *\n * If you really need to crawl your Express app's middleware stack, change\n * your test to use name.indexOf('whatever') === 0 as the predicate instead\n * of name === 'whatever'. It's a little slower, but you shouldn't be doing\n * that anyway.\n *\n * @param {string} name The candidate function name\n *\n * @returns {string} A safe (potentially mangled) function name.\n */\nfunction mangle(name) {\n  if (RESERVED.indexOf(name) !== -1) return name + '_';\n\n  return name;\n}\n\nmodule.exports = function initialize(agent, connect) {\n  var tracer = agent.tracer;\n\n  var interceptor = {\n    route : '',\n    handle : function sentinel(error, req, res, next) {\n      if (error) {\n        var transaction = agent.tracer.getTransaction();\n        if (transaction) {\n          transaction.exceptions.push(error);\n        }\n        else {\n          agent.errors.add(null, error);\n        }\n      }\n\n      return next(error);\n    }\n  };\n\n  /**\n   * Problem:\n   *\n   * 1. Connect determines whether middleware functions are error handlers by\n   *    testing their arity. Not cool.\n   * 2. Downstream Express users rely upon being able to iterate over their\n   *    middleware stack to find specific middleware functions. Sorta less\n   *    uncool, but still a pain.\n   *\n   * Solution:\n   *\n   * Use eval. This once. For this one specific purpose. Not anywhere else for\n   * any reason.\n   */\n  function wrapHandle(handle) {\n    // jshint -W061\n    var arglist\n      , name = ''\n      ;\n\n    // reiterated: testing function arity is stupid\n    switch (handle.length) {\n      case 2:\n        arglist = '(req, res)';\n        break;\n\n      case 3:\n        arglist = '(req, res, next)';\n        break;\n\n      // don't break other error handlers\n      case 4:\n        arglist = '(err, req, res, next)';\n        break;\n\n      default:\n        arglist = '()';\n    }\n\n    if (handle.name) name = mangle(handle.name);\n\n    // leave this function anonymous\n    // it's connect madness\n    var template = function () {\n      var args = tracer.slice(arguments)\n        , last = args.length - 1\n        ;\n\n      if (typeof args[last] === 'function') {\n        args[last] = tracer.callbackProxy(args[last]);\n      }\n\n      handle.apply(this, args);\n    };\n\n    // I am a bad person and this makes me feel bad.\n    // We use eval because we need to insert the function with a specific name to allow for lookups.\n    var wrapped = eval(\n      '(function(){return function ' + name + arglist +\n      template.toString().substring(11) + '}())'\n    );\n    wrapped[ORIGINAL] = handle;\n\n    return wrapped;\n  }\n\n  function wrapUse(use) {\n    return function cls_wrapUse() {\n      if (!this.stack) return use.apply(this, arguments);\n\n      this.stack = this.stack.filter(function cb_filter(m) { return m !== interceptor; });\n\n      /* We allow `use` to go through the arguments so it can reject bad things\n       * for us so we don't have to also do argument type checking.\n       */\n      var app = use.apply(this, arguments);\n\n      // wrap most recently added unwrapped handler\n      var top = this.stack.pop();\n      if (top) {\n          if (top.handle &&\n              typeof top.handle === 'function' &&\n              !top.handle[ORIGINAL]) {\n            top.handle = wrapHandle(top.handle);\n          }\n          this.stack.push(top);\n      }\n\n      /* Give the error tracer a better chance of intercepting errors by\n       * putting it before the first error handler (a middleware that takes 4\n       * parameters, in Connect's world). Error handlers tend to be placed\n       * towards the end of the middleware chain and sometimes don't pass\n       * errors along. Don't just put the interceptor at the beginning because\n       * we want to allow as many middleware functions to execute as possible\n       * before the interceptor is run, to increase error coverage.\n       *\n       * NOTE: This is heuristic, and works because interceptor propagates\n       *       errors instead of terminating the middleware chain.\n       *       Ignores routes.\n       */\n      var spliced = false;\n      for (var i = 0; i < this.stack.length; i++) {\n        var middleware = this.stack[i];\n        // Check to see if it is an error handler middleware\n        if (middleware &&\n            middleware.handle &&\n            middleware.handle.length === 4) {\n          this.stack.splice(i, 0, interceptor);\n          spliced = true;\n          break;\n        }\n      }\n      if (!spliced) this.stack.push(interceptor);\n\n      // don't break chaining\n      return app;\n    };\n  }\n\n  /**\n   * Connect 1 and 2 are very different animals, but like Express, it mostly\n   * comes down to factoring.\n   */\n  var version = connect && connect.version && connect.version[0];\n  switch (version) {\n    case '1':\n      shimmer.wrapMethod(connect && connect.HTTPServer && connect.HTTPServer.prototype,\n                         'connect.HTTPServer.prototype',\n                         'use',\n                         wrapUse);\n      break;\n\n    case '2':\n      shimmer.wrapMethod(connect && connect.proto,\n                         'connect.proto',\n                         'use',\n                         wrapUse);\n      break;\n\n    default:\n      logger.debug(\"Unrecognized version %s of Connect detected; not instrumenting.\",\n                   version);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/instrumentation/express.js":"'use strict';\n\nvar path    = require('path')\n  , shimmer = require(path.join(__dirname, '..', 'shimmer.js'))\n  , urltils = require(path.join(__dirname, '..', 'util', 'urltils.js'))\n  , logger  = require('oneapm-logger')\n                .child({component : 'express'})\n  , record  = require(path.join(__dirname, '..', 'metrics', 'recorders', 'generic.js'))\n  , NAMES   = require(path.join(__dirname, '..', 'metrics', 'names.js'))\n  , VIEW    = NAMES.VIEW\n  ;\nvar debug=require('debug')('oneapm:instrument:express');\n\nvar ORIGINAL = '__NR_original';\nvar RESERVED = [ // http://es5.github.io/#x7.6.1.2\n  // always (how would these even get here?)\n  'class', 'enum', 'extends', 'super', 'const', 'export', 'import',\n  // strict\n  'implements', 'let', 'private', 'public', 'yield', 'interface',\n  'package', 'protected', 'static'\n];\n\n/**\n * ES5 strict mode disallows some identifiers that are allowed in non-strict\n * code. Mangle function names that are on that list of keywords so they're\n * non-objectionable in strict mode (which is currently enabled everywhere\n * inside the agent, as well as at many customer sites).\n *\n * If you really need to crawl your Express app's middleware stack, change\n * your test to use name.indexOf('whatever') === 0 as the predicate instead\n * of name === 'whatever'. It's a little slower, but you shouldn't be doing\n * that anyway.\n *\n * @param {string} name The candidate function name\n *\n * @returns {string} A safe (potentially mangled) function name.\n */\nfunction mangle(name) {\n  if (RESERVED.indexOf(name) !== -1) return name + '_';\n\n  return name;\n}\n\nfunction nameFromRoute(segment, route, params) {\n  if (!segment) return logger.error(\"No OneAPM context to set Express route name on.\");\n  if (!route) return logger.debug(\"No Express route to use for naming.\");\n\n  // Express 4.3.0 changed where params live. On newer vesrions of express\n  // params should be populated, on older it shouldn't be.\n  params = params || route.params;\n\n  var transaction = segment.trace.transaction\n    , path        = route.path || route.regexp\n    ;\n    \n  if(transaction._express_routers && transaction._express_routers.length){\n    debug('get from parent routers');\n    path=transaction._express_routers.join(\"\")+path;\n  }\n  if (!path) return logger.debug({route : route}, \"No path found on Express route.\");\n\n  // when route is a regexp, route.path will be a regexp\n  if (path instanceof RegExp) path = path.source;\n\n\n  urltils.copyParameters(transaction.agent.config, params, segment.parameters);\n  \n  if(path[0]!==NAMES.ACTION_DELIMITER){\n      path=NAMES.ACTION_DELIMITER+path;\n  }\n\n  transaction.partialName = NAMES.EXPRESS.PREFIX + transaction.verb + path;\n  debug(\"transaction.partialName=\",transaction.partialName);\n}\n\nmodule.exports = function initialize(agent, express) {\n  var tracer = agent.tracer;\n\n  var interceptor;\n  // This is the error handler we inject for express4. Yanked from connect support.\n  function sentinel(error, req, res, next) {\n    if (error) {\n      var transaction = agent.tracer.getTransaction();\n      if (transaction) {\n        transaction.exceptions.push(error);\n      }\n      else {\n        agent.errors.add(null, error);\n      }\n    }\n\n    return next(error);\n  }\n\n  function setDispatcher(app) {\n    return function wrappedCreateServer() {\n      agent.environment.setDispatcher('express');\n      agent.environment.setFramework('express');\n\n      return app.apply(this, arguments);\n    };\n  }\n\n  /**\n   * This needs to be kept up to date with Express to ensure that it's using\n   * the same logic to decide where the callback is hiding.\n   */\n  function wrapRender(version, render) {\n    /*jshint maxparams:5*/ // follow Express as closely as possible\n    return function cls_wrapRender(view, options, cb, parent, sub) {\n      logger.trace(\"Rendering Express %d view %s.\", version, view);\n      if (!tracer.getTransaction()) {\n        logger.trace(\"Express %d view %s rendered outside transaction, not measuring.\",\n                     version,\n                     view);\n        return render.apply(this, arguments);\n      }\n\n      var name    = VIEW.PREFIX + view + VIEW.RENDER\n        , segment = tracer.addSegment(name, record)\n        , wrapped\n        ;\n\n      if ('function' === typeof options) {\n        cb = options;\n        options = null;\n      }\n\n      if (cb === null || cb === undefined) {\n        /* CAUTION: Need this to generate a metric, but adding a callback\n         * changes Express's control flow.\n         */\n        wrapped = tracer.callbackProxy(function syntheticCallback(err, rendered) {\n          if (err) {\n            segment.end();\n            logger.trace(err,\n                         \"Express %d rendering for metric %s failed for transaction %d:\",\n                         version,\n                         name,\n                         segment.trace.transaction.id);\n\n            return this.req.next(err);\n          }\n\n          var returned = this.send(rendered);\n          segment.end();\n\n          logger.trace(\"Rendered Express %d view with metric %s for transaction %d.\",\n                       version,\n                       name,\n                       segment.trace.transaction.id);\n\n          return returned;\n        }.bind(this));\n      }\n      else {\n        wrapped = tracer.callbackProxy(function renderWrapper() {\n          var returned = cb.apply(this, arguments);\n          segment.end();\n\n          return returned;\n        });\n      }\n\n      return render.call(this, view, options, wrapped, parent, sub);\n    };\n  }\n\n  function wrapMatchRequest(version, matchRequest) {\n    return function cls_wrapMatchRequest() {\n      if (!tracer.getTransaction()) {\n        logger.trace(\"Express %d router called outside transaction.\", version);\n        return matchRequest.apply(this, arguments);\n      }\n      var route = matchRequest.apply(this, arguments);\n      nameFromRoute(tracer.getSegment(), route);\n      return route;\n    };\n  }\n\n  function wrapProcessParams(version, process_params) {\n    return function cls_wrapProcessParams() {\n      var transaction=tracer.getTransaction();\n      if (!transaction) {\n        logger.trace(\"Express %d router called outside transaction.\", version);\n        return process_params.apply(this, arguments);\n      }\n      if (arguments.length) {\n        // parms would be layer, called, req, res, done\n        var layer= arguments[0];\n        \n        if (!layer.route && layer.path) {\n\n            // get the handler\n            if(layer.handle && layer.handle[ORIGINAL]){\n                var eachHandler=layer.handle[ORIGINAL];\n\n                // if it is a router\n                if(eachHandler.hasOwnProperty(\"caseSensitive\")){\n                    debug(\"saving\",layer.path);\n                    transaction._express_routers=transaction._express_routers||[];\n                    transaction._express_routers.push(layer.path);\n\n                // if it is a middle ware\n                }else{\n                    debug(\"ignore\",layer.path);\n                }\n            }\n        }else if(layer.route){\n          // Express 4.3.0 changed where params live. On newer vesrions of\n          // express params should be populated, on older it shouldn't be.\n          nameFromRoute(tracer.getSegment(), layer.route, layer.params);\n        }\n      }\n      return process_params.apply(this, arguments);\n    };\n  }\n\n  /**\n   * Problem:\n   *\n   * 1. Express determines whether middleware functions are error handlers by\n   *    testing their arity. Not cool.\n   * 2. Downstream Express users rely upon being able to iterate over their\n   *    middleware stack to find specific middleware functions. Sorta less\n   *    uncool, but still a pain.\n   *\n   * Solution:\n   *\n   * Use eval. This once. For this one specific purpose. Not anywhere else for\n   * any reason.\n   */\n  function wrapHandle(handle) {\n    var arglist\n      , name = ''\n      ;\n\n    // reiterated: testing function arity is stupid\n    switch (handle.length) {\n      case 2:\n        arglist = '(req, res)';\n        break;\n\n      case 3:\n        arglist = '(req, res, next)';\n        break;\n\n      // don't break other error handlers\n      case 4:\n        arglist = '(err, req, res, next)';\n        break;\n\n      default:\n        arglist = '()';\n    }\n\n    if (handle.name) {\n      name = mangle(handle.name);\n\n      // FIX: https://github.com/cnodejs/nodeclub/issues/561\n      name = name.replace(/^bound\\s/);\n    }\n\n    var template = function () {\n      var args = tracer.slice(arguments)\n        , last = args.length - 1\n        ;\n\n      if (typeof args[last] === 'function') {\n        args[last] = tracer.callbackProxy(args[last]);\n      }\n\n      handle.apply(this, args);\n    };\n\n    // I am a bad person and this makes me feel bad.\n    // We use eval because we need to insert the function with a specific name to allow for lookups.\n    // jshint evil:true\n    var wrapped = eval(\n      '(function(){return function ' + name + arglist +\n      template.toString().substring(11) + '}())'\n    );\n    wrapped[ORIGINAL] = handle;\n    // jshint evil:false\n\n    return wrapped;\n  }\n\n  function wrapMiddlewareStack(route, use) {\n    return function cls_wrapMiddlewareStack() {\n\n      // return directly if it is mounted\n      if(this._mountpath){\n        return use.apply(this, arguments);\n      }\n\n      if (this.stack && this.stack.length) {\n        // Remove our custom error handler.\n        this.stack = this.stack.filter(function cb_filter(m) { return m !== interceptor; });\n      }\n      if (!interceptor) {\n        // call use to create a Layer object, then pop it off and store it.\n        use.call(this, '/', sentinel);\n        interceptor = this.stack.pop();\n      }\n\n      /* We allow `use` to go through the arguments so it can reject bad things\n       * for us so we don't have to also do argument type checking.\n       */\n      var app = use.apply(this, arguments);\n\n      /* Express adds routes to the same stack as middlewares. We need to wrap\n       * that adder too but we only want to wrap the middlewares that are\n       * added, not the Router.\n       */\n      if (!route) {\n        // wrap most recently added unwrapped handler\n        var top = this.stack[this.stack.length-1];\n        if (top) {\n            if (top.handle &&\n                typeof top.handle === 'function' &&\n                !top.handle[ORIGINAL]) {\n              top.handle = wrapHandle(top.handle);\n            }\n        }\n      }\n\n      /* Give the error tracer a better chance of intercepting errors by\n       * putting it before the first error handler (a middleware that takes 4\n       * parameters, in express's world). Error handlers tend to be placed\n       * towards the end of the middleware chain and sometimes don't pass\n       * errors along. Don't just put the interceptor at the beginning because\n       * we want to allow as many middleware functions to execute as possible\n       * before the interceptor is run, to increase error coverage.\n       *\n       * NOTE: This is heuristic, and works because interceptor propagates\n       *       errors instead of terminating the middleware chain.\n       *       Ignores routes.\n       */\n      var spliced = false;\n      for (var i = 0; i < this.stack.length; i++) {\n        var middleware = this.stack[i];\n        // Check to see if it is an error handler middleware\n        if (middleware &&\n            middleware.handle &&\n            middleware.handle.length === 4) {\n          this.stack.splice(i, 0, interceptor);\n          spliced = true;\n          break;\n        }\n      }\n      if (!spliced) this.stack.push(interceptor);\n\n      if(process.env.ONEAPM_DEMO){\n        console.log(\"MiddleWare Stack:\",this.stack.map(function(func,i){\n          return (1+i)+\"-\"+func.name+func.handle.length;\n        }).join('\\t'));\n      }\n\n      // don't break chaining\n      return app;\n    };\n  }\n\n  /**\n   * Major versions of express have very different factoring,\n   * even though the core instrumentation is the same.\n   */\n  var version = express && express.version && express.version[0];\n\n  /* TJ decided he didn't want to deal with the hassle of updating a\n   * version field. Thanks, TJ!\n   */\n  if (!version && express && express.application &&\n      express.application.init && express.response &&\n      express.response.render && express.Router &&\n      express.Router.prototype.matchRequest) {\n    version = '3';\n  } else if (!version && express && express.application &&\n           express.application.init && express.response &&\n           express.response.render && express.Router &&\n           express.Router.process_params) {\n    version = '4';\n  }\n\n  switch (version) {\n    case '2':\n      /* Express 2 doesn't directly expose its Router constructor, so create an\n       * app and grab the constructor off it. Do it before instrumenting\n       * createServer so the agent doesn't automatically set the dispatcher\n       * to Express.\n       */\n      var oneoff = express.createServer()\n        , Router = oneoff.routes.constructor\n        ;\n\n      shimmer.wrapMethod(express,\n                         'express',\n                         'createServer',\n                         setDispatcher);\n\n      /* Express 2 squirts its functionality directly onto http.ServerResponse,\n       * leaving no clean way to wrap its functionality without pulling in the\n       * http module ourselves.\n       */\n      var http = require('http');\n      shimmer.wrapMethod(http.ServerResponse.prototype,\n                         'http.ServerResponse.prototype',\n                         'render',\n                         wrapRender.bind(null, 2));\n\n      shimmer.wrapMethod(Router.prototype,\n                         'Router.prototype',\n                         '_match',\n                         wrapMatchRequest.bind(null, 2));\n      break;\n\n    case '3':\n      shimmer.wrapMethod(express.application,\n                         'express.application',\n                         'init',\n                         setDispatcher);\n\n      shimmer.wrapMethod(express.response,\n                         'express.response',\n                         'render',\n                         wrapRender.bind(null, 3));\n\n      shimmer.wrapMethod(express.Router.prototype,\n                         'express.Router.prototype',\n                         'matchRequest',\n                         wrapMatchRequest.bind(null, 3));\n      break;\n\n    case '4':\n      shimmer.wrapMethod(express.application,\n                         'express.application',\n                         'init',\n                         setDispatcher);\n\n      shimmer.wrapMethod(express.response,\n                         'express.response',\n                         'render',\n                         wrapRender.bind(null, 4));\n\n      shimmer.wrapMethod(express.Router,\n                         'express.Router',\n                         'process_params',\n                         wrapProcessParams.bind(null, 4));\n\n      shimmer.wrapMethod(express.Router,\n                         'express.Router',\n                         'use',\n                         wrapMiddlewareStack.bind(null, false));\n\n      shimmer.wrapMethod(express.Router,\n                         'express.Router',\n                         'route',\n                         wrapMiddlewareStack.bind(null, true));\n      break;\n    default:\n      logger.warn(\"Unrecognized version %d of Express detected; not instrumenting\",\n                  version);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/instrumentation/generic-pool.js":"'use strict';\n\nvar path    = require('path')\n  , shimmer = require(path.join(__dirname, '..', 'shimmer'))\n  ;\n\nmodule.exports = function initialize(agent, generic) {\n  shimmer.wrapMethod(generic, 'generic-pool', 'Pool', function cb_wrapMethod(Pool) {\n    return function cls_wrapMethod() {\n      var pooler = Pool.apply(this, arguments) ;\n\n      shimmer.wrapMethod(pooler, 'Pool', 'acquire', function cb_wrapMethod(acquire) {\n        return function propagateTransactionThroughPool(callback, priority) {\n          if (typeof callback === 'function') {\n            /* See adjustCallback in generic-pool.js for the motivation behind\n             * this grotesque hack. Tl;dr: depending on Function.length is evil.\n             */\n            var proxied = agent.tracer.callbackProxy(callback);\n            switch (callback.length) {\n              case 2:\n                callback = function moveAlongNothingToSeeHere(error, client) {\n                  return proxied.call(this, error, client);\n                };\n                break;\n              case 1:\n                callback = function moveAlongNothingToSeeHere(client) {\n                  return proxied.call(this, client);\n                };\n                break;\n              default:\n                callback = proxied;\n            }\n          }\n\n          return acquire.call(this, callback, priority);\n        };\n      });\n\n      return pooler;\n    };\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/instrumentation/hapi.js":"'use strict';\n\nvar path    = require('path')\n  , shimmer = require(path.join(__dirname, '..', 'shimmer.js'))\n  , urltils = require(path.join(__dirname, '..', 'util', 'urltils.js'))\n  , logger  = require('oneapm-logger')\n                .child({component : 'hapi'})\n  , record  = require(path.join(__dirname, '..', 'metrics', 'recorders', 'generic.js'))\n  , NAMES   = require(path.join(__dirname, '..', 'metrics', 'names.js'))\n  , VIEW    = NAMES.VIEW\n  ;\n\nfunction nameFromRequest(segment, request) {\n  if (!segment) return logger.error(\"No OneAPM context to set Hapi route name on.\");\n  if (!request) return logger.debug(\"No Hapi request to use for naming.\");\n\n  var transaction = segment.trace.transaction\n    , path        = request.route && request.route.path\n    ;\n\n  if (!path) return logger.debug({request : request}, \"No path found on Hapi route.\");\n\n  urltils.copyParameters(transaction.agent.config, request.params, segment.parameters);\n\n  transaction.partialName = NAMES.HAPI.PREFIX + transaction.verb +\n                            NAMES.ACTION_DELIMITER + path;\n}\n\nfunction setDispatcher(agent) {\n  agent.environment.setDispatcher('hapi');\n  agent.environment.setFramework('hapi');\n}\n\nmodule.exports = function initialize(agent, hapi) {\n  if (!agent) return logger.error(\"Hapi instrumentation bootstrapped without agent\");\n  if (!hapi) return logger.error(\"Hapi instrumentation applied without module\");\n\n  var tracer = agent.tracer;\n\n  function wrapRender(render) {\n    return function wrappedRender(filename, context, options, callback) {\n      var wrapped = callback;\n\n      // FIXME: this is going to be the most recent segment, which may not be right\n      var segment = tracer.getSegment();\n      if (segment && callback) {\n        wrapped = tracer.callbackProxy(function cb_callbackProxy() {\n          segment.end();\n\n          return callback.apply(this, arguments);\n        });\n      }\n\n      return render.call(this, filename, context, options, wrapped);\n    };\n  }\n\n  function wrapStart(start) {\n    return function wrappedStart() {\n      setDispatcher(agent);\n\n      /* The patched module loader doesn't access the filesystem itself, so\n       * lazily apply the patch to Views.prototype.render only once a Views\n       * object has been assigned as the view manager.\n       */\n      if (this._views) {\n        logger.debug('Hapi view manager set; instrumenting render.');\n        var proto = this._views.constructor.prototype;\n        shimmer.wrapMethod(proto, 'hapi.Views.prototype', 'render', wrapRender);\n      }\n\n      return start.apply(this, arguments);\n    };\n  }\n\n  function wrapViews(views) {\n    return function wrappedViews() {\n      var returned = views.apply(this, arguments);\n\n      /* The patched module loader doesn't access the filesystem itself, so\n       * lazily apply the patch to Views.prototype.render only once a Views\n       * object has been assigned as the view manager.\n       */\n      if (this._views) {\n        var proto = this._views.constructor.prototype;\n        shimmer.wrapMethod(proto, 'hapi.Views.prototype', 'render', wrapRender);\n      }\n      else {\n        logger.warn('Hapi view manager set without manager actually being created.');\n      }\n\n      return returned;\n    };\n  }\n\n  function wrapReplyView(reply) {\n    var view = reply.view;\n    reply.view = function (template) {\n      if (tracer.getTransaction()) {\n        var name = VIEW.PREFIX + template + VIEW.RENDER;\n        tracer.addSegment(name, record);\n      }\n\n      return view.apply(this, arguments);\n    };\n  }\n\n  function wrapHandler(handler) {\n    return function cls_wrapHandler(request, reply) {\n      if (!tracer.getTransaction()) {\n        logger.trace(\"Hapi route handler called outside transaction.\");\n        return handler.apply(this, arguments);\n      }\n\n      nameFromRequest(tracer.getSegment(), request);\n      if (reply && reply.view) wrapReplyView(reply);\n\n      return handler.apply(this, arguments);\n    };\n  }\n\n  function tableVisitor(before, after, vhost, visit) {\n    if (!vhost) vhost = '*';\n\n    if (after) {\n      Object.keys(after).forEach(function cb_forEach(method) {\n        var beforeHandlers = before && before[method];\n        var afterHandlers = after[method];\n        for (var i = 0; i < afterHandlers.length; i++) {\n          var route = afterHandlers[i];\n          logger.debug('Instrumented hapi route [host %s] %s %s',\n                       vhost, method, route.path);\n          if (!beforeHandlers || beforeHandlers.indexOf(route) === -1) {\n            route.settings.handler = visit(route.settings.handler);\n          }\n        }\n      });\n    }\n  }\n\n  function wrapRoute(_route) {\n    return function wrappedRoute(configs, env) {\n      var server = this;\n\n      var router = server._router;\n      if (!router) return logger.warn(\"no router found on hapi server\");\n\n      var vhosts = router.vhosts;\n      var beforeHosts;\n      if (vhosts) {\n        logger.debug(\"capturing vhosts on hapi router\");\n\n        Object.keys(vhosts).forEach(function cb_forEach(host) {\n          beforeHosts[host] = {};\n          Object.keys(vhosts[host]).forEach(function cb_forEach(method) {\n            beforeHosts[host][method] = vhosts[host][method].slice();\n          });\n        });\n      }\n\n      var symbol;\n      // hapi 2: router.table -> router.routes & router.table is a function\n      if (typeof router.table === 'function') {\n        symbol = 'routes';\n      }\n      // hapi 1: when vhosts aren't used, router.table contains the routes\n      else {\n        symbol = 'table';\n      }\n\n      var table = router[symbol];\n      var beforeTable = {};\n      if (table) {\n        Object.keys(table).forEach(function cb_forEach(method) {\n          beforeTable[method] = table[method].slice();\n        });\n      }\n\n      var returned = _route.call(this, configs, env);\n\n      vhosts = router.vhosts;\n      if (vhosts) {\n        Object.keys(vhosts).forEach(function cb_forEach(host) {\n          tableVisitor(beforeHosts[host], vhosts[host], host, wrapHandler);\n        });\n      }\n\n      table = router[symbol];\n      if (table) tableVisitor(beforeTable, table, undefined, wrapHandler);\n\n      return returned;\n    };\n  }\n\n  var proto = hapi && hapi.Server && hapi.Server.prototype;\n  if (proto) {\n    shimmer.wrapMethod(proto, 'hapi.Server.prototype', 'start',  wrapStart);\n    shimmer.wrapMethod(proto, 'hapi.Server.prototype', 'views',  wrapViews);\n    shimmer.wrapMethod(proto, 'hapi.Server.prototype', '_route', wrapRoute);\n  }\n  else {\n    logger.warn('hapi Server constructor not found; can\\'t instrument');\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/instrumentation/memcached.js":"'use strict';\n\nvar path           = require('path')\n  , shimmer        = require(path.join(__dirname, '..', 'shimmer.js'))\n  , stackUtil      = require(path.join(__dirname, '..', 'util', 'stack' ))\n  , recordMemcache = require(path.join(__dirname, '..', 'metrics',\n                                       'recorders', 'memcached.js'))\n  , MEMCACHE       = require(path.join(__dirname, '..', 'metrics', 'names.js')).MEMCACHE\n  ;\n\nfunction wrapKeys(metacall) {\n  if (metacall.key) {\n    return [metacall.key];\n  }\n  else if (metacall.multi) {\n    return metacall.command.split(' ').slice(1);\n  }\n  else {\n    return [];\n  }\n}\n\n/**\n * Thanks to Hernan Silberman!\n *\n * instrument the memcached driver to intercept calls and keep stats on them.\n */\nmodule.exports = function initialize(agent, memcached) {\n  var tracer = agent.tracer;\n\n  shimmer.wrapMethod(memcached && memcached.prototype,\n                     'memcached.prototype',\n                     'command',\n                     function cb_wrapMethod(command) {\n    return tracer.segmentProxy(function cb_segmentProxy() {\n      if (!tracer.getTransaction()) return command.apply(this, arguments);\n\n      /* The 'command' function will be called with a single function argument.\n       * That function returns a simple object describing the memcached call.\n       * Call that function to get that call description.\n       */\n      var metacall = arguments[0]()\n        , name     = MEMCACHE.OPERATION + (metacall.type || 'Unknown')\n        , segment  = tracer.addSegment(name, recordMemcache)\n        , keys     = wrapKeys(metacall)\n        ;\n\n      /* capture connection info for datastore instance metric\n       *\n       * ONLY do this if there's only one connection for the driver,\n       * because that's the only way to know for sure which shard a given\n       * key was fetched from. Heuristic and sucky, but truthful.\n       */\n      if (this.connections && Object.keys(this.connections).length === 1) {\n        var location = Object.keys(this.connections)[0].split(':');\n        segment.host = location[0];\n        segment.port = location[1];\n      }\n\n      if (agent.config.capture_params &&\n          keys.length > 0 &&\n          agent.config.ignored_params.indexOf('key') === -1) {\n        segment.parameters.key = JSON.stringify(keys);\n      }\n\n      // Add backtrace to segment.\n      var stack = (new Error()).stack; \n      segment.parameters.backtrace = stackUtil.formatStack( stack );\n\n      /* Memcached's call description includes a callback to apply when the\n       * operation is concluded. Wrap that to trace the duration of the\n       * operation.\n       */\n      shimmer.wrapMethod(metacall, 'metacall', 'callback', function cb_wrapMethod(kallback) {\n        return tracer.callbackProxy(function wrappedMemcachedCallback() {\n          var returned = kallback.apply(this, arguments);\n          segment.end();\n          return returned;\n        });\n      });\n\n      // rewrap the metacall for the command object\n      var rewrapped = function rewrapped() { return metacall; };\n\n      // finally, execute the original command\n      return command.call(this, rewrapped);\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/instrumentation/mongodb.js":"\"use strict\";\n\nvar path = require('path'),\n  ParsedStatement = require(path.join(__dirname, '..', 'db', 'nosql-statement')),\n  shimmer = require(path.join(__dirname, '..', 'shimmer')),\n  stackUtil = require(path.join(__dirname, '..', 'util', 'stack.js')),\n  urltils = require(path.join(__dirname, '..', 'util', 'urltils.js')),\n  logger = require('oneapm-logger').child({\n    component: 'mongodb'\n  }),\n  MONGODB = require(path.join(__dirname, '..', 'metrics', 'names')).MONGODB;\n\nvar INSTRUMENTED_OPERATIONS = [\n  'find',\n  'findOne',\n  'insert',\n  'insertOne',\n  'remove',\n  'removeOne',\n  'save',\n  'update',\n  'updateOne',\n  'distinct',\n  'count',\n  'findAndModify',\n  'findAndRemove',\n  'createIndex',\n  'ensureIndex',\n  'dropIndex',\n  'dropAllIndexes',\n  'reIndex'\n];\n\n/**\n * Everything uses nextObject, whether you're streaming or using callbacks.\n *\n * @param {TraceSegment} segment The current segment, to be closed when done.\n * @param {Tracer}       tracer  The current transaction trcer.\n *\n * @returns {Function} A callback that further wraps the callback called by the\n *                     wrapped nextObject method, so we can tell when the cursor\n *                     is exhausted.\n */\nfunction wrapNextObject(tracer) {\n  return function cls_wrapNextObject(nextObject) {\n    return function wrappedNextObject() {\n      if (!tracer.getTransaction()) return nextObject.apply(this, arguments);\n\n      var args = tracer.slice(arguments),\n        last = args.length - 1,\n        callback = args[last],\n        cursor = this;\n\n      if (typeof callback === 'function' && cursor.collection) {\n        args[last] = tracer.callbackProxy(function cb_callbackProxy(err, object) {\n          var collection = cursor.collection.collectionName || 'unknown',\n            remaining = cursor.items.length,\n            total = cursor.totalNumberOfRecords,\n            limit = cursor.limitValue === -1 ? 1 : cursor.limitValue,\n            returned = callback.apply(this, arguments),\n            segment = tracer.getSegment();\n\n          if (remaining === 0 && limit === total) {\n            segment.end();\n            logger.trace(\"MongoDB query trace segment ended for %s: end of batch.\",\n              collection);\n          } else if (!object) {\n            segment.end();\n            logger.trace(\"MongoDB query trace segment ended for %s: nothing to pull.\",\n              collection);\n          }\n\n          /* each time the cursor is called, update the prospective end time\n           * for the MongoDB cursor\n           */\n          segment.touch();\n\n          return returned;\n        });\n      }\n\n      return nextObject.apply(this, args);\n    };\n  };\n}\n\nfunction addMongoStatement(tracer, collection, operation) {\n  var statement = new ParsedStatement(MONGODB.PREFIX, operation, collection),\n    recorder = statement.recordMetrics.bind(statement),\n    name = MONGODB.STATEMENT + collection + '/' + operation;\n\n  return tracer.addSegment(name, recorder);\n}\n\nmodule.exports = function initialize(agent, mongodb) {\n  if (!(mongodb && mongodb.Collection && mongodb.Collection.prototype)) return;\n\n  var tracer = agent.tracer;\n\n  if (mongodb && mongodb.Cursor && mongodb.Cursor.prototype) {\n    shimmer.wrapMethod(mongodb.Cursor.prototype,\n      'mongodb.Cursor.prototype', 'nextObject', wrapNextObject(tracer));\n  }\n\n  INSTRUMENTED_OPERATIONS.forEach(function cb_forEach(operation) {\n    shimmer.wrapMethod(mongodb.Collection.prototype,\n      'mongodb.Collection.prototype', operation,\n      function cls_MONGO_OPERATION(command) {\n        return tracer.segmentProxy(function cb_segmentProxy() {\n          var collection = this.collectionName || 'unknown',\n            args = tracer.slice(arguments),\n            terms = typeof args[0] === 'function' ? undefined : args[0];\n\n          if (args.length < 1) {\n            logger.trace(\"Not tracing MongoDB %s.%s(); no command parameters.\",\n              collection, operation);\n\n            return command.apply(this, arguments);\n          } else if (!tracer.getTransaction()) {\n            logger.trace(\"Not tracing MongoDB %s.%s(); no OneAPM transaction.\",\n              collection, operation);\n            if (terms) logger.trace({\n              terms: terms\n            }, \"With terms:\");\n\n            return command.apply(this, arguments);\n          }\n\n          logger.trace(\"Tracing MongoDB %s.%s(%j).\", collection, operation, terms);\n\n          /* Don't add segments when MongoDB is calling back into itself.\n           * Mildly heuristic: MongoDB operations that self-call do so on the\n           * same tick, so if a MongoDB operation has already happened this\n           * tick (according to the tracer), then it's a self-call.\n           */\n          if (!tracer.isCurrentSegmentType(MONGODB.PREFIX)) {\n            tracer.setCurrentSegmentType(MONGODB.PREFIX);\n            var transaction = tracer.getTransaction(),\n              segment = addMongoStatement(tracer, collection, operation);\n\n            if (typeof terms === 'object') {\n              urltils.copyParameters(agent.config, terms, segment.parameters);\n            }\n\n            // capture configuration information if available\n            if (this.db && this.db.serverConfig) {\n              segment.host = this.db.serverConfig.host;\n              segment.port = this.db.serverConfig.port;\n            }\n            // Add backtrace to segment.\n            var stack = (new Error()).stack;\n            segment.parameters.backtrace = stackUtil.formatStack( stack );\n\n            var callback = args.pop();\n            if (typeof callback !== 'function') {\n              args.push(callback);\n              if (operation !== 'find'&&operation !== 'count') {\n                args.push(tracer.callbackProxy(function cb_callbackProxy() {\n                  segment.end();\n                  logger.trace(\"Tracing MongoDB %s.%s(%j) ended for transaction %s.\",\n                    collection, operation, terms, transaction.id);\n                }));\n              }\n            } else {\n              if (operation === 'find') {\n                args.push(tracer.callbackProxy(callback));\n              } else {\n                args.push(tracer.callbackProxy(function cb_callbackProxy() {\n                  var returned = callback.apply(this, arguments);\n\n                  segment.end();\n                  logger.trace(\"Tracing MongoDB %s.%s(%j) ended for transaction %s.\",\n                    collection, operation, terms, transaction.id);\n\n                  return returned;\n                }));\n              }\n            }\n          }\n\n          return command.apply(this, args);\n        });\n      });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/instrumentation/mysql2.js":"'use strict';\n\nvar path = require('path')\n  , logger = require('oneapm-logger').child({component: 'mysql'})\n  , shimmer = require(path.join(__dirname, '..', 'shimmer'))\n  , parseSql = require(path.join(__dirname, '..', 'db', 'parse-sql'))\n  , MYSQL2 = require(path.join(__dirname, '..', 'metrics', 'names')).MYSQL2\n  ;\n\nvar formatSqlString = require( 'mysql/lib/protocol/SqlString' ).format;\n\nvar RE_NAMED_PLACEHOLDERS = /(?:\\?)|(?::(\\d+|(?:[a-zA-Z][a-zA-Z0-9_]*)))/g;\n\nmodule.exports = function initialize(agent, mysql2) {\n  var tracer = agent.tracer;\n\n  // Comment the Connection class warpping, since mysql2 doesn't export it to the user( Connection is exported, while the essential ConnectionConfig is not, weird).\n  // TODO Uncomment it once mysql2 exports it completely to the user.\n  // Wrap the Connection class\n  /*\n  shimmer.wrapMethod( mysql2, 'mysql2.Connection', 'Connection', connectionWrapper );\n  function connectionWrapper( Connection ) {\n    function wrapConnection() {\n      var connection = Connection.apply( this, arguments );\n      if( connection === undefined )\n        connection = this;\n\n      shimmer.wrapMethod( connection, 'mysql2.Connection.query', 'query', queryWrapper );\n      shimmer.wrapMethod( connection, 'mysql2.Connection.query', 'execute', queryWrapper );\n\n      return connection;\n    }\n\n    return wrapConnection;\n  }\n  */\n\n  shimmer.wrapMethod( mysql2, 'mysql2', 'createConnection', createConnectionWrapper );\n  shimmer.wrapMethod( mysql2, 'mysql2', 'connect', createConnectionWrapper );\n  function createConnectionWrapper( createConnection ) {\n    function wrapCreateConnection() {\n      var connection = createConnection.apply( this, arguments );\n      shimmer.wrapMethod( connection, 'mysql2.Connection', 'query', queryWrapper );\n      shimmer.wrapMethod( connection, 'mysql2.Connection', 'execute', queryWrapper );\n      shimmer.wrapMethod( connection, 'mysql2.Connection', 'prepare', prepareWrapper );\n\n      return connection;\n    }\n    return wrapCreateConnection;\n  }\n\n\n\n  shimmer.wrapMethod(mysql2, 'mysql', 'createPool', createPoolWrapper );\n\n  // Copied from mysql instrumentation.\n  // TODO Extract the code for reusing.\n  function createPoolWrapper(createPool) {\n    return function () {\n      var pool = createPool.apply(mysql2, arguments);\n      shimmer.wrapMethod(pool, 'pool', 'getConnection', function (getConnection) {\n        return function (connectionCallback) {\n          getConnection.call(pool, tracer.callbackProxy(function (err, connection) {\n\n            if (connection && !connection.query.__NR_original) {\n              shimmer.wrapMethod(connection, 'connection', 'query', queryWrapper);\n              shimmer.wrapMethod(connection, 'connection', 'execute', queryWrapper);\n              shimmer.wrapMethod(connection, 'connection', 'prepare', prepareWrapper);\n            }\n\n            connectionCallback.call(this, err, connection);\n          }));\n        };\n      });\n\n      /* mysql2's pool just call its connection(by getConnection method) to make the query or execution, so pool wrapping is not needed.\n      shimmer.wrapMethod(pool, 'pool', 'query', queryWrapper);\n      shimmer.wrapMethod(pool, 'pool', 'execute', queryWrapper);\n      */\n\n      return pool;\n    };\n  };\n\n\n  function prepareWrapper( prepare ) {\n    return function( options, callback ) {\n      return prepare.call( this, options, tracer.callbackProxy( function( err, statement ) {\n        statement['oneapm:prepare'] = true; // Make a special mark on statment, which is used in queryWrapper.\n        shimmer.wrapMethod( statement, 'statement', 'execute', queryWrapper );\n        callback.call( this, err, statement );\n      } ) );\n    }\n  }\n\n  function queryWrapper(query) {\n    return tracer.segmentProxy(function cb_segmentProxy(sql, values, callback) {\n\n      logger.trace(\"Potentially tracing node-mysql 2 query.\");\n\n      var transaction = tracer.getTransaction();\n\n      if (!transaction || arguments.length < 1) {\n\n        if (!transaction) {\n          logger.trace(\"Return early because no active context found\");\n        }\n\n        return query.apply(this, arguments);\n      }\n\n      var actualSql, actualCallback, actualValues;\n\n      // Analyse the arguments of Connection.prototype.query().\n      // The prototype is:\n      // query( sql, values, callback).\n      //\n      // sql could be a string, or an object containing the SQL string in the property 'sql', aka:\n      // \"SELECT * FROM users WHERE uid=13\", or\n      // { sql : \"SELECT * FROM users WHERE uid=13\" }\n      // The MySQL driver also support value replacement, so the SQL string might contain place holder '?', aka:\n      // \"SELECT * FROM users WHERE uid=?\", then the values argument should contain the content to replace '?', in an array, like [13].\n      // When sql is an object, the values argument can be passed in sql.values. \n      //\n      // Actually the MySQL driver compose all the content into one object in the lower level, an object like this:\n      // { sql : \"SELECT ... ?\", values : [ 1 ] }, which is obtained in a Query instance(mysql/protocol/sequences/Query.js).\n\n      if( this['oneapm:prepare'] ) { // The arguments is just values and callback, the sql is stored in this.query('this' is a PreparedStatement instance).\n        actualSql = this.query;\n        actualValues = sql;\n        actualCallback = values;\n      }\n      else { // Not in a prepare statment.\n        if( typeof sql === 'object' || typeof sql === 'string' ) {\n          actualSql = sql;\n          if( typeof values === 'function' ) { // .query( sql, callback)\n            actualCallback = values;\n            actualValues = sql.values;\n          }\n          else { // .query( sql ) or .query( sql, null, callback ), the callback can be falsy here, since MySQL driver will handle it.\n            actualValues = values || [];\n            actualCallback = callback;\n          }\n        }\n        else { // Empty sql, the original MySQL driver will return an error(saying 'Hey, the SQL should not be empty') in the callback.\n          return query.apply( this, arguments );\n        }\n      }\n\n      // Get the real SQL string, by replacing the holder '?' with correct content, with the help of 'mysql' module.\n      var sqlStr = formatSqlString( typeof actualSql === 'object' ? actualSql.sql : actualSql, actualValues );\n\n      var ps = parseSql(MYSQL2.PREFIX, sqlStr)\n        , wrapped = tracer.callbackProxy(actualCallback)\n        , name = MYSQL2.STATEMENT + ps.model + '/' + ps.operation\n        , segment = tracer.addSegment(name, ps.recordMetrics.bind(ps))\n        ;\n\n      tracer.getTransaction().addRecorder( ps.recordMetrics.bind( ps, segment ) );\n      // capture connection info for datastore instance metric\n      if (this.config) {\n        segment.port = this.config.port;\n        segment.host = this.config.host;\n      }\n\n      logger.trace(\"Adding node-mysql 2 query trace segment on transaction %d.\",\n        transaction.id);\n\n\n      var returned;\n      if( this['oneapm:prepare'] ) { // A prepare statment's execute method just accepts the values and callback.\n        returned = query.call(this, actualValues, wrapped);\n      }\n      else {\n        returned = query.call(this, actualSql, actualValues, wrapped);\n      }\n      returned.once('end', function handle_end() {\n        segment.end();\n        logger.trace(\"node-mysql 2 query finished for transaction %d.\",\n          transaction.id);\n      });\n\n      return returned;\n    });\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/instrumentation/mysql.js":"'use strict';\n\nvar path = require('path')\n  , logger = require('oneapm-logger').child({component: 'mysql'})\n  , shimmer = require(path.join(__dirname, '..', 'shimmer'))\n  , parseSql = require(path.join(__dirname, '..', 'db', 'parse-sql'))\n  , MYSQL = require(path.join(__dirname, '..', 'metrics', 'names')).MYSQL\n  ;\n\nvar formatSqlString = require( 'mysql/lib/protocol/SqlString' ).format;\n\nmodule.exports = function initialize(agent, mysql) {\n  var tracer = agent.tracer;\n\n  function queryWrapper(query) {\n    return tracer.segmentProxy(function cb_segmentProxy(sql, values, callback) {\n\n      logger.trace(\"Potentially tracing node-mysql 2 query.\");\n\n      var transaction = tracer.getTransaction();\n\n      if (!transaction || arguments.length < 1) {\n\n        if (!transaction) {\n          logger.trace(\"Return early because no active context found\");\n        }\n\n        return query.apply(this, arguments);\n      }\n\n      var actualSql, actualCallback, actualValues;\n\n      // Analyse the arguments of Connection.prototype.query().\n      // The prototype is:\n      // query( sql, values, callback).\n      //\n      // sql could be a string, or an object containing the SQL string in the property 'sql', aka:\n      // \"SELECT * FROM users WHERE uid=13\", or\n      // { sql : \"SELECT * FROM users WHERE uid=13\" }\n      // The MySQL driver also support value replacement, so the SQL string might contain place holder '?', aka:\n      // \"SELECT * FROM users WHERE uid=?\", then the values argument should contain the content to replace '?', in an array, like [13].\n      // When sql is an object, the values argument can be passed in sql.values. \n      //\n      // Actually the MySQL driver compose all the content into one object in the lower level, an object like this:\n      // { sql : \"SELECT ... ?\", values : [ 1 ] }, which is obtained in a Query instance(mysql/protocol/sequences/Query.js).\n\n      if( typeof sql === 'object' || typeof sql === 'string' ) {\n        actualSql = sql;\n        if( typeof values === 'function' ) { // .query( sql, callback)\n          actualCallback = values;\n          actualValues = sql.values;\n        }\n        else { // .query( sql ) or .query( sql, null, callback ), the callback can be falsy here, since MySQL driver will handle it.\n          actualValues = values || [];\n          actualCallback = callback;\n        }\n      }\n      else { // Empty sql, the original MySQL driver will return an error(saying 'Hey, the SQL should not be empty') in the callback.\n        return query.apply( this, arguments );\n      }\n\n      // Get the real SQL string, by replacing the holder '?' with correct content, with the help of 'mysql' module.\n      var sqlStr = formatSqlString( typeof actualSql === 'object' ? actualSql.sql : actualSql, actualValues );\n\n      var ps = parseSql(MYSQL.PREFIX, sqlStr)\n        , wrapped = tracer.callbackProxy(actualCallback)\n        , name = MYSQL.STATEMENT + ps.model + '/' + ps.operation\n        , segment = tracer.addSegment(name, ps.recordMetrics.bind(ps))\n        ;\n\n      tracer.getTransaction().addRecorder( ps.recordMetrics.bind( ps, segment ) );\n      // capture connection info for datastore instance metric\n      if (this.config) {\n        segment.port = this.config.port;\n        segment.host = this.config.host;\n      }\n\n      logger.trace(\"Adding node-mysql 2 query trace segment on transaction %d.\",\n        transaction.id);\n      var returned = query.call(this, sql, actualValues, wrapped);\n      returned.once('end', function handle_end() {\n        segment.end();\n        logger.trace(\"node-mysql 2 query finished for transaction %d.\",\n          transaction.id);\n      });\n\n      return returned;\n    });\n  }\n\n  // FIXME: need a more general way of differentiating between driver versions\n  if (mysql && mysql.createConnection) {\n    // congratulations, you have node-mysql 2.0\n    shimmer.wrapMethod(mysql, 'mysql', 'createConnection', function cb_wrapMethod(createConnection) {\n      return tracer.segmentProxy(function cb_segmentProxy() {\n        var connection = createConnection.apply(this, arguments);\n        shimmer.wrapMethod(connection, 'connection', 'query', queryWrapper);\n        return connection;\n      });\n    });\n\n    shimmer.wrapMethod(mysql, 'mysql', 'createPool', function cb_wrapMethod(createPool) {\n      return function () {\n        var pool = createPool.apply(mysql, arguments);\n        shimmer.wrapMethod(pool, 'pool', 'getConnection', function (getConnection) {\n          return function (connectionCallback) {\n            getConnection.call(pool, tracer.callbackProxy(function (err, connection) {\n\n              if (connection && !connection.query.__NR_original) {\n                shimmer.wrapMethod(connection, 'connection', 'query', queryWrapper);\n              }\n\n              connectionCallback.call(this, err, connection);\n            }));\n          };\n        });\n\n        shimmer.wrapMethod(pool, 'pool', 'query', queryWrapper);\n\n        return pool;\n      };\n    });\n  }\n  else if (mysql && mysql.Client) {\n    // congratulations, you have node-mysql 0.9\n    shimmer.wrapMethod(mysql && mysql.Client && mysql.Client.prototype,\n      'mysql.Client.prototype',\n      'query',\n      function cb_wrapMethod(query) {\n        return tracer.segmentProxy(function cb_segmentProxy() {\n          logger.trace(\"Potentially tracing node-mysql 0.9 query.\");\n          if (!tracer.getTransaction() || arguments.length < 1) {\n            return query.apply(this, arguments);\n          }\n          var transaction = tracer.getTransaction();\n          logger.trace(\"Tracing node-mysql 0.9 query on transaction %d.\",\n            transaction.id);\n\n          var args = tracer.slice(arguments)\n            , ps = parseSql(MYSQL.PREFIX, args[0])\n            , name = MYSQL.STATEMENT + ps.model + '/' + ps.operation\n            , segment = tracer.addSegment(name, ps.recordMetrics.bind(ps))\n            ;\n\n          tracer.getTransaction().addRecorder( ps.recordMetrics.bind( ps, segment ) );\n          // capture connection info for datastore instance metric\n          segment.port = this.port;\n          segment.host = this.host;\n\n          // find and wrap the callback\n          if (args.length > 1 && typeof(args[args.length - 1]) === 'function') {\n            args[args.length - 1] = tracer.callbackProxy(args[args.length - 1]);\n          }\n\n          // FIXME: need to grab error events as well, as they're also emitted on\n          // the client\n\n          var queried = query.apply(this, args);\n          queried.once('end', function handle_end() {\n            segment.end();\n            logger.trace(\"node-mysql 0.9 query finished for transaction %d.\",\n              transaction.id);\n          });\n\n          return queried;\n        });\n      });\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/instrumentation/node-cassandra-cql.js":"'use strict';\n\nvar path        = require('path')\n  , shimmer     = require(path.join(__dirname, '..', 'shimmer'))\n  , stackUtil   = require(path.join(__dirname, '..', 'util', 'stack'))\n  , logger      = require('oneapm-logger')\n                    .child({component : 'node-cassandra-cql'})\n  , record = require(path.join(__dirname, '..', 'metrics', 'recorders', 'node-cassandra-cql.js'))\n  , CASSANDRA       = require(path.join(__dirname, '..', 'metrics', 'names')).CASSANDRA\n  ;\n\nvar INSTRUMENTED_OPERATIONS = [\n  'execute',\n  'executeAsPrepared',\n  'executeBatch'\n];\n\nmodule.exports = function initialize(agent, cassandracql) {\n  var tracer = agent.tracer;\n\n  INSTRUMENTED_OPERATIONS.forEach(function cb_forEach(operation) {\n    shimmer.wrapMethod(cassandracql && cassandracql.Client && cassandracql.Client.prototype,\n      'node-cassandra-cql.Client.prototype',\n      operation,\n      function wrapper(cmd) {\n        return tracer.segmentProxy(function wrapped() {\n          if (!tracer.getTransaction() || arguments.length < 1) {\n            logger.trace(\"Not tracing cassandra-cql command due to no transaction state.\");\n            return cmd.apply(this, arguments);\n          }\n\n          var transaction = tracer.getTransaction()\n            , args = tracer.slice(arguments)\n            , name = CASSANDRA.OPERATION + operation\n            , segment = tracer.addSegment(name, record)\n            , position = args.length - 1\n            , last = args[position]\n            ;\n\n          logger.trace(\"Adding cassandra-cql command trace segment transaction %d.\",\n            transaction.id);\n\n          // capture connection info for datastore instance metric\n          segment.port = this.port;\n          segment.host = this.host;\n\n          var stack = (new Error()).stack;\n          segment.parameters.backtrace = stackUtil.formatStack( stack );\n\n          function finalize(target) {\n            return function cls_finalize() {\n              var returned = target.apply(this, arguments);\n              segment.end();\n              logger.trace(\"cassandra-cql command trace segment ended for transaction %d.\",\n                transaction.id);\n\n              return returned;\n            };\n          }\n\n          if (typeof last === 'function') {\n            args[position] = tracer.callbackProxy(finalize(last));\n          }\n          else if (Array.isArray(last) && typeof last[last.length - 1] === 'function') {\n            var callback = finalize(last[last.length - 1]);\n            last[last.length - 1] = tracer.callbackProxy(callback);\n          }\n          else { // let's shove a callback in there for fun\n            args.push(function cb_push() {\n              segment.end();\n              logger.trace(\"cassandra-cql command trace segment ended for transaction %d.\",\n                transaction.id);\n            });\n          }\n\n          return cmd.apply(this, args);\n        });\n      });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/instrumentation/pg.js":"'use strict';\n\nvar path        = require('path')\n  , shimmer     = require(path.join(__dirname, '..', 'shimmer'))\n  , parseSql    = require(path.join(__dirname, '..', 'db', 'parse-sql'))\n  , logger      = require('oneapm-logger').child({component : 'pg'})\n  , POSTGRES    = require(path.join(__dirname, '..', 'metrics', 'names')).POSTGRES\n  ;\n\nmodule.exports = function initialize(agent, pgsql) {\n  var tracer = agent.tracer;\n  if( process.env.NODE_PG_FORCE_NATIVE ) {\n    return instrumentNativePG( 'pg', pgsql );\n  }\n\n  // Instrument native pg(without NODE_PG_FORCE_NATIVE specified, native pg is accessible through pg.native)\n\n  /* The code from pg, hoping load the 'native' property lazily(which IS a good idea since the native lib may not be installed, and most of the users won't use pg.native).\n   * Let's replace the deprecated '__lookupGetter__' method with Object.getOwnPropertyDescriptor here, since the former never becomes the standard.\n   * Object.getOwnPropertyDescriptor works with Node.JS v0.10.8 and higher.\n   *\n   * By the way, the '__defineGetter__' method cannot be replaced by Object.defineProperty with a get function,\n   * within a get function, passing pgsql.native to a function will cause 'maximum call stack size exceeded' error\n   * it makes sense, since we are calling native within its getter.\n   *\n   * While in a __defineGetter__ function, the behavior won't happen, if we refer to pgsql.native in the __defineGetter__'s code,\n   * the call stack size error occurs, but it works well if we pass pgsql.native to the instrumentNativePG function.\n   *\n   * TODO: That's weired, more digging work will be done.\n   *\n    // Code in pg module:\n    //lazy require native module...the native module may not have installed\n    module.exports.__defineGetter__(\"native\", function() {\n      delete module.exports.native;\n      module.exports.native = new PG(require('./native'));\n      return module.exports.native;\n    });\n   *\n   */\n\n  /*\n  Object.defineProperty( pgsql, 'native', {\n    get : function() {\n      var originalNative = originalNativeGetter();\n      //instrumentNativePG( 'pg.native', pgsql.native );\n      return originalNative;\n    }\n  } );\n  */\n\n  /* Alternative way using ___lookupGetter__\n  var originalNativeGetter = pgsql.__lookupGetter__( 'native' );\n  */\n  var nativeDescriptor = Object.getOwnPropertyDescriptor( pgsql, 'native' )\n  if( nativeDescriptor && nativeDescriptor.get ) {\n    var originalNativeGetter = nativeDescriptor.get;\n\n    delete pgsql.native;\n\n    pgsql.__defineGetter__( 'native', function getNative() {\n      // Don't ref the pgsql.native in the code, only pass it to the function.\n      // console.log( !!pgsql.native );\n      var originalNative = originalNativeGetter();\n      instrumentNativePG( 'pg.native', pgsql.native );\n      return originalNative;\n    } );\n\n    /* The code won't work, leave it here for further study.\n    Object.defineProperty( pgsql, 'native', {\n      get : function getNative() {\n        var originalNative = originalGetter();\n        instrumentNativePG( 'pg.native', pgsql.native ); // Just can't ref to pgsql.native even it's a function argument.\n        return originalNative; \n      }\n    } );\n    */\n  }\n  \n\n  function instrumentNativePG( name, pg ) {\n\n    shimmer.wrapMethod( pg, name, 'Client', pgClientWrapper );\n    shimmer.wrapMethod( pg.pools, name + '.pools', 'Client', pgClientWrapper );\n\n    function pgClientWrapper( PGClient ) {\n      function wrapClient () {\n        var client = PGClient.apply( this, arguments );\n        if( client === undefined ) \n          client = this;\n        // Wrap the connect and query method of the pg client instance.\n        shimmer.wrapMethod( client, 'pgclient.connect', 'connect', wrapConnect );\n        shimmer.wrapMethod( client, 'pgclient.query', 'query', wrapQuery );\n\n\n        return client;\n      }\n      wrapClient.prototype = PGClient.prototype;\n\n      return wrapClient;\n    }\n  }\n\n  // Instrument JS implementation.\n  shimmer.wrapMethod(pgsql && pgsql.Client && pgsql.Client.prototype, 'pg.Client.prototype', 'query', wrapQuery);\n  shimmer.wrapMethod(pgsql && pgsql.Client && pgsql.Client.prototype, 'pg.Client.prototype', 'connect', wrapConnect );\n\n\n  function finalize( target, segment, transaction ) {\n    return function cls_finalize() {\n      var returned = target.apply(this, arguments);\n      var transaction = transaction || tracer.getTransaction();\n      if( arguments[0] ) { // Capture an error, if the callback is given to pgsql Client instance's query method, the 'error' event won't be emitted, the error is only accessible in the callback.\n        agent.errors.add( transaction, arguments[0] );\n      }\n      if( segment ) {\n        segment.end();\n      }\n      if( transaction ) {\n        logger.trace(\"postgres command trace segment ended for transaction %d.\", transaction && transaction.id);\n      }\n      return returned;\n    };\n  }\n\n  function wrapConnect( connect ) {\n    return function( cb ) { \n      // When using native pg, the connect method only accepts a callback parameter(the connection string should be passed to pg Client constructor).\n      // While for the JS implementation, the prototype could be connect( connectString, callback )\n      var args      = tracer.slice( arguments );\n      var position  = args.length - 1;\n      var last      = args[ position ];\n\n      if( typeof last === 'function' ) {\n        args[position] = tracer.callbackProxy( finalize( last ) );\n      }\n      return connect.apply( this, args );\n    }\n  }\n\n  function wrapQuery( query ) {\n    return tracer.segmentProxy(function wrapped( config, values, callback ) {\n      var transaction = tracer.getTransaction();\n      if (!transaction || arguments.length < 1) {\n        logger.trace(\"Not tracing postgres command due to no transaction state.\");\n        return query.apply(this, arguments);\n      }\n\n      var sql;\n      // config: might be a string which is the sql string, or an object with 'text' property as the sql string\n      if( typeof config === 'string' || config instanceof String ) {\n        sql = config;\n      }\n      else if( config && config.text ) {\n        sql = config.text;\n      }\n\n      var ps = parseSql( POSTGRES.PREFIX, sql );\n\n      var args = tracer.slice(arguments)\n        , name = POSTGRES.STATEMENT + ps.model + '/' + ps.operation\n        , segment  = tracer.addSegment(name, ps.recordMetrics.bind(ps))\n        , position = args.length - 1\n        , last = args[position]\n        ;\n\n      logger.trace(\"Adding postgres command trace segment transaction %d.\",\n        transaction.id);\n\n      transaction.addRecorder( ps.recordMetrics.bind( ps, segment ) );\n\n      // capture connection info for datastore instance metric\n      segment.port = this.port;\n      segment.host = this.host;\n\n\n      if (typeof last === 'function') {\n        args[position] = tracer.callbackProxy(finalize(last, segment, transaction));\n      }\n      else { // Make up a callback which won't affect the user's logic.\n        args.push(function cb_push( err ) {\n          if( err ) {\n            agent.errors.add( transaction, err );\n          }\n          segment.end();\n          logger.trace(\"postgres command trace segment ended for transaction %d.\", transaction.id);\n        });\n      }\n      var queried = query.apply( this, args );\n\n      queried.on( 'error', end );\n      queried.on( 'end', end );\n      \n      function end() {\n        segment.end();\n      }\n\n      return queried;\n    });\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/instrumentation/redis.js":"'use strict';\n\nvar path        = require('path')\n  , shimmer     = require(path.join(__dirname, '..', 'shimmer'))\n  , stackUtil   = require(path.join(__dirname, '..', 'util', 'stack' ) )\n  , logger      = require('oneapm-logger')\n                    .child({component : 'redis'})\n  , recordRedis = require(path.join(__dirname, '..', 'metrics', 'recorders', 'redis.js'))\n  , REDIS       = require(path.join(__dirname, '..', 'metrics', 'names')).REDIS\n  ;\n\nmodule.exports = function initialize(agent, redis) {\n  var tracer = agent.tracer;\n\n  shimmer.wrapMethod(redis && redis.RedisClient && redis.RedisClient.prototype,\n                     'redis.RedisClient.prototype',\n                     'send_command',\n                     function wrapper(send_command) {\n    return tracer.segmentProxy(function wrapped() {\n      if (!tracer.getTransaction() || arguments.length < 1) {\n        logger.trace(\"Not tracing Redis command due to no transaction state.\");\n        return send_command.apply(this, arguments);\n      }\n\n      var transaction = tracer.getTransaction()\n        , args        = tracer.slice(arguments)\n        , name        = REDIS.OPERATION + (args[0] || 'unknown')\n        , segment     = tracer.addSegment(name, recordRedis)\n        , position    = args.length - 1\n        , keys        = args[1]\n        , last        = args[position]\n        ;\n\n      if (agent.config.capture_params &&\n          keys && typeof keys !== 'function' &&\n          agent.config.ignored_params.indexOf('key') === -1) {\n        segment.parameters.key = JSON.stringify([keys[0]]);\n\n        var stack = ( new Error() ).stack; \n        segment.parameters.backtrace = stackUtil.formatStack( stack );\n\n      }\n\n      logger.trace(\"Adding Redis command trace segment transaction %d.\",\n                   transaction.id);\n\n      // capture connection info for datastore instance metric\n      segment.port = this.port;\n      segment.host = this.host;\n\n      function finalize(target) {\n        return function cls_finalize() {\n          var returned = target.apply(this, arguments);\n          segment.end();\n          logger.trace(\"Redis command trace segment ended for transaction %d.\",\n                       transaction.id);\n\n          return returned;\n        };\n      }\n\n      if (typeof last === 'function') {\n        args[position] = tracer.callbackProxy(finalize(last));\n      }\n      else if (Array.isArray(last) && typeof last[last.length - 1] === 'function') {\n        var callback = finalize(last[last.length - 1]);\n        last[last.length - 1] = tracer.callbackProxy(callback);\n      }\n      else { // let's shove a callback in there for fun\n        args.push(function cb_push() {\n          segment.end();\n          logger.trace(\"Redis command trace segment ended for transaction %d.\",\n                       transaction.id);\n        });\n      }\n\n      return send_command.apply(this, args);\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/instrumentation/restify.js":"'use strict';\n\nvar path    = require('path')\n  , shimmer = require(path.join(__dirname, '..', 'shimmer'))\n  , logger  = require('oneapm-logger')\n                .child({component : 'restify'})\n  , urltils = require(path.join(__dirname, '..', 'util', 'urltils.js'))\n  , NAMES   = require(path.join(__dirname, '..', 'metrics', 'names.js'))\n  ;\n\nfunction nameFromRoute(segment, route, context) {\n  if (!segment) return logger.error(\"No OneAPM context to set Restify route name on.\");\n  if (!route) return logger.error(\"No Restify route to use for naming.\");\n\n  var transaction = segment.trace.transaction\n    , path        = (route.spec && (route.spec.path || route.spec.name)) || route.name\n    ;\n\n  var params = context || route.params;\n  if (params) {\n    urltils.copyParameters(transaction.agent.config, params, segment.parameters);\n  }\n\n  if (!path) return logger.warn({route : route}, \"No path found on Restify route.\");\n\n  // when route is a regexp, route.spec.path will be a regexp\n  if (path instanceof RegExp) path = path.source;\n\n  transaction.partialName = NAMES.RESTIFY.PREFIX + transaction.verb +\n                            NAMES.ACTION_DELIMITER + path;\n}\n\nmodule.exports = function initialize(agent, restify) {\n  /* Restify doesn't directly expose its Router constructor. We need to wait\n   * until a server is created, and then grab the constructor off of it.\n   *\n   * Unfortunately, we can't create a server ourselves as doing so causes\n   * restify's req.query extension to override express' req.query extension of\n   * IncomingMessage. This is an issue if an app uses express for serving while\n   * using restify only for client-side REST requests.\n   */\n  shimmer.wrapMethod(restify, 'restify', 'createServer', function cb_wrapMethod(createServer) {\n    return function wrappedCreateServer() {\n      agent.environment.setDispatcher('restify');\n      agent.environment.setFramework('restify');\n\n      var server = createServer.apply(this, arguments);\n      var Router = server.router.constructor;\n\n      /* Now that we have created a server, we have access to the Router\n       * constructor and can instrument it.\n       */\n      shimmer.wrapMethod(Router.prototype, 'Router.prototype', 'find', function cb_wrapMethod(find) {\n        return function wrappedFind(req, res, callback) {\n          var tracer = agent.tracer;\n\n          if (!tracer.getTransaction()) {\n            logger.trace(\"Restify router invoked outside transaction.\");\n            return find.apply(this, arguments);\n          }\n\n          var wrapped = function (error, route, context) {\n            nameFromRoute(tracer.getSegment(), route, context);\n            return callback(error, route, context);\n          };\n\n          return find.call(this, req, res, wrapped);\n        };\n      });\n\n      return server;\n    };\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/instrumentation/thinkjs.js":"var path = require('path');\nvar NAMES = require(path.join(__dirname, '..', 'metrics', 'names.js'));\nvar logger = require('oneapm-logger').child({component: 'thinkjs'});\nvar shimmer = require(path.join(__dirname, '..', 'shimmer.js'));\n\nfunction nameFromHTTP(segment, http) {\n    if (!segment)\n        return logger.error(\"No OneAPM context to set Thinkjs route name on.\");\n    if (!http)\n        return logger.debug(\"No Thinkjs request to use for naming.\");\n\n    var transaction = segment.trace.transaction;\n\n    // naming convention for thinks js is\n    // PREFIX / HTTP_VERB / GROUP / CONTROLLER / ACTION\n    var partialName = NAMES.THINKJS.PREFIX + transaction.verb\n            + NAMES.ACTION_DELIMITER + http.group\n            + NAMES.ACTION_DELIMITER + http.controller\n            + NAMES.ACTION_DELIMITER + http.action;\n    transaction.partialName = partialName;\n    logger.debug(partialName);\n}\n\nmodule.exports = function (agent, thinkjs) {\n    agent.environment.setDispatcher('thinkjs');\n    agent.environment.setFramework('thinkjs');\n    function wrapBehavior(_B) {\n        return function cls_wrapMethod(name, http, data) {\n            var result = _B.apply(global, arguments);\n            if (isString(name)) {\n                if (http.controller && !http.__oneapm_marked) {\n                    nameFromHTTP(agent.tracer.getSegment(), http);\n                    http.__oneapm_marked=true;\n                }\n            }\n            return result;\n        }\n    }\n    shimmer.wrapMethod(global, \"global\", \"B\", wrapBehavior);\n}","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/instrumentation/thrift.js":"'use strict';\n\nvar path        = require('path')\n  , shimmer     = require(path.join(__dirname, '..', 'shimmer'))\n  , stackUtil   = require(path.join(__dirname, '..', 'util', 'stack' ) )\n  , logger      = require('oneapm-logger')\n  , recordThrift= require(path.join(__dirname, '..', 'metrics', 'recorders', 'thrift.js'))\n  , NAMES       = require(path.join(__dirname, '..', 'metrics', 'names'))\n  , THRIFT      = NAMES.THRIFT\n  , recordExternal = require(path.join(__dirname, '..', 'metrics', 'recorders', 'http_external.js'))\n  ;\n\nmodule.exports = function initialize(agent, thrift) {\n  var tracer = agent.tracer;\n\n  shimmer.wrapMethod( thrift, 'thrift', 'createServer', function wrapper(createServer) {\n    return tracer.callbackProxy(function wrappedHandler(service, provider) {\n      for( let k in provider ) {\n        shimmer.wrapMethod( provider, 'thrift_service.' + k, k, function wrapper( original ) {\n\n          var proxied = tracer.transactionProxy( function wrapService() {\n            var transaction = tracer.getTransaction();\n            if (!transaction) return original.apply(this, arguments);\n\n            // Mark it as a web transaction:\n            transaction.url = THRIFT.PREFIX + '/' + k;\n            transaction.verb = THRIFT.PREFIX;\n            transaction.partialName = THRIFT.PREFIX + '/' + k;\n            transaction.name = NAMES.WEB + '/' + transaction.partialName;\n\n            var segment = tracer.addSegment( THRIFT.PREFIX + k, recordThrift );\n\n            var stack = (new Error()).stack;\n            segment.parameters.backtrace = stackUtil.formatStack( stack );\n\n            var result = original.apply( null, arguments );\n            //segment.markAsWeb('thrift' + k);\n            transaction.end();\n            segment.end();\n            return result;\n          } );\n\n          // Construct the formal argument list\n          var argList = [];\n          for( var i=0,len=original.length; i<len; ++i ) {\n            argList.push( 'arg' + i );\n          }\n\n          // Wrap the last callback into CLS, so the errors inside can be recorded.\n          var args = tracer.slice(arguments)\n          var position = args.length - 1\n          var last     = args[position]\n          if( last && typeof last === 'function') {\n            function finalize(target) {\n              function cls_finalize() {\n                var returned = target.apply(this,  arguments );\n                segment.end();\n                return returned;\n              };\n              return cls_finalize;\n            }\n            arguments[position] = tracer.callbackProxy( finalize(last) );\n          }\n\n          // I know I really did something ugly with eval, but what else can I choose? \n          // The thrift framework just uses the original function's 'length' property, forcing me to construct the wrapped function with a correct number of formal arguments.\n          // Uh...hope someday we can get rid of the continuation-local-storage module, which conflicts with the 'q' module.\n          return eval( '(function(' + argList.toString() + '){ proxied.apply( this, arguments )  })');\n        } );\n      }\n\n      var server = createServer.apply( this, arguments );\n      server.on( 'error', function( error ) {\n        logger.error( \"Error when creating thrift server\", error );\n        // Since the server error is emitted in the event loop, it may not be related to a certain transaction, so just consume that there is no transaction.\n        // If use tracer.getTransaction here, the error might be scoped to an unrelated transaction.\n        agent.errors.add( null, error );\n      } );\n\n      return server;\n    } );\n  } );\n\n\n  shimmer.wrapMethod( thrift, 'thrift', 'createClient', function wrapper(createClient) {\n    \n    return tracer.callbackProxy(function wrappedHandler(service, connection) {\n      connection.on( 'error', function( error ) {\n        var transaction = agent.tracer.getTransaction();\n        agent.errors.add( transaction, error );\n      } );\n\n      var methods = Object.getOwnPropertyNames(service.prototype || service.Client.prototype);\n\n      var targetMethods = [];\n      methods.forEach( function( method ) {\n        if( method.substr(0, 5) == 'send_' ) {\n          var targetMethod = method.substring( 5, method.length );\n          if( service.Client.prototype[targetMethod] ) { // Don't forget to check the existence of the target method in Client.prototype, or a method named with 'send_' will also be considered as things to wrap.\n            targetMethods.push( targetMethod );\n          }\n        }\n      } );\n\n      targetMethods.forEach( function( method ) {\n        shimmer.wrapMethod( service.Client.prototype, 'thriftClient', method, function( originalMethod ) {\n          return tracer.segmentProxy( function wrapMethod() {\n\n            if (!tracer.getTransaction() ) { // TODO Maybe a thrift client request should be considered as a complete transaction when it's not scoped with any other transaction?\n              logger.trace(\"Not tracing thrift rpc method due to no transaction state.\");\n              return originalMethod.apply(this, arguments);\n            }\n\n            var host = connection.host;\n            var port = connection.port;\n\n            // Construct the thrift uri for recorder.\n            var uri = 'thrift://' + host + ':' + port + '/';\n            if( service.serviceName ) {\n              uri += service.serviceName + '.';\n            }\n            uri += method;\n\n            var transaction = agent.tracer.getTransaction()\n              , name        = NAMES.EXTERNAL.PREFIX + '/thrift/' + host + ':' + port + '/' + method\n              , segment     = tracer.addSegment(name, recordExternal(uri, 'thrift'))\n              , args        = tracer.slice(arguments)\n              , position    = args.length - 1\n              , last        = args[position]\n              ;\n\n            segment.port = port;\n            segment.host = host;\n\n            function finalize(target) {\n              function cls_finalize() {\n                var returned = target.apply(this,  arguments );\n                segment.end();\n                return returned;\n              };\n              return cls_finalize;\n            }\n\n            if( typeof last === 'function' ) {\n              args[position] = tracer.callbackProxy( finalize(last) );\n            }\n            else {\n              logger.warn(\"OneAPM currently doesn't support thrift client request without a callback, this might cause unkonwn behaviors!\");\n            }\n\n            return originalMethod.apply( this, args );\n          } );\n        } );\n      } );\n\n      return createClient.apply( this, arguments );\n    } );\n  } );\n\n\n};\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/metrics/mapper.js":"'use strict';\n\nvar path   = require('path')\n  , logger = require('oneapm-logger').child({component : 'mapper'})\n  ;\n\n/**\n * To tighten up the metrics JSON, the collector will maintain a list of\n * mappings from metric names (which sometimes include scopes as well) to\n * numeric IDs. As the agent sends new metric names to the collector, the\n * collector will return corresponding metric IDs, in the expectation that the\n * agent will uses those IDs instead of the names going forward.\n *\n * @param {Array} raw A list of metric spec -> ID mappings represented as\n *                    2-element arrays: [{name : 'Metric', scope : 'Scope'}, 1]\n */\nfunction MetricMapper(raw) {\n  this.unscoped = {};\n  this.scoped   = {};\n  this.length   = 0;\n\n  this.load(raw);\n}\n\n/**\n * Parse the list of metric mappings returned on metric_data responses from the\n * collector. These continue to stream in as the agent runs, so keep adding to\n * the collection rather than resetting.\n *\n * @param {Array} raw A list of metric spec -> ID mappings represented as\n *                    2-element arrays: [{name : 'Metric', scope : 'Scope'}, 1]\n */\nMetricMapper.prototype.load = function load(raw) {\n  if (!(raw && raw.length)) {\n    logger.debug(\"No new metric mappings from server.\");\n    return;\n  }\n\n  for (var i = 0; i < raw.length; i++) {\n    var spec  = raw[i][0]\n      , scope = spec.scope\n      , name  = spec.name\n      , id    = raw[i][1]\n      , resolved\n      ;\n\n    if (scope) {\n      if (!this.scoped[scope]) this.scoped[scope] = {};\n      resolved = this.scoped[scope];\n    }\n    else {\n      resolved = this.unscoped;\n    }\n\n    if (!resolved[name]) this.length++;\n    resolved[name] = id;\n    logger.trace(\"Metric spec %j has been mapped to ID %s.\", spec, id);\n  }\n  logger.debug(\"Parsed %d metric ids (%d total).\", raw.length, this.length);\n};\n\n/**\n * @param {String} name  The metric name.\n * @param {String} scope The scope for the metric, if set.\n *\n * @returns {object} Either a metric spec based on the parameters, or the\n *                   server-sent ID.\n */\nMetricMapper.prototype.map = function map(name, scope) {\n  if (scope) {\n    if (this.scoped[scope] && this.scoped[scope][name]) {\n      return this.scoped[scope][name];\n    }\n    else {\n      return {name : name, scope : scope};\n    }\n  }\n  else {\n    if (this.unscoped[name]) {\n      return this.unscoped[name];\n    }\n    else {\n      return {name : name};\n    }\n  }\n};\n\nmodule.exports = MetricMapper;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/metrics/normalizer.js":"'use strict';\n\nvar path      = require('path')\n  , logger    = require('oneapm-logger')\n                  .child({component : 'metric_normalizer'})\n  , deepEqual = require('../util/deep-equal')\n  , Rule      = require('./normalizer/rule')\n  , NAMES     = require('../metrics/names.js')\n  ;\n\n\nfunction url(normalized, path, config) {\n  if (normalized) return NAMES.NORMALIZED + normalized;\n\n  if (config.enforce_backstop) {\n    return NAMES.NORMALIZED + '/*';\n  }\n  else {\n    return NAMES.URI + path;\n  }\n}\n\nfunction plain(normalized, path) {\n  if (normalized) {\n    return normalized;\n  }\n  else {\n    return path;\n  }\n}\n\n/**\n * The collector keeps track of rules that should be applied to metric names,\n * and sends these rules to the agent at connection time. These rules can\n * either change the name of the metric or indicate that metrics associated with\n * this name (which is generally a URL path) should be ignored altogether.\n *\n * @param {object} config The agent's configuration blob, which has a parameter\n *                        that indicates whether to enforce the normalization\n *                        backstop.\n */\nfunction MetricNormalizer(config, type) {\n  if (!config) throw new Error(\"normalizer must be created with configuration.\");\n  if (!type) throw new Error(\"normalizer must be created with a type.\");\n\n  this.config = config;\n  this.type = type;\n  // some mildly cheesy polymorphism to make normalizers work generically\n  if (type === 'URL') {\n    this.formatter = url;\n  }\n  else {\n    this.formatter = plain;\n  }\n\n  this.rules = [];\n}\n\n/**\n * Convert the raw, deserialized JSON response into a set of\n * NormalizationRules.\n *\n * @param object json The deserialized JSON response sent on collector\n *                    connection.\n */\nMetricNormalizer.prototype.load = function load(json) {\n  if (json) {\n    logger.debug(\"Received %s %s normalization rule(s)\", json.length, this.type);\n\n    json.forEach(function cb_forEach(ruleJSON) {\n      var rule = new Rule(ruleJSON);\n      // no need to add the same rule twice\n      if (!this.rules.some(function cb_some(r) { return deepEqual(r, rule); })) {\n        this.rules.push(rule);\n      }\n    }, this);\n\n    /* I (FLN) always forget this, so making a note: JS sort is always\n     * IN-PLACE, even though it returns the sorted array.\n     */\n    this.rules.sort(function cb_sort(a, b) { return a.precedence - b.precedence; });\n\n    logger.debug(\"Normalized to %s %s normalization rule(s).\",\n                 this.rules.length, this.type);\n  }\n};\n\n/**\n * Load any rules found in the configuration into a metric normalizer.\n *\n * Operates via side effects.\n */\nMetricNormalizer.prototype.loadFromConfig = function loadFromConfig() {\n  var rules = this.config.rules;\n\n  if (rules && rules.name && rules.name.length > 0) {\n    rules.name.forEach(function cb_forEach(rule) {\n      if (!rule.pattern) {\n        return logger.error({rule : rule},\n                            \"Simple naming rules require a pattern.\");\n      }\n      if (!rule.name) {\n        return logger.error({rule : rule},\n                            \"Simple naming rules require a replacement name.\");\n      }\n\n      this.addSimple(rule.pattern, rule.name);\n    }, this);\n  }\n\n  if (rules && rules.ignore && rules.ignore.length > 0) {\n    rules.ignore.forEach(function cb_forEach(pattern) { this.addSimple(pattern); }, this);\n  }\n};\n\n/**\n * Add simple, user-provided rules to the head of the match list. These rules\n * will always be highest precedence, always will terminate matching, and\n * will always apply to the URL as a whole. If no name is provided, then\n * transactions attached to the matching URLs will be ignored.\n *\n * @param {RegExp} pattern The pattern to rename (with capture groups).\n * @param {string} name    The name to use for the transaction.\n */\nMetricNormalizer.prototype.addSimple = function addSimple(pattern, name) {\n  if (!pattern) return logger.error(\"Simple naming rules require a pattern.\");\n\n  var json = {\n    match_expression : pattern,\n    terminate_chain  : true\n  };\n\n  if (name) {\n    json.replacement = name;\n  }\n  else {\n    json.ignore = true;\n  }\n\n  this.rules.unshift(new Rule(json));\n};\n\n/**\n * Test whether a URL path should be ignored.\n *\n * @param {string} path The URL path to test.\n *\n * @returns {boolean} Whether or not to ignore the path.\n */\nMetricNormalizer.prototype.isIgnored = function isIgnored(path) {\n  var length = this.rules.length;\n  for (var i = 0; i < length; i++) {\n    var rule = this.rules[i];\n    if (rule.ignore && rule.matches(path)) {\n      logger.trace(\"Ignoring %s because of rule: %j\", path, rule);\n      // prevent deoptimization\n      return true;\n    }\n  }\n\n  return false;\n};\n\n/**\n * Test whether a URL path will be normalized.\n *\n * @param {string} path The URL path to test.\n *\n * @returns {boolean} Whether or not any normalization rules match.\n */\nMetricNormalizer.prototype.isNormalized = function isNormalized(path) {\n  var length = this.rules.length;\n  for (var i = 0; i < length; i++) {\n    var rule = this.rules[i];\n    if (!rule.ignore && rule.matches(path)) {\n      logger.trace(\"Normalizing %s because of rule: %j\", path, rule);\n      // prevent deoptimization\n      return true;\n    }\n  }\n\n  return false;\n};\n\n\n/**\n * Turn a (scrubbed) URL path into partial metric name.\n *\n * @param {string} path The URL path to turn into a name.\n *\n * @returns {string} The normalized name.\n */\nMetricNormalizer.prototype.normalize = function normalize(path) {\n  var last   = path\n    , length = this.rules.length\n    , normalized\n    ;\n\n  for (var i = 0; i < length; i++) {\n    var rule = this.rules[i];\n    if (rule.matches(last)) {\n      normalized = rule.apply(last);\n      logger.trace(\"Normalized %s to %s because of rule: %j\", last, normalized, rule);\n\n      if (rule.isTerminal) {\n        logger.trace(\"Terminating normalization because of rule: %j\", rule);\n        break;\n      }\n\n      last = normalized;\n    }\n  }\n\n  return this.formatter(normalized, path, this.config);\n};\n\nmodule.exports = MetricNormalizer;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/transaction/tracer.js":"'use strict';\n\nvar path        = require('path')\n  , cls         = require('continuation-local-storage')\n  , Transaction = require(path.join(__dirname, '..', 'transaction.js'))\n  ;\n\n/*\n *\n * CONSTANTS\n *\n */\nvar ORIGINAL = '__NR_original'\n  , TRACER   = '__NR_tracer'\n  , TYPE     = '__NR_segment_type'\n  ;\n\n/* Just in case something decides to use the production and\n * debugging tracers at the same time.\n */\nvar namespace = process.namespaces[TRACER];\nif (!namespace) namespace = cls.createNamespace(TRACER);\n\n/**\n * Instead of eating the overhead of creating two separate async listeners\n * to handle CLS and error-tracing, reuse the existing CLS error callback.\n *\n * @param {Agent} agent The current agent instance.\n * @param {Namespace} namespace CLS instance.\n */\nfunction _patchErrorTracerOntoCLS(agent, namespace) {\n  var callbacks = namespace && namespace.id;\n  if (callbacks && callbacks.error) {\n    callbacks.error = function cb_error(domain, error) {\n      var context     = namespace.fromException(error)\n        , transaction = (domain && domain.transaction) ||\n                        (context && context.transaction)\n        ;\n\n      agent.errors.add(transaction, error);\n\n      if (domain) namespace.exit(domain);\n    };\n  }\n}\n\n/**\n * EXECUTION TRACER\n *\n * One instance of this class exists per agent, with the state\n * representing the current context shared across the agent.\n *\n * The transaction tracer works by wrapping either the generator functions\n * that asynchronously handle incoming requests (via\n * Tracer.transactionProxy and Tracer.segmentProxy) or direct function\n * calls in the form of callbacks (via Tracer.callbackProxy).\n *\n * In both cases, the wrappers exist to set up the execution context for\n * the wrapped functions. The context is effectively global, and works in\n * a manner similar to Node 0.8's domains, by explicitly setting up and\n * tearing down the current transaction / segment / call around each\n * wrapped function's invocation. It relies upon the fact that Node is\n * single-threaded, and requires that each entry and exit be paired\n * appropriately so that the context is left in its proper state.\n *\n * This version is optimized for production. For debugging purposes,\n * use transaction/tracer/debug.js. The agent can be configured to\n * run in debugging mode at runtime by setting the configuration\n * variable debug.tracer_tracing.\n */\nfunction Tracer(agent) {\n  if (!agent) throw new Error(\"Must be initialized with an agent.\");\n\n  this.agent = agent;\n\n  _patchErrorTracerOntoCLS(agent, namespace);\n}\n\n/**\n * Examine shared context to find any current transaction.\n * Filter out inactive transactions.\n *\n * @returns {Transaction} The current transaction.\n */\nTracer.prototype.getTransaction = function getTransaction() {\n  var transaction = namespace.get('transaction');\n  if (transaction && transaction.isActive()) return transaction;\n};\n\nTracer.prototype.setTransaction = function setTransaction(transaction) {\n  namespace.set('transaction', transaction);\n};\n\n/**\n * Look up the currently active segment.\n *\n * @returns {Segment} Active segment, if set.\n */\nTracer.prototype.getSegment = function getSegment() {\n  return namespace.get('segment');\n};\n\nTracer.prototype.setSegment = function setSegment(segment) {\n  namespace.set('segment', segment);\n};\n\n/**\n * Create a new trace segment that depends on the current segment on the\n * active transaction trace.\n *\n * @param {string}   name     The metric name for the new segment (can be\n *                            renamed by Segment.prototype.markAsWeb).\n * @param {function} recorder Function to be called when the segment is closed\n *                            and metrics are ready to be recorded.\n *\n * @returns {Segment} The newly-created segment.\n */\nTracer.prototype.addSegment = function addSegment(name, recorder) {\n  var current = namespace.get('segment');\n  var segment = current.add(name, recorder);\n  namespace.set('segment', segment);\n\n  return segment;\n};\n\n/**\n * Use transactionProxy to wrap a closure that is a top-level handler that is\n * meant to start transactions. This wraps the first half of\n * asynchronous handlers. Use callbackProxy to wrap handler callbacks.\n *\n * @param {Function} handler Generator to be proxied.\n * @returns {Function} Proxy.\n */\nTracer.prototype.transactionProxy = function transactionProxy(handler) {\n  // if there's no handler, there's nothing to proxy.\n  if (!handler) return;\n\n  var self = this;\n  var wrapped = function wrapTransactionInvocation() {\n    // don't nest transactions, reuse existing ones\n    var transaction = self.getTransaction() || new Transaction(self.agent)\n      , proxied     = this\n      , args        = self.slice(arguments)\n      ;\n\n    var returned;\n    namespace.bind(function cb_bind() {\n      self.setTransaction(transaction);\n      self.setSegment(transaction.getTrace().root);\n      returned = namespace.bind(handler).apply(proxied, args);\n    }, Object.create(null))();\n\n    return returned;\n  };\n  wrapped[ORIGINAL] = handler;\n\n  return wrapped;\n};\n\n/**\n * Use segmentProxy to wrap a closure that is a top-level handler that is\n * meant to participate in an existing transaction. Unlike transactionProxy,\n * it will not create new transactions. This is wraps the first half of\n * asynchronous calls. Use callbackProxy to wrap handler callbacks.\n *\n * @param {Function} handler Generator to be proxied.\n * @returns {Function} Proxy.\n */\nTracer.prototype.segmentProxy = function segmentProxy(handler) {\n  // if there's no handler, there's nothing to proxy.\n  if (!handler) return;\n\n  var self = this;\n  var wrapped = function wrapSegmentInvocation() {\n    // don't implicitly create transactions\n    if (!self.getTransaction()) return handler.apply(this, arguments);\n\n    return namespace.bind(handler, namespace.createContext()).apply(this, arguments);\n  };\n  wrapped[ORIGINAL] = handler;\n\n  return wrapped;\n};\n\n/**\n * Use callbackProxy to wrap a closure that may invoke subsidiary functions that\n * want access to the current transaction. When called, it sets up the correct\n * context before invoking the original function (and tears it down afterwards).\n *\n * Proxying of individual calls is only meant to be done within the scope of\n * an existing transaction.\n *\n * @param {Function} handler Function to be proxied on invocation.\n * @returns {Function} Proxy.\n */\nTracer.prototype.callbackProxy = function callbackProxy(handler) {\n  // if there's no handler, there's nothing to proxy.\n  if (!handler) return;\n\n  // don't implicitly create transactions\n  if (!this.getTransaction()) return handler;\n\n  var wrapped = namespace.bind(handler, namespace.createContext());\n  wrapped[ORIGINAL] = handler;\n\n  return wrapped;\n};\n\n/**\n * Requests, responses, sockets and streams can be pulled into a request, and\n * the tracer needs to make sure that any event-handling propagates state\n * appropriately. CLS will take care of the necessary monkeypatching (which is\n * kinda gross and slow, but unavoidable without a more general way of bridging\n * synchronous emitters and asynchronous CLS).\n *\n * @param {EventEmitter} emitter The emitter to be put onto the CLS context.\n */\nTracer.prototype.bindEmitter = function bindEmitter(emitter) {\n  namespace.bindEmitter(emitter);\n};\n\n/**\n * Some instrumented modules make self calls from instrumented functions to\n * instrumented functions.  Because developers can't do anything about these\n * subsidiary calls, and in most cases won't even know they're there, it\n * doesn't make sense to put them on the transaction trace. The instrumentation\n * needs a way to determine whether calls should be ignored or not, and why not\n * use CLS to set the current instrumentation type for the rest of the current\n * tick?\n *\n * @param {object} type An opaque identifier for the current segment type.\n */\nTracer.prototype.setCurrentSegmentType = function setCurrentSegmentType(type) {\n  // only add a cleaner if there isn't one set already\n  if (!namespace.get(TYPE)) process.nextTick(function cb_nextTick() {\n    namespace.set(TYPE, undefined);\n  });\n  namespace.set(TYPE, type);\n};\n\n/**\n * Determine whether last segment was of the same type. Doing it this way\n * allows synchronous setup calls to alternate between e.g. Redis and MongoDB,\n * without stomping on subsidiary calls.\n *\n * @param {object} type An opaque identifier for the current segment type.\n *\n * @returns {boolean} Whether the segment types match.\n */\nTracer.prototype.isCurrentSegmentType = function isCurrentSegmentType(type) {\n  return namespace.get(TYPE) === type;\n};\n\nTracer.prototype.slice = function slice(args) {\n  /**\n   * Usefully nerfed version of slice for use in instrumentation. Way faster\n   * than using [].slice.call, and maybe putting it in here (instead of the\n   * same module context where it will be used) will make it faster by\n   * defeating inlining.\n   *\n   *   http://jsperf.com/array-slice-call-arguments-2\n   *\n   *  for untrustworthy benchmark numbers. Only useful for copying whole\n   *  arrays, and really only meant to be used with the arguments arraylike.\n   *\n   *  Also putting this comment inside the function in an effort to defeat\n   *  inlining.\n   */\n  var length = args.length\n    , array = []\n    , i\n    ;\n\n  for (i = 0; i < length; i++) {\n    array[i] = args[i];\n  }\n\n  return array;\n};\n\nmodule.exports = Tracer;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/util/deep-equal.js":"'use strict';\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) === '[object Arguments]';\n}\n\nfunction slice(args) {\n  // Array.prototype.slice on arguments arraylike is expensive\n  var l = args.length, a = [], i;\n  for (i = 0; i < l; i++) {\n    a[i] = args[i];\n  }\n  return a;\n}\n\n/**\n * This is a node-specific version of deepEquals, modeled on bits and pieces\n * of loads of other implementations of this algorithm, most notably the\n * one in the Node.js source and Underscore's. It doesn't throw and handles\n * cycles.\n *\n * Everybody who writes one of these functions puts the documentation\n * inline, which makes it incredibly hard to follow. Here's what this version\n * of the algorithm does, in order:\n *\n * 1. === only tests objects and and functions by reference. Null is an object.\n *    Any pairs of identical entities failing this test are therefore objects\n *    (including null), which need to be recursed into and compared attribute by\n *    attribute.\n * 2. Since the only matching entities to get to this test must be objects, if\n *    a or b is not an object, they're clearly not the same. All unfiltered a\n *    and b getting are objects (including null).\n * 3. null is an object, but null === null. All unfiltered a and b are non-null\n *    objects.\n * 4. Buffers need to be special-cased because they live partially on the wrong\n *    side of the C++ / JavaScript barrier. Still, calling this on structures\n *    that can contain Buffers is a bad idea, because they can contain\n *    multiple megabytes of data and comparing them byte-by-byte is hella\n *    expensive. buffertools is a better solution here, but this version of\n *    this code is dependency free.\n * 5. It's much faster to compare dates by numeric value than by lexical value.\n * 6. Same goes for Regexps.\n * 7. The parts of an arguments list most people care about are the arguments\n *    themselves, not the callee, which you shouldn't be looking at anyway.\n * 8. Objects are more complex:\n *    a. ensure that a and b are on the same constructor chain\n *    b. ensure that a and b have the same number of own properties (which is\n *       what Object.keys returns).\n *    c. ensure that cyclical references don't blow up the stack.\n *    d. ensure that all the key names match (faster)\n *    e. esnure that all of the associated values match, recursively (slower)\n *\n * (SOMEWHAT UNTESTED) ASSUMPTIONS:\n *\n * o Functions are only considered identical if they unify to the same\n *   reference. To anything else is to invite the wrath of the halting problem.\n * o V8 is smart enough to optimize treating an Array like any other kind of\n *   object.\n * o Users of this function are cool with mutually recursive data structures\n *   that are otherwise identical being treated as the same.\n */\nfunction deeper(a, b, ca, cb) {\n  if (a === b) {\n    return true;\n  }\n  else if (typeof a !== 'object' || typeof b !== 'object') {\n    return false;\n  }\n  else if (a === null || b === null) {\n    return false;\n  }\n  else if (Buffer.isBuffer(a) && Buffer.isBuffer(b)) {\n    if (a.length !== b.length) return false;\n\n    // potentially incredibly expensive\n    for (var i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;\n\n    return true;\n  }\n  else if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime();\n  }\n  else if (a instanceof RegExp && b instanceof RegExp) {\n    return a.source     === b.source &&\n           a.global     === b.global &&\n           a.multiline  === b.multiline &&\n           a.lastIndex  === b.lastIndex &&\n           a.ignoreCase === b.ignoreCase;\n  }\n  else if (isArguments(a) || isArguments(b)) {\n    if (!(isArguments(a) && isArguments(b))) return false;\n\n    return deeper(slice(a), slice(b), ca, cb);\n  }\n  else {\n    if (a.constructor !== b.constructor) return false;\n\n    var ka = Object.keys(a), kb = Object.keys(b);\n    if (ka.length !== kb.length) return false;\n\n    var cal = ca.length;\n    while (cal--) if (ca[cal] === a) return cb[cal] === b;\n    ca.push(a); cb.push(b);\n\n    ka.sort(); kb.sort();\n    for (var j = ka.length - 1; j >= 0; j--) if (ka[j] !== kb[j]) return false;\n\n    var key;\n    for (var k = ka.length - 1; k >= 0; k--) {\n      key = ka[k];\n      if (!deeper(a[key], b[key], ca, cb)) return false;\n    }\n\n    ca.pop(); cb.pop();\n\n    return true;\n  }\n}\n\nmodule.exports = function exports(a, b) { return deeper(a, b, [], []); };\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/util/flatten.js":"/**\n * Flatten nested maps of JSONifiable data.\n *\n * Ex: {a: 5, b: {c: true, d: 7}} -> {a: 5, 'b.c': true, 'b.d': 7}\n *\n * @param result Object to place key-value pairs into, normally called with {}\n * @param prefix Prefix for keys, normally called with ''\n * @param obj    Object to be flattened\n *\n * @return Object with flattened key-value pairs\n */\nmodule.exports = function flatten(result, prefix, obj, seen) {\n  seen = seen || [];\n  seen.push(obj);\n\n  for (var key in obj) {\n\n    if (seen.indexOf(obj[key]) > -1) {\n      continue;\n    }\n\n    if (obj[key] instanceof Object) flatten(result, prefix + key + '.', obj[key], seen);\n    else result[prefix + key] = obj[key];\n  }\n\n  return result;\n};\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/util/full-url.js":"function fullUrl(request) {\n\tif (/^\\//.test(request.url)) {\n\t\tvar protocol = request.ssl ? 'https' : 'http';\n\t\tvar hostAndPort = request.headers['host']\n\t\tif (!hostAndPort) {\n\t\t\tvar localAddress = request.socket.localAddress\n\t\t\tvar localPort = request.socket.localPort\n\t\t\t// IPv6\n\t\t\tif (localAddress.indexOf(':') !== -1) {\n\t\t\t\t// \"Format for Literal IPv6 Addresses in URL's\"\n\t\t\t\t//   https://tools.ietf.org/html/rfc2732\n\t\t\t\t// \"Representing IPv6 Zone Identifiers in Address Literals and Uniform Resource Identifiers\"\n\t\t\t\t//   https://tools.ietf.org/html/rfc6874\n\t\t\t\thostAndPort = '[' + localAddress + ']' + ':' + localPort\n\t\t\t}\n\t\t\t// IPv4\n\t\t\telse {\n\t\t\t\thostAndPort = localAddress + ':' + localPort\n\t\t\t}\n\t\t}\n\t\treturn protocol + '://' + hostAndPort + request.url\n\t}\n\telse {\n\t\treturn request.url;\n\t}\n}\n\nmodule.exports = fullUrl;","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/util/inject-script.js":"/**\n * Created by yan on 15-8-5.\n */\nvar path = require('path');\nvar logger = require('oneapm-logger')\n  .child({component: 'api-inject-script'});\n\nvar loading = false;\nvar inline_content_cache = {};\n\n/**\n *\n * @param js_agent_loader\n */\nfunction set_cache(js_agent_loader) {\n  loading = true;\n  var js_agent_loader_url = \"http:\" + js_agent_loader;\n  var req = require('http').request(js_agent_loader_url, function (res) {\n    var buf = [];\n    var buf_len = 0;\n    res.on('data', function (r) {\n      buf.push(r);\n      buf_len += r.length;\n    });\n    res.on('end', function () {\n      loading = false;\n      var content = Buffer.concat(buf, buf_len);\n      inline_content_cache[js_agent_loader] = '</script><script type=\"text/javascript\">' + content.toString('UTF-8');\n      logger.debug('get inline script content ', {\n        js_agent_loader: js_agent_loader,\n        content: inline_content_cache[js_agent_loader]\n      });\n      logger.info('updated inline_content_cache', Object.keys(inline_content_cache));\n    });\n  });\n\n  logger.info('requesting %s ', js_agent_loader_url);\n  req.end();\n}\n\n/**\n *  return inline or external script for BI features\n *\n * @since v1.2.5\n *\n * @param js_agent_loader {string} BI script file location, normally it will look like //tpm.oneapm.com/static/js/bw-loader-411.4.3.js\n * @param config {Object} agent config object\n * @returns {string}\n */\nmodule.exports = function (js_agent_loader, config) {\n  var external_link = '</script><script type=\"text/javascript\" src=\"' + js_agent_loader + '\">';\n\n  var isProxy = (config.proxy.length + config.proxy_host.length) > 0;\n\n  if (config.is_js_text && !isProxy) {\n\n    if (inline_content_cache[js_agent_loader]) {\n      return inline_content_cache[js_agent_loader];\n    } else if (!loading) {\n      set_cache(js_agent_loader);\n    }\n  }\n\n  return external_link;\n};","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/util/last-io.js":"var assert = require('assert')\n\nfunction markOrUpdate(socket) {\t\n\tif (!socket.hasOwnProperty('__OneAPM_LastIO')) {\n\t\tsocket.__OneAPM_LastIO = {\n\t\t\tbytesRead: socket.bytesRead,\n\t\t\tbytesWritten: socket.bytesWritten\n\t\t}\n\t}\n\telse {\n\t\tsocket.__OneAPM_LastIO.bytesRead = socket.bytesRead\n\t\tsocket.__OneAPM_LastIO.bytesWritten = socket.bytesWritten\n\t}\n}\n\nfunction bytesRead(socket) {\t\n\tvar last = socket.hasOwnProperty('__OneAPM_LastIO') ? socket.__OneAPM_LastIO.bytesRead : 0\n\treturn socket.bytesRead - last\n}\n\nfunction bytesWritten(socket) {\t\n\tvar last = socket.hasOwnProperty('__OneAPM_LastIO') ? socket.__OneAPM_LastIO.bytesWritten : 0\n\treturn socket.bytesWritten - last\n}\n\nexports.markOrUpdate = markOrUpdate\nexports.bytesRead = bytesRead\nexports.bytesWritten = bytesWritten\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/util/myip.js":"'use strict';\n\nvar os = require('os');\n\n/**\n * Retrieve local IPs (IPv4 only).\n *\n * @return List of IP string, or empty list.\n */\nfunction myip() {\n    var ip_list = [];\n    var nifs = os.networkInterfaces();\n    for (var name in nifs) {\n        var items = nifs[name];\n        items.forEach(function(item) {\n            if (!item.internal && item.family === 'IPv4') {\n                ip_list.push(item.address);\n            }\n        })\n    }\n    return ip_list.sort();\n}\n\nmodule.exports = exports = myip;","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/util/stack.js":"var path = require( 'path' );\nvar ONEAPM_MODULE_ROOT = path.resolve(__dirname, '../..')\n\nfunction formatStack(stack) {\n  if( !stack ) return '';\n  // remove error message and instrumentation frames from stack trace\n  return stack.split('\\n').slice(1).filter(notOneAPM).join('\\n');\n}\n\nfunction notOneAPM(frame) {\n  return frame.indexOf(ONEAPM_MODULE_ROOT) === -1\n}\n\nexports.formatStack = formatStack;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/util/stream-sink.js":"'use strict';\n\nvar EventEmitter = require('events').EventEmitter\n  , util         = require('util')\n  ;\n\n/**\n * Pipe a readable stream into this sink that fulfills the Writable Stream\n * contract and the callback will be fired when the stream has been completely\n * read.\n */\nfunction StreamSink(callback) {\n  EventEmitter.call(this);\n\n  this.callback = callback;\n  this.sink = '';\n  this.writable = true;\n\n  var sink = this;\n  this.on('error', function handle_error(error) {\n    sink.writable = false;\n    callback(error);\n  });\n}\nutil.inherits(StreamSink, EventEmitter);\n\nStreamSink.prototype.write = function write(string) {\n  if (!this.writable) {\n    this.emit('error', new Error(\"Sink no longer writable!\"));\n    return false;\n  }\n\n  // Explicitly copy buffer contents so we are sure to release references to\n  // the TLS slab buffer region.\n  // I guess it is a potential bottle neck, because we are doing lots of string concat here\n  this.sink += string.toString();\n\n  return true;\n};\n\nStreamSink.prototype.end = function end() {\n  this.writable = false;\n\n  this.callback(null, this.sink);\n};\n\nStreamSink.prototype.destroy = function destroy() {\n  this.emit('close');\n  this.writable = false;\n\n  delete this.sink;\n};\n\nmodule.exports = StreamSink;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/instrumentation/core/http.js":"'use strict';\n\nvar path               = require('path')\n  , shimmer            = require('../../shimmer.js')\n  , logger             = require('oneapm-logger').child({component : 'http'})\n  , stackUtil          = require('../../util/stack' )\n  , recordWeb          = require('../../metrics/recorders/http.js')\n  , instrumentOutbound = require('../../transaction/tracer/instrumentation/outbound.js')\n  , myip               = require('../../util/myip')\n  , fullUrl            = require('../../util/full-url')\n  , lastIO             = require('../../util/last-io.js')\n  ;\n\n/*\n *\n * CONSTANTS\n *\n */\nvar NR_CONNECTION_PROP = '__NR__connection';\nvar DEFAULT_HOST = 'localhost';\nvar DEFAULT_PORT = 80;\nvar REQUEST_HEADER = 'x-request-start';\nvar QUEUE_HEADER = 'x-queue-start';\nvar AE_REQ_HEADER_ID = 'x-blueware-id';                   // Analytic Event Request  Header: ID\nvar AE_REQ_HEADER_TRANSACTION = 'x-blueware-transaction'; // Analytic Event Request  Header: Transaction\nvar AE_RES_HEADER_APP_DATA = 'x-blueware-app-data';       // Analytic Event Response Header: App Data\n\nfunction wrapListener(agent, listener) {\n  if (!listener) throw new Error(\"No request listener defined, so nothing to do.\");\n\n  var tracer = agent.tracer;\n\n  return tracer.transactionProxy(function wrappedHandler(request, response) {\n    if (!tracer.getTransaction()) return listener.apply(this, arguments);\n\n    /* Needed for Connect and Express middlewares that monkeypatch request\n     * and response via listeners.\n     */\n    tracer.bindEmitter(request);\n    tracer.bindEmitter(response);\n\n    var transaction = tracer.getTransaction()\n      , segment     = tracer.addSegment(request.url, recordWeb)\n      ;\n\n    var stack = (new Error()).stack;\n    segment.parameters.backtrace = stackUtil.formatStack( stack );\n\n    // the error tracer needs a URL for tracing, even though naming overwrites\n    transaction.url  = request.url;\n    transaction.fullUrl = fullUrl(request);\n    transaction.verb = request.method;\n    transaction.headers = request.headers;\n    transaction.remoteAddress = request.connection && request.connection.remoteAddress;\n\n    if (request.headers[AE_REQ_HEADER_ID] && request.headers[AE_REQ_HEADER_TRANSACTION]) {\n      try {\n        var ae_id = request.headers[AE_REQ_HEADER_ID];\n        var ae_transaction = request.headers[AE_REQ_HEADER_TRANSACTION];\n        ae_transaction = JSON.parse(ae_transaction);\n        transaction.referer_guid = ae_transaction[0];\n        transaction.force_trace = ae_transaction[1];\n        transaction.trip_guid = ae_transaction[2];\n        // NOT USED:\n        // ae_transaction[3] -> WHAT?\n        // ae_transaction[4] -> ip_addr\n        // ae_transaction[5] -> WHAT?\n      }\n      catch (err) {\n        // ignore JSON parsing error\n        console.error(err)\n      }\n    }\n\n    // need to set any config-driven names early for RUM\n    transaction.applyUserNamingRules(request.url);\n\n    /**\n     * Calculate Queue Time\n     *\n     * Queue time is provided by certain providers by stamping the request\n     * header with the time the request arrived at the router.\n     *\n     * Units for queue time are\n     */\n    var qtime = request.headers[REQUEST_HEADER] || request.headers[QUEUE_HEADER];\n    if (qtime) {\n\n      var split = qtime.split('=');\n      if (split.length > 1) {\n        qtime = split[1];\n      }\n\n      var start = parseFloat(qtime);\n\n      if (isNaN(start)) {\n        logger.warn('Queue time header parsed as NaN (' + qtime + ')');\n      }\n      else {\n        if (start > 1e18) start = start / 1e6; // nano seconds\n        else if (start > 1e15) start = start / 1e3; // micro seconds\n        else if (start < 1e12) start = start * 1e3; // seconds\n\n        transaction.queueTime = Date.now() - start;\n      }\n\n    }\n\n    function instrumentedFinish() {\n      /* Stats how many bytes sended and received\n       */\n      transaction.bytesRead = lastIO.bytesRead(request.socket)\n      transaction.bytesWritten = lastIO.bytesWritten(request.socket)\n      lastIO.markOrUpdate(request.socket)\n\n      /* Express breaks URLs up by application, but the unmodified URL can be\n       * recovered from the request via request.originalUrl.\n       */\n      var url = request.originalUrl || request.url;\n\n      /* Naming must happen before the segment and transaction are ended,\n       * because metrics recording depends on naming's side effects.\n       */\n      transaction.setName(url, response.statusCode);\n\n      // This should be the last thing called before the web segment finishes.\n      segment.markAsWeb(url);\n\n      segment.end();\n      transaction.end();\n    }\n    response.once('finish', instrumentedFinish);\n\n    return listener.apply(this, arguments);\n  });\n}\n\nfunction wrapRequest(agent, request) {\n  return agent.tracer.segmentProxy(function wrappedRequest(options, callback) {\n    if (callback && typeof callback === 'function') {\n      // want to bind callack into request regardless of current state\n      callback = agent.tracer.callbackProxy(callback);\n    }\n\n    // don't pollute metrics and calls with NR connections\n    var internalOnly = options && options[NR_CONNECTION_PROP];\n    if (internalOnly) options[NR_CONNECTION_PROP] = undefined;\n\n    var transaction = agent.tracer.getTransaction()\n\n    // inject headers for analytic events\n    if (transaction && !internalOnly) {\n      if (typeof options === 'string') {\n        options = require('url').parse(options);\n      }\n      options.headers = {} || options.headers;\n      // WARNING: maybe cross_process_id is not ready\n      if (agent.config.cross_process_id) {\n        options.headers[AE_REQ_HEADER_ID] = agent.config.cross_process_id;\n        options.headers[AE_REQ_HEADER_TRANSACTION] = JSON.stringify([\n          transaction.guid,\n          transaction.force_trace,\n          transaction.trip_guid,\n          null, // WHAT?\n          myip().join(','),\n          null  // WHAT?\n        ])\n      }\n    }\n\n    var requested = request.call(this, options, callback);\n\n    if (transaction && !internalOnly) {\n      // hostname & port logic pulled directly from node's 0.10 lib/http.js\n      var hostname = options.hostname || options.host || DEFAULT_HOST;\n      var port = options.port || options.defaultPort || DEFAULT_PORT;\n      instrumentOutbound(agent, requested, hostname, port);\n    }\n\n    return requested;\n  });\n}\n\nfunction wrapLegacyRequest(agent, request) {\n  return agent.tracer.segmentProxy(function wrappedLegacyRequest(method, path, headers) {\n\n    // inject headers for analytic events\n    // TODO: legacy nodejs API, I need to check the document\n\n    var requested = request.call(this, method, path, headers);\n\n    if (agent.tracer.getTransaction()) {\n      instrumentOutbound(agent, requested, this.host, this.port);\n    }\n\n    return requested;\n  });\n}\n\nfunction wrapLegacyClient(agent, proto) {\n  shimmer.wrapMethod(\n    proto,\n    'http.Client.prototype',\n    'request',\n    wrapLegacyRequest.bind(null, agent)\n  );\n}\n\nmodule.exports = function initialize(agent, http) {\n  // FIXME: will this ever not be called?\n  shimmer.wrapMethod(http, 'http', 'createServer', function cb_wrapMethod(createServer) {\n    return function setDispatcher(requestListener) {\n      /*jshint unused:false */\n      agent.environment.setDispatcher('http');\n      return createServer.apply(this, arguments);\n    };\n  });\n\n  /**\n   * It's not a great idea to monkeypatch EventEmitter methods given how hot\n   * they are, but this method is simple and works with all versions of\n   * node supported by the module.\n   */\n  shimmer.wrapMethod(http && http.Server && http.Server.prototype,\n                     'http.Server.prototype',\n                     ['on', 'addListener'],\n                     function cb_wrapMethod(addListener) {\n    return function cls_wrapMethod(type, listener) {\n      if (type === 'request' && typeof listener === 'function') {\n        return addListener.call(this, type, wrapListener(agent, listener));\n      }\n      else {\n        return addListener.apply(this, arguments);\n      }\n    };\n  });\n\n  /**\n   * As of node 0.8, http.request() is the right way to originate outbound\n   * requests.\n   */\n  if (http && http.Agent && http.Agent.prototype && http.Agent.prototype.request) {\n    // Node 0.11+ always uses an Agent.\n    shimmer.wrapMethod(\n      http.Agent.prototype,\n      'http.Agent.prototype',\n      'request',\n      wrapRequest.bind(null, agent)\n    );\n  }\n  else {\n    shimmer.wrapMethod(\n      http,\n      'http',\n      'request',\n      wrapRequest.bind(null, agent)\n    );\n  }\n\n  // http.Client is deprecated, but still in use\n  var DeprecatedClient, deprecatedCreateClient;\n  function clearGetters() {\n    if (DeprecatedClient) {\n      delete http.Client;\n      http.Client = DeprecatedClient;\n    }\n    if (deprecatedCreateClient) {\n      delete http.createClient;\n      http.createClient = deprecatedCreateClient;\n    }\n  }\n\n  DeprecatedClient = shimmer.wrapDeprecated(\n    http,\n    'http',\n    'Client',\n    {\n      get : function get() {\n        var example = new DeprecatedClient(80, 'localhost');\n        wrapLegacyClient(agent, example.constructor.prototype);\n        clearGetters();\n\n        return DeprecatedClient;\n      },\n      set : function set(NewClient) {\n        DeprecatedClient = NewClient;\n      }\n    }\n  );\n\n  deprecatedCreateClient = shimmer.wrapDeprecated(\n    http,\n    'http',\n    'createClient',\n    {\n      get : function get() {\n        var example = deprecatedCreateClient(80, 'localhost');\n        wrapLegacyClient(agent, example.constructor.prototype);\n        clearGetters();\n\n        return deprecatedCreateClient;\n      },\n      set : function set(newCreateClient) {\n        deprecatedCreateClient = newCreateClient;\n      }\n    }\n  );\n};\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/metrics/normalizer/rule.js":"'use strict';\n\nvar path   = require('path')\n  , logger = require('oneapm-logger').child({component : 'normalizer_rule'})\n  ;\n\n/**\n * JavaScript just has to do things slightly differently.\n */\nvar replaceReplacer = function replaceReplacer(input) {\n  return input.replace(/\\\\/g, '$');\n};\n\n/**\n * Be liberal about accepting incomplete information, because we don't want\n * bad rules from the collector to crash client apps. Otherwise, this is a\n * fairly straightforward mapping of the concepts in metric normalization\n * rules into an object form.\n *\n * @param {Object} json A JavaScript object literal parsed out from the JSON\n *                      from the collector.\n */\nfunction NormalizerRule(json) {\n  if (!json) {\n    logger.debug(\"Received incompletely specified \" +\n                 \"metric normalization rule from collector.\");\n    json = {};\n  }\n\n  this.eachSegment   = json.each_segment                || false;\n  this.precedence    = json.eval_order                  || 0;\n  this.isTerminal    = json.terminate_chain             || false;\n  this.replacement   = replaceReplacer(json.replacement || '$0');\n  this.replaceAll    = json.replace_all                 || false;\n  this.ignore        = json.ignore                      || false;\n\n  var modifiers = '';\n  if (this.replaceAll) modifiers += 'g';\n\n  // don't allow this to fail\n  if (json.match_expression instanceof RegExp) {\n    this.pattern = json.match_expression;\n  }\n  else {\n    try {\n      this.pattern = new RegExp(json.match_expression || '^$', modifiers);\n      logger.trace(\"Loaded normalization rule: %j\", this);\n    }\n    catch (error) {\n      logger.warn(error, \"Problem compiling metric normalization rule pattern.\");\n      this.pattern = /^$/;\n    }\n  }\n}\n\n/**\n * Allow the higher-level functions to operate on input uniformly.\n *\n * @param {string} input URL to potentially be split.\n */\nNormalizerRule.prototype.getSegments = function getSegments(input) {\n  if (this.eachSegment) {\n    return input.split('/');\n  }\n  else {\n    return [input];\n  }\n};\n\n/**\n * Check if a URL matches a rule.\n *\n * @param {string} input URL to match.\n */\nNormalizerRule.prototype.matches = function matches(input) {\n  var segments = this.getSegments(input);\n\n  for (var i = 0; i < segments.length; i++) {\n    if (segments[i].match(this.pattern)) return true;\n  }\n\n  return false;\n};\n\n/**\n * Apply the substitutions, if any, to the input.\n *\n * @param {string} input URL to normalize.\n */\nNormalizerRule.prototype.apply = function apply(input) {\n  return this.getSegments(input)\n    .map(function cb_map(segment) {\n      /* String.split will return empty segments when the path has a leading\n       * slash or contains a run of slashes. Don't inadvertently substitute or\n       * drop these empty segments, or the normalized path will be wrong.\n       */\n      if (segment === \"\") return segment;\n\n      return segment.replace(this.pattern, this.replacement);\n    }.bind(this))\n    .join('/');\n};\n\nNormalizerRule.prototype.toJSON = function toJSON() {\n  return {\n    eachSegment : this.eachSegment,\n    precedence  : this.precedence,\n    isTerminal  : this.isTerminal,\n    replacement : this.replacement,\n    replaceAll  : this.replaceAll,\n    ignore      : this.ignore,\n    pattern     : this.pattern.source\n  };\n};\n\nmodule.exports = NormalizerRule;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/metrics/recorders/generic.js":"'use strict';\n\nfunction record(segment, scope) {\n  var duration    = segment.getDurationInMillis()\n    , exclusive   = segment.getExclusiveDurationInMillis()\n    , transaction = segment.trace.transaction\n    ;\n\n  if (scope) transaction.measure(segment.name, scope, duration, exclusive);\n\n  transaction.measure(segment.name, null, duration, exclusive);\n}\n\nmodule.exports = record;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/metrics/recorders/http.js":"'use strict';\n\nvar path  = require('path')\n  , NAMES = require(path.join(__dirname, '..', '..', 'metrics', 'names.js'))\n  ;\n\n/*\n *\n * CONSTANTS\n *\n */\nvar TO_MILLIS = 1e3;\n\nfunction recordWeb(segment, scope) {\n  // in web metrics, scope is required\n  if (!scope) return;\n\n  var duration         = segment.getDurationInMillis()\n    , exclusive        = segment.getExclusiveDurationInMillis()\n    , transaction      = segment.trace.transaction\n    , partial          = segment.partialName\n    , config           = segment.trace.transaction.agent.config\n    // named / key transaction support requires per-name apdexT\n    , keyApdexInMillis = config.web_transactions_apdex[scope] * TO_MILLIS\n    ;\n    \n  // transaction.measure(scope,      scope, duration, exclusive);\n  \n  transaction.measure(NAMES.WEB,   null, duration, exclusive);\n  transaction.measure(NAMES.HTTP,  null, duration, exclusive);\n  transaction.measure(scope,       null, duration, exclusive);\n\n  if (transaction.queueTime > 0) {\n    transaction.measure(NAMES.QUEUETIME, null, transaction.queueTime);\n  }\n\n  transaction._setApdex(NAMES.APDEX + '/' + partial, duration, keyApdexInMillis);\n  transaction._setApdex(NAMES.APDEX,                 duration, null);\n}\n\nmodule.exports = recordWeb;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/metrics/recorders/memcached.js":"'use strict';\n\nvar path     = require('path')\n  , NAMES    = require(path.join(__dirname, '..', 'names'))\n  , DS       = NAMES.DATASTORE\n  , MEMCACHE = NAMES.MEMCACHE\n  ;\n\nfunction recordMemcache(segment, scope) {\n  var duration    = segment.getDurationInMillis()\n    , exclusive   = segment.getExclusiveDurationInMillis()\n    , transaction = segment.trace.transaction\n    , type        = transaction.isWeb() ? DS.WEB : DS.OTHER\n    , operation   = segment.name\n    ;\n\n  if (scope) transaction.measure(operation, scope, duration, exclusive);\n\n  transaction.measure(operation, null, duration, exclusive);\n  transaction.measure(type,      null, duration, exclusive);\n  transaction.measure(DS.ALL,    null, duration, exclusive);\n\n  if (segment.port > 0) {\n    var hostname = segment.host || 'localhost'\n      , location = hostname + ':' + segment.port\n      , instance = DS.INSTANCE + '/' + MEMCACHE.PREFIX + '/' + location\n      ;\n\n    transaction.measure(instance, null, duration, exclusive);\n  }\n}\n\nmodule.exports = recordMemcache;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/metrics/recorders/node-cassandra-cql.js":"'use strict';\n\nvar path  = require('path')\n  , NAMES = require(path.join(__dirname, '..', 'names'))\n  , DB    = NAMES.DB\n  , CASSANDRA = NAMES.CASSANDRA\n  ;\n\nfunction record(segment, scope) {\n  var duration    = segment.getDurationInMillis()\n    , exclusive   = segment.getExclusiveDurationInMillis()\n    , transaction = segment.trace.transaction\n    , type        = transaction.isWeb() ? DB.WEB : DB.OTHER\n    , operation   = segment.name\n    ;\n\n  if (scope) transaction.measure(operation, scope, duration, exclusive);\n\n  transaction.measure(operation, null, duration, exclusive);\n  transaction.measure(type,      null, duration, exclusive);\n  transaction.measure(DB.ALL,    null, duration, exclusive);\n\n  if (segment.port > 0) {\n    var hostname = segment.host || 'localhost'\n      , location = hostname + ':' + segment.port\n      , instance = DB.INSTANCE + '/' + CASSANDRA.PREFIX + '/' + location\n      ;\n\n    transaction.measure(instance, null, duration, exclusive);\n  }\n}\n\nmodule.exports = record;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/metrics/recorders/redis.js":"'use strict';\n\nvar path  = require('path')\n  , NAMES = require(path.join(__dirname, '..', 'names'))\n  , DS    = NAMES.DATASTORE\n  , REDIS = NAMES.REDIS\n  ;\n\nfunction recordRedis(segment, scope) {\n  var duration    = segment.getDurationInMillis()\n    , exclusive   = segment.getExclusiveDurationInMillis()\n    , transaction = segment.trace.transaction\n    , type        = transaction.isWeb() ? DS.WEB : DS.OTHER\n    , operation   = segment.name\n    ;\n\n  if (scope) transaction.measure(operation, scope, duration, exclusive);\n\n  transaction.measure(operation, null, duration, exclusive);\n  transaction.measure(type,      null, duration, exclusive);\n  transaction.measure(DS.ALL,    null, duration, exclusive);\n\n  if (segment.port > 0) {\n    var hostname = segment.host || 'localhost'\n      , location = hostname + ':' + segment.port\n      , instance = DS.INSTANCE + '/' + REDIS.PREFIX + '/' + location\n      ;\n\n    transaction.measure(instance, null, duration, exclusive);\n  }\n}\n\nmodule.exports = recordRedis;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/metrics/recorders/thrift.js":"'use strict';\n\nvar path  = require('path')\n  , NAMES = require(path.join(__dirname, '..', 'names.js'))\n  ;\n\n/*\n *\n * CONSTANTS\n *\n */\nvar TO_MILLIS = 1e3;\n\nfunction recordThrift(segment, scope) {\n  // in web metrics, scope is required\n  if (!scope) return;\n\n  var duration         = segment.getDurationInMillis()\n    , exclusive        = segment.getExclusiveDurationInMillis()\n    , transaction      = segment.trace.transaction\n    , partial          = segment.partialName\n    , config           = segment.trace.transaction.agent.config\n    // named / key transaction support requires per-name apdexT\n    , keyApdexInMillis = config.web_transactions_apdex[scope] * TO_MILLIS\n    ;\n    \n  // transaction.measure(scope,      scope, duration, exclusive);\n\n  // Lance: Maybe we don't need so many types for thrift?\n  \n  transaction.measure(NAMES.WEB,   null, duration, exclusive);\n  transaction.measure(NAMES.HTTP,  null, duration, exclusive);\n  transaction.measure(scope,       null, duration, exclusive);\n\n  if (transaction.queueTime > 0) {\n    transaction.measure(NAMES.QUEUETIME, null, transaction.queueTime);\n  }\n\n  transaction._setApdex(NAMES.APDEX + '/' + 'thrift', duration, keyApdexInMillis);\n  transaction._setApdex(NAMES.APDEX,                 duration, null);\n}\n\nmodule.exports = recordThrift;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/transaction/trace/aggregator.js":"'use strict';\n\n/*\n *\n * CONSTANTS\n *\n */\nvar TO_MILLIS = 1e3;\n\n/**\n * Locus for the complicated logic surrounding the selection of slow\n * transaction traces for submission to the collector.\n *\n * @param {object} config Dictionary containing transaction tracing\n *                        parameters. Required.\n */\nfunction TraceAggregator(config) {\n  if (!config) throw new Error(\"Trace aggregator needs configuration at creation.\");\n\n  /**\n   * 5 Transaction Trace Guarantee\n   *\n   * For the initial experience problem, the Agent will sample up to 1\n   * transaction per minute until it has sampled 5 transactions. This\n   * guarantees that the agent will always report some transaction traces.\n   * There is no time out for this sampling period - the agent always\n   * samples until it has collected 5 transactions. The agent doesn't\n   * simply report the first 5 transactions that it sees because it's\n   * likely (particularly for a local dev test) that all 5 transactions\n   * would be associated with one request (a single web page and its\n   * resources).\n   */\n  this.reported = 0;\n  this.config   = config;\n\n  // Setting up top n capacity.\n  this.capacity = 1;\n  if (config.transaction_tracer &&\n      config.transaction_tracer.top_n) {\n    this.capacity = config.transaction_tracer.top_n;\n  }\n\n  // hidden class optimization\n  this.trace            = null;\n  this.requestTimes     = {};\n  this.noTraceSubmitted = 0;\n}\n\n/**\n * For every five harvest cycles (or \"minutes\"), if no new slow transactions\n * have been added, reset the requestTime match and allow a new set of five\n * to start populating the Top N Slow Trace list.\n */\nTraceAggregator.prototype.resetTimingTracker = function resetTT() {\n  this.requestTimes     = {};\n  this.noTraceSubmitted = 0;\n};\n\n/**\n * Add a trace to the slow trace list, if and only if it fulfills the necessary\n * criteria.\n *\n * @param {Transaction} transaction The transaction, which we need to check\n *                                  apdexT, as well as getting the trace.\n */\nTraceAggregator.prototype.add = function add(transaction) {\n  if (this.config.collect_traces &&\n      this.config.transaction_tracer && this.config.transaction_tracer.enabled &&\n      transaction && transaction.metrics) {\n    var trace    = transaction.getTrace()\n      , name     = transaction.name\n      , duration = trace.getDurationInMillis()\n      , apdexT   = transaction.metrics.apdexT\n      ;\n\n    if (this.isBetter(name, duration, apdexT)) {\n      this.trace = trace;\n\n      // because of the \"first 5\" rule, this may or may not be the slowest\n      if (!this.requestTimes[name] || this.requestTimes[name] < duration) {\n        this.requestTimes[name] = duration;\n      }\n    }\n\n    this.config.measureInternal('Transaction/Count', duration);\n  }\n};\n\n/**\n * If there's a slow trace to be sent, encode it and pass it along\n * to the callback, otherwise update the relevant trace diversity settings.\n *\n * @param Function callback The receiver of the encoded trace or errors.\n */\nTraceAggregator.prototype.harvest = function harvest(callback) {\n  // calls out to zlib are asynchronous\n  if (this.trace) {\n    this.noTraceSubmitted = 0;\n    this.trace.generateJSON(callback);\n  }\n  else {\n    this.noTraceSubmitted++;\n    if (this.noTraceSubmitted >= 5) this.resetTimingTracker();\n\n    process.nextTick(function cb_nextTick() { callback(null, null, null); });\n  }\n};\n\n/**\n * Reset the trace diversity settings after a successful harvest.\n *\n * @param {Trace} trace Because the harvest cycle can take a while,\n *                      it's possible a better trace came along\n *                      in the window between the start and end of\n *                      the harvest cycle, so don't throw that away.\n */\nTraceAggregator.prototype.reset = function reset(trace) {\n  this.reported++;\n  if (trace === this.trace) this.trace = null;\n};\n\n/**\n * Determine whether a new trace is more worth keeping than an old one.\n * This gets called on every single transactionFinished event, so return as\n * quickly as possible and call as few external functions as possible. On the\n * converse, there's some complicated logic here, so spell things out.\n *\n * @param {string} name     Name of this transaction's key metric.\n * @param {number} duration Time the transaction took, in milliseconds.\n * @param {number} apdexT   Apdex tolerating threshold, in seconds.\n */\nTraceAggregator.prototype.isBetter = function isBetter(name, duration, apdexT) {\n\n  if(process.env.ONEAPM_FORCE_TRACE_COLLECT){\n    return true;\n  }\n\n  /* 1. If the transaction duration is below the tracing threshold, the\n   *    transaction is skipped.\n   *\n   * The threshold for slow traces defaults to apdex_f, which is 4 * apdex_t.\n   */\n  var config = this.config.transaction_tracer\n    , isOverThreshold\n    ;\n  if (config &&\n      config.transaction_threshold &&\n      config.transaction_threshold !== 'apdex_f' &&\n      typeof config.transaction_threshold === 'number') {\n    isOverThreshold = duration > config.transaction_threshold * TO_MILLIS;\n  }\n  else {\n    isOverThreshold = duration > 4 * TO_MILLIS * apdexT;\n  }\n  if (!isOverThreshold) return false;\n\n  /* 2. If the transaction duration is less than the duration of the current\n   *    slow transaction, the transaction is skipped.\n   */\n  var slowerThanExisting = true;\n  if (this.trace) {\n    slowerThanExisting = this.trace.getDurationInMillis() < duration;\n  }\n  if (!slowerThanExisting) return false;\n\n  /* We always gather some slow transactions at the start, regardless of\n   * the size of Top N. This changes the behavior of the rest of the\n   * decision-making process in some subtle ways.\n   */\n  var hasMetGuarantee = this.reported >= 5;\n\n  /* 3. If the transaction's name is in the transaction map and its duration\n   *    is less than the response time in the map, it is skipped.\n   */\n  var slowerThanCaptured = true;\n  if (hasMetGuarantee) {\n    if (this.requestTimes[name]) {\n      slowerThanCaptured = this.requestTimes[name] < duration;\n    }\n  }\n  if (!slowerThanCaptured) return false;\n\n  /* Not part of enumerated rules, but necessary for Top N support:\n   * Ensure this name is either already in the request time map\n   * or that the map still hasn't hit capacity.\n   */\n  if (hasMetGuarantee &&\n      !this.requestTimes[name] &&\n      Object.keys(this.requestTimes).length >= this.capacity) {\n    return false;\n  }\n\n  /* 4. The transaction is held as the slowest transaction.\n   */\n  return true;\n};\n\nmodule.exports = TraceAggregator;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/transaction/tracer/debug.js":"'use strict';\n\nvar path          = require('path')\n  , cls           = require('continuation-local-storage')\n  , util          = require('util')\n  , NRTransaction = require(path.join(__dirname, '..', '..', 'transaction'))\n  , NRTracer      = require(path.join(__dirname, '..', 'tracer'))\n  ;\n\n/*\n *\n * CONSTANTS\n *\n */\nvar TRACER = '__NR_tracer';\n\n/* Just in case something decides to use the production and\n * debugging tracers at the same time.\n */\nvar namespace = process.namespaces[TRACER];\nif (!namespace) namespace = cls.createNamespace(TRACER);\n\n/**\n * Instead of eating the overhead of creating two separate async listeners\n * to handle CLS and error-tracing, reuse the existing CLS error callback.\n *\n * @param {Agent} agent The current agent instance.\n * @param {Namespace} namespace CLS instance.\n */\nfunction _patchErrorTracerOntoCLS(agent, namespace) {\n  var callbacks = namespace && namespace.id && namespace.id.callbacks;\n  if (callbacks && callbacks.error) {\n    callbacks.error = function error(domain, error) {\n      var context = namespace.fromException(error);\n      var transaction = context && context.transaction;\n      agent.errors.add(transaction, error);\n\n      if (domain) namespace.exit(domain);\n    };\n  }\n}\n\n/**\n *\n *\n * THE MODEL:\n *\n * A simple set of classes intended to model a call chain within the scope of\n * a OneAPM transaction trace. The players are transactions (e.g. web page\n * requests), trace segments for subsidiary calls (e.g. database or memcached\n * calls), and instrumented callbacks.\n *\n * The goal is to be able to model the scenarios outlined in the test cases,\n * copied up here for easy reference:\n *\n * a. direct function execution\n * b. an asynchronous function -- that is, a function that returns a callback,\n *    that can be executed at an arbitrary future time\n * c. two overlapping executions of an asynchronous function and its callback\n * d. direct function execution, including direct execution of an instrumented\n *    subsidiary function\n * e. an asynchronous function that calls an asynchronous subsidiary function\n * f. two overlapping executions of an asynchronous function with an\n *    asynchronous subsidiary function\n *\n * Here are some of the rules the model is intended to follow:\n *\n * 1. Every call, segment, and transaction has an ID (for the purposes of these\n *    tests, that ID is derived from how many of each thing are associated\n *    with a given trace).\n * 2. Every Call is associated with a Segment.\n * 3. Every Segment is associated with a Trace.\n *\n *\n */\n\n/**\n * CALL\n */\nfunction Call(id, segment, value) {\n  if (!id) throw new Error(\"Calls must have an ID.\");\n  if (!segment) throw new Error(\"Calls must be associated with a segment.\");\n  if (!value) throw new Error(\"Calls must be associated with a segment value.\");\n\n  this.id      = id;\n  this.segment = segment;\n  this.value   = value;\n}\n\nCall.prototype.format = function format() {\n  return util.format(\"T%dS%dC%d\",\n                     this.segment.transaction.id,\n                     this.segment.id,\n                     this.id);\n};\n\n\n/**\n * SEGMENT\n */\nfunction Segment(id, transaction, value) {\n  if (!id) throw new Error(\"Segments must have an ID.\");\n  if (!transaction) throw new Error(\"Segments must be associated with a transaction.\");\n  if (!value) throw new Error(\"Segments must be associated with a value.\");\n\n  this.id          = id;\n  this.transaction = transaction;\n  this.value       = value;\n\n  this.numCalls = 0;\n}\n\nSegment.prototype.addCall = function addCall(value) {\n  this.numCalls += 1;\n  return new Call(this.numCalls, this, value);\n};\n\n\n/**\n * TRANSACTION\n */\nfunction Transaction (id, value) {\n  if (!id) throw new Error(\"Transactions must have an ID.\");\n  if (!value) throw new Error(\"Transactions must be associated with a value.\");\n\n  this.id    = id;\n  this.value = value;\n\n  this.numSegments = 0;\n}\n\nTransaction.prototype.addSegment = function addSegment(value) {\n  this.numSegments += 1;\n  return new Segment(this.numSegments, this, value);\n};\n\nfunction Describer() {\n  this.trace     = [];\n  this.creations = [];\n  this.wrappings = [];\n\n  this.verbose   = [];\n}\n\nDescriber.prototype.clone = function clone() {\n  var cloned = new Describer();\n\n  cloned.trace     = this.trace.slice();\n  cloned.creations = this.creations.slice();\n  cloned.wrappings = this.wrappings.slice();\n  cloned.verbose   = this.verbose.slice();\n\n  return cloned;\n};\n\nDescriber.prototype.traceCall = function traceCall(direction, call) {\n  var id = direction + call.format();\n\n  this.trace.push(id);\n  this.verbose.push(id);\n};\n\nDescriber.prototype.traceCreation = function traceCreation(type) {\n  var creation = util.format(\"+%s\", type[0]);\n\n  this.creations.push(creation);\n  this.verbose.push(creation);\n};\n\nDescriber.prototype.traceWrapping = function traceWrapping(direction, type) {\n  var wrapping = util.format(\"%s%s\", direction, type);\n\n  this.wrappings.push(wrapping);\n  this.verbose.push(wrapping);\n};\n\n/**\n * EXECUTION TRACER\n *\n * One instance of this class exists per transaction, with the state\n * representing the current context shared between multiple instances.\n *\n * The transaction tracer works by wrapping either the generator functions\n * that asynchronously handle incoming requests (via\n * Tracer.transactionProxy and Tracer.segmentProxy) or direct function\n * calls in the form of callbacks (via Tracer.callbackProxy).\n *\n * In both cases, the wrappers exist to set up the execution context for\n * the wrapped functions. The context is effectively global, and works in\n * a manner similar to Node 0.8's domains, by explicitly setting up and\n * tearing down the current transaction / segment / call around each\n * wrapped function's invocation. It relies upon the fact that Node is\n * single-threaded, and requires that each entry and exit be paired\n * appropriately so that the context is left in its proper state.\n *\n * This version is optimized for debugging. A new version should be made\n * for production use without all of the internal tracing information\n * included.\n */\nfunction Tracer(agent) {\n  if (!agent) throw new Error(\"Must be initialized with an agent.\");\n\n  this.numTransactions = 0;\n  this.agent           = agent;\n  this.describer       = new Describer();\n\n  _patchErrorTracerOntoCLS(agent, namespace);\n}\n\nTracer.prototype.getTransaction = function getTransaction() {\n  var transaction = namespace.get('transaction');\n  if (transaction && transaction.value && transaction.value.isActive()) {\n    return transaction.value;\n  }\n};\n\nTracer.prototype.setTransaction = function setTransaction(transaction) {\n  namespace.set('transaction', transaction);\n};\n\nTracer.prototype.getSegment = function getSegment() {\n  return namespace.get('segment') && namespace.get('segment').value;\n};\n\nTracer.prototype.setSegment = function setSegment(segment) {\n  namespace.set('segment', segment);\n};\n\nTracer.prototype.addSegment = function addSegment(name, recorder) {\n  var current              = this.getSegment()\n    , segment              = current.add(name, recorder)\n    , transactionContainer = namespace.get('transaction')\n    , transaction          = transactionContainer.value\n    , describer            = transaction.describer\n    , segmentContainer     = this.traceSegment(transactionContainer, segment, describer)\n    ;\n\n  this.setSegment(segmentContainer);\n\n  return segment;\n};\n\n\nTracer.prototype.enter = function enter(call, describer) {\n  describer.traceCall('->', call);\n};\n\nTracer.prototype.exit = function exit(call, describer) {\n  describer.traceCall('<-', call);\n};\n\nTracer.prototype.traceTransaction = function traceTransaction(value, describer) {\n  this.numTransactions += 1;\n\n  describer.traceCreation('Trace');\n  return new Transaction(this.numTransactions, value, describer);\n};\n\nTracer.prototype.traceSegment = function traceSegment(transaction, value, describer) {\n  describer.traceCreation('Segment');\n  return transaction.addSegment(value);\n};\n\nTracer.prototype.traceCall = function traceCall(segment, value, describer) {\n  describer.traceCreation('Call');\n  return segment.addCall(value);\n};\n\n/**\n * Use transactionProxy to wrap a closure that is a top-level handler that is\n * meant to originate transactions. This is meant to wrap the first half of\n * async calls, not their callbacks.\n *\n * @param {Function} handler Generator to be proxied.\n * @returns {Function} Proxied function.\n */\nTracer.prototype.transactionProxy = function transactionProxy(handler) {\n  // if there's no handler, there's nothing to proxy.\n  if (!handler) return;\n\n  this.describer.traceWrapping('->', 'T outer');\n\n  var self = this;\n  var wrapped = function wrapTransactionInvocation() {\n    var describer = self.describer.clone();\n    describer.traceWrapping('->', 'T inner');\n\n    // don't nest transactions, reuse existing ones\n    var transaction          = self.getTransaction() || new NRTransaction(self.agent)\n      , segment              = transaction.getTrace().root\n      , proxied              = this\n      , args                 = self.slice(arguments)\n      , transactionContainer = self.traceTransaction(transaction, describer)\n      , segmentContainer     = self.traceSegment(transactionContainer, segment, describer)\n      , callContainer        = self.traceCall(segmentContainer, handler, describer)\n      ;\n\n    /* NOICE HAX D00D\n     *\n     * Will leave the end state of the transaction, including the various\n     * traces, attached to the transaction.\n     */\n    transaction.describer = describer;\n\n    self.enter(callContainer, describer);\n    var returned;\n    namespace.bind(function cb_bind() {\n      self.setTransaction(transactionContainer);\n      self.setSegment(segmentContainer);\n      returned = namespace.bind(handler).apply(proxied, args);\n    }, Object.create(null))();\n    self.exit(callContainer, describer);\n\n    describer.traceWrapping('<-', 'T inner');\n    return returned;\n  };\n\n  this.describer.traceWrapping('<-', 'T outer');\n  return wrapped;\n};\n\n/**\n * Use segmentProxy to wrap a closure that is a top-level handler that is\n * meant to participate in an existing transaction. It will add itself as a\n * new subsidiary to the current transaction. This is meant to wrap the first\n * half of async calls, not their callbacks.\n *\n * @param {Function} handler Generator to be proxied.\n * @returns {Function} Proxied function.\n */\nTracer.prototype.segmentProxy = function segmentProxy(handler) {\n  // if there's no handler, there's nothing to proxy.\n  if (!handler) return;\n\n  this.describer.traceWrapping('->', 'S outer');\n\n  var self = this;\n  var wrapped = function wrapSegmentInvocation() {\n    // don't implicitly create transactions\n    var transactionContainer = namespace.get('transaction');\n    if (!transactionContainer) return handler.apply(this, arguments);\n\n    var transaction = transactionContainer.value;\n    if (!transaction.isActive()) return handler.apply(this, arguments);\n\n    var describer = transaction.describer;\n    describer.traceWrapping('->', 'S inner');\n\n    var segment          = self.getSegment()\n      , segmentContainer = self.traceSegment(transactionContainer, segment, describer)\n      , callContainer    = self.traceCall(segmentContainer, handler, describer)\n      , context          = namespace.createContext()\n      ;\n\n    context.segment = segmentContainer;\n    context.call = callContainer;\n\n    self.enter(callContainer, describer);\n    var returned = namespace.bind(handler, context).apply(this, arguments);\n    self.exit(callContainer, describer);\n\n    describer.traceWrapping('<-', 'S inner');\n    return returned;\n  };\n\n  this.describer.traceWrapping('<-', 'S outer');\n  return wrapped;\n};\n\n/**\n * Use callbackProxy to wrap a closure that may invoke subsidiary functions that\n * want access to the current transaction. When called, it sets up the correct\n * context before invoking the original function (and tears it down afterwards).\n *\n * Proxying of individual calls is only meant to be done within the scope of\n * an existing transaction. It\n *\n * @param {Function} handler Function to be proxied on invocation.\n * @returns {Function} Proxied function.\n */\nTracer.prototype.callbackProxy = function callbackProxy(handler) {\n  // if there's no handler, there's nothing to proxy.\n  if (!handler) return;\n\n  // don't implicitly create transactions\n  var transaction = this.getTransaction();\n  if (!transaction) return handler;\n\n  var describer = transaction.describer;\n  describer.traceWrapping('->', 'C outer');\n\n  var segmentContainer = namespace.get('segment')\n    , callContainer    = this.traceCall(segmentContainer, handler, describer)\n    ;\n\n  var context = namespace.createContext();\n  context.segment = segmentContainer;\n  context.call = callContainer;\n\n  var self = this;\n  var wrapped = namespace.bind(function cb_bind() {\n    describer.traceWrapping('->', 'C inner');\n\n    self.enter(callContainer, describer);\n    var returned = handler.apply(this, arguments);\n    self.exit(callContainer, describer);\n\n    describer.traceWrapping('<-', 'C inner');\n    return returned;\n  }, context);\n\n  describer.traceWrapping('<-', 'C outer');\n  return wrapped;\n};\n\nTracer.prototype.bindEmitter = NRTracer.prototype.bindEmitter;\nTracer.prototype.setCurrentSegmentType = NRTracer.prototype.setCurrentSegmentType;\nTracer.prototype.isCurrentSegmentType = NRTracer.prototype.isCurrentSegmentType;\nTracer.prototype.slice = NRTracer.prototype.slice;\n\nmodule.exports = Tracer;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/transaction/trace/sql.js":"'use strict';\n\nvar path  = require('path')\n  , codec = require(path.join(__dirname, '..', '..', 'util', 'codec'))\n  ;\n\nfunction SQLTrace(query, transaction, stats) {\n  if (!query) throw new Error(\"Can't create SQL trace without SQL!\");\n  if (!transaction) throw new Error(\"Can't create SQL trace without transaction.\");\n  if (!stats) throw new Error(\"Can't create SQL trace without statistics.\");\n\n  this.query       = query;\n  this.transaction = transaction;\n  this.stats       = stats;\n}\n\n/**\n * Because encoding is asynchronous, this must also be asynchronous.\n *\n * Thank goodness for events!\n *\n * @param {string} name FIXME: only need to come up with a path at\n *                      generation time for some reason.\n * @param {object} params The parameters for the query, if any.\n * @param {Function} callback After generation, hand off the results.\n *                            First parameter is errors, second is\n *                            JSON-ready array.\n */\nSQLTrace.prototype.generateJSON = function generateJSON(name, params, callback) {\n  codec.encode(params, function cb_encode(err, encoded) {\n    if (err) return callback(err);\n\n    return callback(null,\n                    [\n                      name,\n                      this.transaction.url,\n                      this.getSQLId(),\n                      this.query,\n                      this.stats.callCount,\n                      this.stats.total,\n                      this.stats.min,\n                      this.stats.max,\n                      encoded\n                    ]);\n  }.bind(this));\n};\n\nSQLTrace.prototype.getSQLId = function getSQLId() {\n  var h = 0;\n\n  var buf = new Buffer(this.query);\n  var len = buf.length;\n  for (var i = 0; i < len; i++) {\n    h = 31 * h + buf.readUInt8(i);\n    h = h & 0xFFFFFFFF;\n  }\n  return h;\n};\n\nmodule.exports = SQLTrace;\n","/home/travis/build/npmtest/node-npmtest-oneapm/node_modules/oneapm/lib/util/sql/obfuscate.js":"'use strict'\n\nmodule.exports = obfuscate\n\nvar singleQuote = /'(?:[^']|'')*?(?:\\\\'.*|'(?!'))/\nvar doubleQuote = /\"(?:[^\"]|\"\")*?(?:\\\\\".*|\"(?!\"))/\nvar dollarQuote = /(\\$(?!\\d)[^$]*?\\$).*?(?:\\1|$)/\nvar oracleQuote = /q'\\[.*?(?:\\]'|$)|q'\\{.*?(?:\\}'|$)|q'\\<.*?(?:\\>'|$)|q'\\(.*?(?:\\)'|$)/\nvar comment = /(?:#|--).*?(?=\\r|\\n|$)/\nvar multilineComment = /\\/\\*(?:[^/]|\\/[^*])*?(?:\\*\\/|\\/\\*.*)/\nvar uuid = /\\{?(?:[0-9a-f]\\-*){32}\\}?/\nvar hex = /0x[0-9a-f]+/\nvar boolean = /true|false|null/\nvar number = /\\b-?(?:[0-9]+\\.)?[0-9]+([eE][+-]?[0-9]+)?/\n\nvar namedePlaceholder = /(?:\\?)|(?::(\\d+|(?:[a-zA-Z][a-zA-Z0-9_]*)))/\n\nvar dialects = {}\n\ndialects.mysql = [\n  replacer(join(\n    [doubleQuote, singleQuote, comment, multilineComment, hex, boolean, number],\n    'gi'\n  )),\n  unmatchedPairs(/'|\"|\\/\\*|\\*\\//)\n]\n\ndialects.mysql2 = [\n  replacer(join(\n    [doubleQuote, singleQuote, comment, multilineComment, hex, boolean, number, namedePlaceholder],\n    'gi'\n  )),\n  unmatchedPairs(/'|\"|\\/\\*|\\*\\//)\n]\n\n\ndialects.postgres = [\n  replacer(join(\n    [dollarQuote, singleQuote, comment, multilineComment, uuid, boolean, number],\n    'gi'\n  )),\n  unmatchedPairs(/'|\\/\\*|\\*\\/|\\$/)\n]\n\ndialects.cassandra = [\n  replacer(join(\n    [singleQuote, comment, multilineComment, uuid, hex, boolean, number],\n    'gi'\n  )),\n  unmatchedPairs(/'|\\/\\*|\\*\\//)\n]\n\ndialects.oracle = [\n  replacer(join(\n    [oracleQuote, singleQuote, comment, multilineComment, number],\n    'gi'\n  )),\n  unmatchedPairs(/'|\\/\\*|\\*\\//)\n]\n\nfunction obfuscate(raw, dialect) {\n  if (!dialects[dialect]) throw new Error('Unknown sql implementation')\n  var replacers = dialects[dialect]\n  var obfuscated = raw\n  for (var i = 0, l = replacers.length; i < l; ++i) {\n    obfuscated = replacers[i](obfuscated)\n  }\n\n  return obfuscated\n}\n\nfunction join(expressions, flags) {\n  return new RegExp(expressions.map(toPart).join('|'), flags)\n}\n\nfunction toPart(expressions) {\n  return expressions.toString().slice(1, -1)\n}\n\nfunction replacer(regex) {\n  return function replace(sql) {\n    return sql.replace(regex, '?')\n  }\n}\n\nfunction unmatchedPairs(regex) {\n  return function check(sql) {\n    return regex.test(sql) ? '?' : sql\n  }\n}\n"}